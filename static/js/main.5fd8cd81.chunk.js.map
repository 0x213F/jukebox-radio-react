{"version":3,"sources":["components/Player/Player.module.css","config/global.js","utils/network.js","components/Chat/network.js","config/api.js","components/Login/network.js","components/Player/network.js","components/Queue/network.js","components/UserSettings/network.js","config/services.js","components/PlaybackWrapper/playback.js","utils/reducers/feed.js","utils/reducers/marker.js","utils/reducers/queue.js","utils/reducers/stream.js","utils/reducers/playback.js","utils/reducers/queueInterval.js","utils/reducers/textComment.js","utils/reducers/textCommentModification.js","utils/reducers/voiceRecording.js","utils/redux.js","components/Login/Login.js","components/VoiceRecording/network.js","components/NotableText/network.js","components/NotableText/NotableText.js","components/TextComment/network.js","components/TextComment/TextComment.js","components/VoiceRecording/VoiceRecording.js","components/Chat/Chat.js","config/model.js","components/TrackMarker/network.js","components/QueueInterval/network.js","components/TrackMarker/TrackMarker.js","components/QueueInterval/QueueInterval.js","components/QueueEdit/QueueEdit.js","components/QueueTrack/QueueTrack.js","components/QueueCollection/QueueCollection.js","components/Queue/Queue.js","components/Search/network.js","components/SearchResult/SearchResult.js","components/Search/Search.js","components/SpotifySync/network.js","components/SpotifySync/SpotifySync.js","components/Upload/network.js","components/Upload/Upload.js","components/Player/Player.js","components/UserSettings/UserSettings.js","components/PlaybackWrapper/PlaybackWrapper.js","App.js","reportWebVitals.js","index.js","components/Upload/Upload.module.css","components/QueueCollection/QueueCollection.module.css","components/Login/Login.module.css","components/Search/Search.module.css","components/QueueTrack/QueueTrack.module.css","components/Chat/Chat.module.css","components/NotableText/NotableText.module.css","components/TextComment/TextComment.module.css","components/VoiceRecording/VoiceRecording.module.css","components/Queue/Queue.module.css"],"names":["module","exports","BACKEND_DOMAIN","process","TYPE_GET","TYPE_POST","fetchBackend","a","method","url","data","formData","FormData","Object","entries","key","value","append","requestOptions","headers","token","localStorage","getItem","Authorization","request","Request","fetch","mode","body","response","searchParams","URLSearchParams","set","getUrl","toString","fetchTextCommentCreate","text","format","textCommentUuid","textCommentTimestamp","json","responseJson","fetchTextCommentList","fetchVoiceRecordingList","fetchAuthToken","username","password","fetchInitializeStream","fetchVerifyToken","status","undefined","fetchStreamGet","fetchTrackGetFiles","trackUuid","fetchNextTrack","nowPlayingTotalDurationMilliseconds","isPlanned","fetchPauseTrack","fetchPlayTrack","fetchPrevTrack","fetchScanBackward","fetchScanForward","fetchQueueList","fetchDeleteQueue","queueUuid","fetchGetUserSettings","SERVICE_SPOTIFY","SERVICE_YOUTUBE","SERVICE_JUKEBOX_RADIO","getPositionMilliseconds","stream","startedAt","nowPlaying","seekTimeout","progress","Date","now","playbackIntervalIdx","cumulativeProgress","playbackInterval","playbackIntervals","playbackIntervalDuration","remainingProgress","length","playbackPause","playback","playbackService","track","service","spotifyApi","pause","uuid","files","audio","playbackSeek","positionMilliseconds","seek","load","currentTime","play","playbackPlay","RENDER_STATUS_HIDE","feedGenerate","state","displayThreshold","historyThreshold","textComments","voiceRecordings","aggregateFeed","map","el","shouldTagHistory","timestampMilliseconds","shouldTagDisplay","renderStatus","filter","i","sort","b","isPlaying","pausedAt","feedUpdate","feed","markerCreate","action","trackMarkerMap","marker","sortedMarkers","markerDelete","filteredMarkers","m","markerList","markers","finalizeQueue","queue","copy","children","editedChildren","totalDurationMilliseconds","reduce","total","q","durationMilliseconds","intervals","trackDurationMilliseconds","lowerBound","upperBound","interval","push","queueListSet","payload","lastUpQueues","nextUpQueues","_lastPlayed","isPaused","lastUp","nextUp","streamSet","obj","streamPlay","updatedPayload","streamPause","streamPrevTrack","lastNowPlaying","nextUpQueue","nextNowPlaying","isTrackInCollection","parentUuid","unshift","pop","streamNextTrack","shift","getNextUp","playbackSpotify","isReady","playbackAddToQueue","externalId","playbackQueue","queuedUp","noopNextTrack","playbackPlannedNextTrackHelper","addToQueueTimeoutId","nextSeekTimeoutId","skipToNext","playbackSkipToNext","clearTimeout","playbackPlannedNextTrack","updatedState","childPayload","updatedNowPlaying","playbackStart","playbackStarted","playbackAddToQueueReschedule","playbackAddToQueueScheduled","playbackNextSeekScheduled","playbackDisable","controlsEnabled","playbackEnable","playbackLoadFiles","Audio","audioUrl","findByUuid","o","sortQueueIntervals","queueIntervalCreate","index","queueInterval","parentQueueUuid","queues","parentIndex","findIndex","trackQueue","sortedQueueIntervals","finalizedNextUpQueues","queueIntervalDelete","filteredQueueIntervals","textCommentListSet","textCommentCreate","textComment","textCommentDelete","textCommentModificationCreate","textCommentModification","textCommentIndex","t","modifications","sortedModifications","startPtr","voiceRecordingListSet","voiceRecordingCreate","voiceRecording","voiceRecordingDelete","voiceRecordingUuid","initialState","userSettings","streamExpire","queueDeleteNode","filteredQueues","queueDeleteChildNode","filteredChildren","textCommentClearModifications","userGetSettings","store","createStore","type","window","__REDUX_DEVTOOLS_EXTENSION__","trace","Login","props","useState","setUsername","setPassword","rememberMe","setRememberMe","handleSubmit","e","preventDefault","access","refresh","setItem","location","reload","className","styles","onSubmit","to","FormBlock","name","placeholder","onChange","target","fetchCreateVoiceRecording","audioFile","transcriptData","transcriptFinal","fetchDeleteVoiceRecording","fetchCreateTextCommentModification","style","anchorOffset","focusOffset","STYLE_BOLD","STYLE_ITALICIZE","STYLE_STRIKETHROUGH","STYLE_CHOICES","connect","textColor","selectableRef","useRef","selectableIsShowable","setSelectableIsShowable","setAnchorOffset","setFocusOffset","handleNotation","dispatch","redux","onTextSelect","selection","getSelection","anchorNode","focusNode","offset","parseInt","parentNode","getAttribute","onTextUnselect","NotableText","color","ref","textCommentText","startOffset","textCommentHtml","modification","regSubString","substring","styledSubString","endPtr","renderTextComment","selectionRef","isOpen","onClick","fetchDeleteTextComment","fetchListDeleteTextCommentModifications","deleteTextComment","clearModifications","TextComment","notation","engraverParams","staffwidth","handleDelete","VoiceRecording","setText","setTextCommentUuid","setTextCommentTimestamp","isAbc","setIsAbc","isRecording","setIsRecording","MicRecorder","bitRate","recorder","useEffect","periodicTask","setInterval","clearInterval","handleTextChange","position","createTextComment","useSpeechRecognition","transcript","resetTranscript","Chat","class","CreateTextComment","checked","SpeechRecognition","browserSupportsSpeechRecognition","stopListening","stop","getMp3","then","buffer","blob","file","File","lastModified","JSON","stringify","startListening","continuous","start","disabled","fetchStreamMarkerCreate","fetchStreamMarkerDelete","markerUuid","fetchStreamMarkerList","fetchStreamQueueIntervalCreate","lowerBoundMarkerUuid","upperBoundMarkerUuid","isMuted","repeatCount","fetchStreamQueueIntervalDelete","queueIntervalUuid","trackMarker","deleteTrackMarker","deleteQueueInterval","formMarkerTimestamp","setFormMarkerTimestamp","setLowerBoundMarkerUuid","setUpperBoundMarkerUuid","loadData","createTrackMarker","createQueueInterval","showEditing","setShowEditing","edit","save","currentIndex","isNextUp","indent","QueueTrack","Button","destroy","isCurrentlyPlayingCollection","reveal","setReveal","toggleReveal","QueueCollection","Item","collection","Children","destroyQueueItem","Queue","fetchSearchMusicLibrary","query","providerSpotify","providerYouTube","providerJukeboxRadio","formatTrack","formatAlbum","formatPlaylist","formatVideo","fetchCreateQueue","genericUuid","SearchResult","searchResult","provider","addToQueue","searchResults","setSearchResults","setQuery","serviceSpotify","setServiceSpotify","serviceYouTube","setServiceYouTube","serviceJukeboxRadio","setServiceJukeboxRadio","setFormatTrack","setFormatAlbum","setFormatPlaylist","setFormatVideo","responseJsonQueueList","fetchUserConnectSpotify","code","error","SpotifySync","queryString","search","urlParams","get","href","postData","fetchCreateTrack","imageFile","trackName","artistName","albumName","Upload","setAudioFile","setImageFile","setTrackName","setArtistName","setAlbumName","setCounter","Div","prevTrack","nextTrack","prev","spotify","authorizationUrl","messageScheduleNextTrack","setMessageScheduleNextTrack","plannedNextTrackTimeoutId","setPlannedNextTrackTimeoutId","nextTrackJson","setNextTrackJson","updateFeed","responseJsonTextCommentList","responseJsonVoiceRecordingList","responseJsonNextTrack","plannedNextTrack","responseJsonPrevTrack","direction","system","date","epochNow","getTime","proposedStartedAt","arr","seekTimeoutDuration","seekTimeoutId","setTimeout","jsonResponse","timeLeft","timeoutId","timeoutDuration","uris","position_ms","console","log","path","SpotifyWebApi","require","App","setStatus","nowPlayingTrack","textCommentsJsonResponse","voiceRecordingsJsonResponse","userSettingsJsonResponse","setAccessToken","accessToken","addEventListener","getState","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"wGACAA,EAAOC,QAAU,CAAC,OAAS,uBAAuB,IAAM,oBAAoB,OAAS,yB,0HCD/EC,G,MAAiBC,8BACjBC,EAAW,MACXC,EAAY,O,SCCHC,I,2EAAf,oFAAAC,EAAA,yDAA4BC,EAA5B,+BAAqC,GAAIC,EAAzC,+BAA+C,GAAIC,EAAnD,+BAA0D,GAGxDD,EAAMP,EAAiBO,EAET,QAAXD,EALL,iBASI,IADMG,EAAW,IAAIC,SACrB,MAA2BC,OAAOC,QAAQJ,GAA1C,eAAkD,EAAD,oBAArCK,EAAqC,KAAhCC,EAAgC,KAC/CL,EAASM,OAAOF,EAAKC,GAV3B,OAiBQE,EAAiB,CAACC,QAAS,KACzBC,EAAQC,aAAaC,QAAQ,kBAEjCJ,EAAeC,QAAQI,cAAvB,iBAAiDH,IAE7CI,EAAU,IAAIC,QAAQhB,EAAKS,GAtBrC,UAyBqBQ,MAAMF,EAAS,CAC9BhB,OAAQA,EACRmB,KAAM,OACNC,KAAMjB,IA5BZ,QAyBIkB,EAzBJ,+BAkCI,IADIC,EAAe,IAAIC,gBACvB,MAA2BlB,OAAOC,QAAQJ,GAA1C,eAAkD,EAAD,oBAArCK,EAAqC,KAAhCC,EAAgC,KAC/Cc,EAAaE,IAAIjB,EAAKC,GAnC5B,OAqCUiB,EAASxB,EAAM,KAAOqB,EAAaI,WAGrChB,EAAiB,CAACC,QAAS,CAAC,eAAgB,sBAC1CC,EAAQC,aAAaC,QAAQ,kBAEjCJ,EAAeC,QAAQI,cAAvB,iBAAiDH,IAE7CI,EAAU,IAAIC,QAAQQ,EAAQf,GA7CxC,UAgDqBQ,MAAMF,EAAS,CAC9BhB,OAAQA,EACRmB,KAAM,SAlDZ,QAgDIE,EAhDJ,wCAsDSA,GAtDT,6C,sBCSO,IAAMM,EAAsB,uCAAG,WAAOC,EAAMC,EAAQC,EAAiBC,GAAtC,iBAAAhC,EAAA,sEACbD,EACrBD,ECJwC,iCDMxC,CAAE+B,OAAMC,SAAQC,kBAAiBC,yBAJC,cAC9BV,EAD8B,gBAMTA,EAASW,OANA,cAM9BC,EAN8B,yBAO7BA,GAP6B,2CAAH,4DAatBC,EAAoB,uCAAG,8BAAAnC,EAAA,sEACXD,EACrBF,ECdsC,+BDYN,cAC5ByB,EAD4B,gBAKPA,EAASW,OALF,cAK5BC,EAL4B,yBAM3BA,GAN2B,2CAAH,qDAYpBE,EAAuB,uCAAG,8BAAApC,EAAA,sEACdD,EACrBF,ECjByC,kCDeN,cAC/ByB,EAD+B,gBAKVA,EAASW,OALC,cAK/BC,EAL+B,yBAM9BA,GAN8B,2CAAH,qDE1BvBG,EAAc,uCAAG,WAAOC,EAAUC,GAAjB,iBAAAvC,EAAA,sEACLD,EACrBD,EDZkC,uBCclC,CAAEwC,SAAUA,EAAUC,SAAUA,IAJN,cACtBjB,EADsB,gBAMDA,EAASW,OANR,cAMtBC,EANsB,yBAOrBA,GAPqB,2CAAH,wDAcdM,EAAqB,uCAAG,8BAAAxC,EAAA,sEACZD,EACrBD,EDWsC,+BCbL,cAC7BwB,EAD6B,gBAKRA,EAASW,OALD,cAK7BC,EAL6B,yBAM5BA,GAN4B,2CAAH,qDAarBO,EAAgB,uCAAG,gCAAAzC,EAAA,6DACxBa,EAAQC,aAAaC,QAAQ,eADL,SAEPhB,EACrBD,EDtCiC,sBCwCjC,CAAEe,MAAOA,IALmB,UAOP,OALjBS,EAFwB,QAOlBoB,OAPkB,8CASrBC,GATqB,uBAWHrB,EAASW,OAXN,cAWxBC,EAXwB,yBAYvBA,GAZuB,4CAAH,qDCrBvBU,EAAc,uCAAG,4BAAA5C,EAAA,sEACED,EACrBF,EFkB+B,uBEpBZ,cACfyB,EADe,gBAKRA,EAASW,OALD,mFAAH,qDASdY,EAAkB,uCAAG,WAAMC,GAAN,eAAA9C,EAAA,sEACFD,EACrBF,EFFoC,yBEIpC,CAAEiD,cAJqB,cACnBxB,EADmB,gBAMZA,EAASW,OANG,mFAAH,sDAalBc,EAAc,uCAAG,WAAOC,EAAqCC,GAA5C,iBAAAjD,EAAA,sEACED,EACrBD,EFFsC,8BEItC,CAAEkD,sCAAqCC,cAJpB,cACf3B,EADe,gBAMMA,EAASW,OANf,cAMfC,EANe,yBAOdA,GAPc,2CAAH,wDAadgB,EAAe,uCAAG,8BAAAlD,EAAA,sEACCD,EACrBD,EFduC,gCEYnB,cAChBwB,EADgB,gBAKKA,EAASW,OALd,cAKhBC,EALgB,yBAMfA,GANe,2CAAH,qDAYfiB,EAAc,uCAAG,8BAAAnD,EAAA,sEACED,EACrBD,EFzBsC,+BEuBnB,cACfwB,EADe,gBAKMA,EAASW,OALf,cAKfC,EALe,yBAMdA,GANc,2CAAH,qDAYdkB,EAAc,uCAAG,8BAAApD,EAAA,sEACED,EACrBD,EFpCsC,+BEkCnB,cACfwB,EADe,gBAKMA,EAASW,OALf,cAKfC,EALe,yBAMdA,GANc,2CAAH,qDAYdmB,EAAiB,uCAAG,8BAAArD,EAAA,sEACDD,EACrBD,EF/CyC,kCE6CnB,cAClBwB,EADkB,gBAKGA,EAASW,OALZ,cAKlBC,EALkB,yBAMjBA,GANiB,2CAAH,qDAYjBoB,EAAgB,uCAAG,WAAON,GAAP,iBAAAhD,EAAA,sEACAD,EACrBD,EF1DwC,gCE4DxC,CAAEkD,wCAJmB,cACjB1B,EADiB,gBAMIA,EAASW,OANb,cAMjBC,EANiB,yBAOhBA,GAPgB,2CAAH,sDC7FTqB,EAAc,uCAAG,8BAAAvD,EAAA,sEACLD,EACrBF,EHyB+B,uBG3BL,cACtByB,EADsB,gBAKDA,EAASW,OALR,cAKtBC,EALsB,yBAMrBA,GANqB,2CAAH,qDAYdsB,EAAgB,uCAAG,WAAOC,GAAP,iBAAAzD,EAAA,sEACPD,EACrBD,EHYiC,yBGVjC,CAAE2D,UAAWA,IAJe,cACxBnC,EADwB,gBAMHA,EAASW,OANN,cAMxBC,EANwB,yBAOvBA,GAPuB,2CAAH,sDCVhBwB,EAAoB,uCAAG,8BAAA1D,EAAA,sEACXD,EACrBF,EJLsC,4BIGN,cAC5ByB,EAD4B,gBAKPA,EAASW,OALF,cAK5BC,EAL4B,yBAM3BA,GAN2B,2CAAH,qDCTpByB,EAAkB,UAClBC,EAAkB,UAClBC,EAAwB,gBCaxBC,EAA0B,SAASC,EAAQC,GACtD,IAAID,EAAOE,WACT,MAAO,MAACtB,OAAWA,GAQrB,IALA,IACIuB,EADAC,EAAWC,KAAKC,MAAQL,EAExBM,EAAsB,EACtBC,EAAqB,IAEb,CACV,IAAMC,EAAmBT,EAAOE,WAAWQ,kBAAkBH,GACvDI,EAA2BF,EAAiB,GAAKA,EAAiB,GAClEG,EAAoBR,EAAWI,EACrC,GAAGI,EAAoBD,EAA0B,CAC/CP,EAAWK,EAAiB,GAAKG,EACjCT,EAAcM,EAAiB,GAAKL,EACpC,MAEFG,GAAuB,EACvBC,GAAsBG,EAOxB,OAJGJ,IAAwBP,EAAOE,WAAWQ,kBAAkBG,OAAS,IACtEV,OAAcvB,GAGT,CAACwB,EAAUD,IAsCPW,EAAgB,SAASC,EAAUf,GAC9C,IAAMgB,EAAkBhB,EAAOE,WAAWe,MAAMC,QAEhD,GAAGF,IAAoBpB,EACrBmB,EAASI,WAAWC,aACf,GAAGJ,IAAoBnB,QAEvB,GAAGmB,IAAoBlB,EAAuB,CACnD,IAAMf,EAAYiB,EAAOE,WAAWe,MAAMI,KAC5BN,EAASO,MAAMvC,GAAWwC,MAClCH,UAQGI,EAAe,SAAST,EAAUf,EAAQC,GACrD,IACMwB,EADM1B,EAAwBC,EAAQC,GACX,GAC3Be,EAAkBhB,EAAOE,WAAWe,MAAMC,QAEhD,GAAGF,IAAoBpB,EACrBmB,EAASI,WAAWO,KAAKD,QACpB,GAAGT,IAAoBnB,QAEvB,GAAGmB,IAAoBlB,EAAuB,CACnD,IAAMf,EAAYiB,EAAOE,WAAWe,MAAMI,KACpCE,EAAQR,EAASO,MAAMvC,GAAWwC,MACxCA,EAAMI,OACNJ,EAAMK,YAAcH,EAAuB,IAC3CF,EAAMM,SAQGC,EAAe,SAASf,EAAUf,GAC7C,IAAMgB,EAAkBhB,EAAOE,WAAWe,MAAMC,QAEhD,GAAGF,IAAoBpB,EACrBmB,EAASI,WAAWU,YACf,GAAGb,IAAoBnB,QAEvB,GAAGmB,IAAoBlB,EAAuB,CACnD,IAAMf,EAAYiB,EAAOE,WAAWe,MAAMI,KAC5BN,EAASO,MAAMvC,GAAWwC,MAClCM,S,sBCxHJE,EAAqB,OAOdC,EAAe,SAASC,GAE7B,IAAAjC,EAASiC,EAAMjC,OAAf,EACiDD,EAAwBC,GADzE,mBACCI,EADD,KACW8B,EADX,KAC6BC,EAD7B,KAGN,IAAI/B,EACF,MAAO,GAGT,IAAMgC,EAAY,YAAOH,EAAMG,cACzBC,EAAe,YAAOJ,EAAMI,iBAC9BC,EAAa,sBAAOF,GAAP,YAAwBC,IA4BzC,OAHAC,GAHAA,GApBAA,EAAgBA,EAAcC,KAAI,SAAAC,GAChC,IAAMC,EACED,EAAGE,sBAAwBP,GAC3BK,EAAGE,uBAAyBR,EAE9BS,EACEH,EAAGE,sBAAwBR,GAC3BM,EAAGE,uBAAyBtC,EAWpC,OAPEoC,EAAGI,aADFH,EAhCuB,UAkChBE,EAjCgB,UAoCNZ,EAGb,eAAKS,OAEgBK,QAAO,SAAAC,GAAC,OACpCA,EAAEF,eAAiBb,MAESgB,MAAK,SAAC9G,EAAG+G,GACrC,OAAO/G,EAAEyG,sBAAwBM,EAAEN,0BAM1B3C,EAA0B,SAASC,GAAS,IAAD,EAEtD,KAAG,OAACA,QAAD,IAACA,GAAD,UAACA,EAAQE,kBAAT,aAAC,EAAoBe,OACtB,MAAO,MAACrC,OAAWA,OAAWA,GAahC,IAVA,IAAMqB,EAAYD,EAAOC,UAErBG,EACEJ,EAAOiD,UAAY5C,KAAKC,MAAQL,EAAYD,EAAOkD,SAAWjD,EAEhEM,EAAsB,EACtB2B,EAAmB,EACnBC,EAAmB,EACnB3B,EAAqB,IAEb,CACV,IAAMC,EAAmBT,EAAOE,WAAWQ,kBAAkBH,GACvDI,EAA2BF,EAAiB,GAAKA,EAAiB,GACpEG,OAAiB,EAkBrB,IAdAA,EADyBR,EAvEJ,IAwEiBI,IACd,GAAKI,EAAoBD,IAC/CuB,EAAmBzB,EAAiB,GAAKG,IAK3CA,EADyBR,EA9EJ,IACA,KA8EiBI,IACd,GAAKI,EAAoBD,IAC/CwB,EAAmB1B,EAAiB,GAAKG,IAI3CA,EAAoBR,EAAWI,GACRG,EAA0B,CAC/CP,EAAWK,EAAiB,GAAKG,EACjC,MAGFL,GAAuB,EACvBC,GAAsBG,EAGxB,MAAO,CAACP,EAAU8B,EAAkBC,IAOzBgB,EAAa,SAASlB,GACjC,OAAO,2BACFA,GADL,IAEEmB,KAAMpB,EAAaC,MCjHVoB,EAAe,SAASpB,EAAOqB,GAC1C,IAAMC,EAAc,eAAQtB,EAAMsB,gBAC5B7D,EAAY4D,EAAO5D,UACnB8D,EAASF,EAAOE,OAEhBC,EADO,sBAAOF,EAAe7D,IAAtB,CAAkC8D,IACjBT,MAAK,SAAC9G,EAAG+G,GAC/B,OAAO/G,EAAEyG,sBAAwBM,EAAEN,yBAG3C,OADAa,EAAe7D,GAAa+D,EACrB,2BACFxB,GADL,IAEEsB,eAAgBA,KAOPG,EAAe,SAASzB,EAAOqB,GAC1C,IAAMC,EAAc,eAAQtB,EAAMsB,gBAC5B7D,EAAY4D,EAAO5D,UACnB8D,EAASF,EAAOE,OAEhBG,EADUJ,EAAeD,EAAO5D,WACNmD,QAAO,SAAAe,GAAC,OAAIA,EAAEvC,OAASmC,EAAOnC,QAE9D,OADAkC,EAAe7D,GAAaiE,EACrB,2BACF1B,GADL,IAEEsB,eAAgBA,KAOPM,EAAa,SAAS5B,EAAOqB,GACxC,IAAM5D,EAAY4D,EAAO5D,UACnBoE,EAAUR,EAAOQ,QACjBP,EAAc,eAAQtB,EAAMsB,gBAElC,OADAA,EAAe7D,GAAaoE,EACrB,2BACF7B,GADL,IAEEsB,eAAgBA,K,QCtCPQ,EAAgB,SAAhBA,EAAyBC,GAAQ,IAAD,EACrCC,EAAI,eAAQD,GAGlB,GAAGC,EAAKC,SAASrD,OAAQ,CACvB,IAAMsD,EAAiBF,EAAKC,SAAS3B,IAAIwB,GACnCK,EAA4BD,EAAeE,QAAO,SAACC,EAAOC,GAAR,OAChDD,EAAQC,EAAEC,uBACT,GAGT,OAFAP,EAAKC,SAAWC,EAChBF,EAAKG,0BAA4BA,EAC1BH,EAGT,IAAMQ,EAAYR,EAAKQ,UACjBC,EAAyB,UAAGT,EAAKhD,aAAR,aAAG,EAAYuD,qBAC9C,IAAIC,EAAU5D,OAGZ,OAFAoD,EAAKG,0BAA4BM,EACjCT,EAAKvD,kBAAoB,CAAC,CAAC,EAAGgE,IACvBT,EAGT,IACIU,EACAC,EAxBuC,EAsBrClE,EAAoB,GAtBiB,cA0BrB+D,GA1BqB,IA0B3C,IAAI,EAAJ,qBAAiC,CAAC,IAAxBI,EAAuB,QAC/B,GAAIA,EAASF,WAGN,IAAIE,EAASD,WAYb,CACDD,IACFA,EAAa,GAEfC,EAAaC,EAASF,WAAWjC,sBACjChC,EAAkBoE,KAAK,CAACH,EAAYC,IACpCD,EAAaE,EAASD,WAAWlC,sBACjCkC,OAAahG,EACb,SAnBI+F,IACFA,EAAa,GAEfC,EAAaC,EAASF,WAAWjC,sBACjChC,EAAkBoE,KAAK,CAACH,EAAYC,IAGpCD,OAAa/F,EAGb,MAbA+F,EAAaE,EAASD,WAAWlC,uBA5BM,8BAsDxCiC,IACDC,EAAaF,EACbhE,EAAkBoE,KAAK,CAACH,EAAYC,KAGtC,IAAMR,EAA4B1D,EAAkB2D,QAAO,SAACC,EAAOxB,GAAR,OACzDwB,GAASxB,EAAE,GAAKA,EAAE,MACjB,GAKH,OAHAmB,EAAKG,0BAA4BA,EACjCH,EAAKvD,kBAAoBA,EAElBuD,GAUIc,EAAe,SAAS9C,EAAO+C,GAC1C,IAAMC,EAAeD,EAAQC,aAAa1C,IAAIwB,GACxCmB,EAAeF,EAAQE,aAAa3C,IAAIwB,GACxCoB,EAAclD,EAAMkD,YAEvBA,GACDF,EAAaH,KAAKK,GAGpB,IAAInF,EAASiC,EAAMjC,OACfA,EAAOiD,WAAcjD,EAAOoF,WAAYpF,EAAOE,aACjD+E,EAAaH,KAAK9E,EAAOE,YACzBF,EAAM,2BAAQA,GAAR,IAAgBE,gBAAYtB,KAGpC,IAAMyG,EACGJ,EAAapE,OAEZoE,EAAaA,EAAapE,OAAS,QADnCjC,EAGJ0G,EACGJ,EAAarE,OACXqE,EAAa,GAAGhB,SAASrD,OAExBqE,EAAa,GAAGhB,SAAS,GADzBgB,EAAa,QAFMtG,EAO/B,OAAO,2BACFqD,GADL,IAEEjC,OAAQA,EACRqF,OAAQA,EACRJ,aAAcA,EACdK,OAAQA,EACRJ,aAAcA,KC9GLK,GAAY,SAAStD,EAAO+C,GACvC,IAAMhF,EAASgF,EAAQhF,OACjBE,EAAaF,EAAOE,WACpBsF,EAAG,eAAQvD,GAQjB,GANG/B,IACDF,EAAOE,WAAa6D,EAAc7D,IAGpCsF,EAAIxF,OAASA,EAETA,EAAOiD,WAAcjD,EAAOoF,WAAYpF,EAAOE,YAM5C,GAAGF,EAAOiD,UAAW,CAC1B,IAAM7C,EAAWC,KAAKC,MAAQN,EAAOC,UAClCG,GAAYA,GAAYJ,EAAOE,WAAWkE,4BAC3CoB,EAAIH,OAASrF,EAAOE,WACpBsF,EAAIL,YAAcnF,EAAOE,WACzBsF,EAAIxF,OAAOE,gBAAatB,EACxB4G,EAAIxF,OAAOiD,WAAY,EACvBuC,EAAIxF,OAAOoF,UAAW,SAZxBI,EAAIH,OAASrF,EAAOE,WACpBsF,EAAIL,YAAcnF,EAAOE,WACzBsF,EAAIxF,OAAOE,gBAAatB,EACxB4G,EAAIxF,OAAOiD,WAAY,EACvBuC,EAAIxF,OAAOoF,UAAW,EAYxB,OAAOI,GAOIC,GAAa,SAASxD,EAAO+C,GACxC,IAAMU,EAAiB,CACrB1F,OAAO,2BACFiC,EAAMjC,QADL,IAEJiD,WAAW,EACXmC,UAAU,EACVnF,UAAW+E,EAAQ/E,aAGvB,OAAOsF,GAAUtD,EAAOyD,IAObC,GAAc,SAAS1D,EAAO+C,GACzC,IAAMU,EAAiB,CACrB1F,OAAO,2BACFiC,EAAMjC,QADL,IAEJiD,WAAW,EACXmC,UAAU,EACVlC,SAAU8B,EAAQ9B,YAGtB,OAAOqC,GAAUtD,EAAOyD,IAObE,GAAkB,SAAS3D,EAAO+C,GAC7C,IAAMC,EAAY,YAAOhD,EAAMgD,cACzBC,EAAY,YAAOjD,EAAMiD,cACzBW,EAAiB5D,EAAMjC,OAAOE,WAC9B4F,EAAcZ,EAAa,GAC3Ba,EAAiBd,EAAaA,EAAapE,OAAS,GAEpDmF,GACU,OAAdH,QAAc,IAAdA,OAAA,EAAAA,EAAgBI,cAAhB,OACAH,QADA,IACAA,OADA,EACAA,EAAazE,QACC,OAAdwE,QAAc,IAAdA,OAAA,EAAAA,EAAgBI,eAAhB,OAA+BH,QAA/B,IAA+BA,OAA/B,EAA+BA,EAAazE,MAY9C,OAVGwE,IACEG,EACDF,EAAY5B,SAASgC,QAAQL,GAE7BX,EAAagB,QAAQL,IAIzBZ,EAAakB,MAEN,2BACAlE,GADP,IAEIjC,OAAO,2BACFiC,EAAMjC,QADL,IAEJC,UAAW+E,EAAQ/E,UACnBC,WAAY6F,EACZ9C,WAAW,EACXmC,UAAU,IAEZH,aAAcA,EACdC,aAAcA,EACdC,iBAAavG,KAQNwH,GAAkB,SAASnE,EAAO+C,GAC7C,IAAMC,EAAY,YAAOhD,EAAMgD,cACzBC,EAAY,YAAOjD,EAAMiD,cACzBW,EAAiB5D,EAAMjC,OAAOE,WAC9B4F,EAAcZ,EAAa,GAC3Ba,EACED,EACGA,EAAY5B,SAASrD,OACpBiF,EAAY5B,SAAS,GACrB4B,OACFlH,EAkBV,OAfGiH,GACDZ,EAAaH,KAAKe,GAGjBC,IACEA,EAAY5B,SAASrD,QACtBiF,EAAY5B,SAASmC,QACjBP,EAAY5B,SAASrD,QACvBqE,EAAamB,SAGfnB,EAAamB,SAIV,2BACApE,GADP,IAEIjC,OAAO,2BACFiC,EAAMjC,QADL,IAEJC,UAAW+E,EAAQ/E,UACnBC,WAAY6F,EACZ9C,YAAa8C,EACbX,UAAU,IAEZH,aAAcA,EACdC,aAAcA,EACdC,YAAaU,KC9IbS,GAAY,SAASrE,GACzB,IAAMiD,EAAejD,EAAMiD,aAQ3B,OANQA,EAAarE,OACVqE,EAAa,GAAGhB,SAASrD,OACxBqE,EAAa,GAAGhB,SAAS,GACzBgB,EAAa,QACftG,GASC2H,GAAkB,SAAStE,EAAO+C,GAC7C,OAAO,2BACF/C,GADL,IAEElB,SAAS,2BACJkB,EAAMlB,UADH,IAENI,WAAY6D,EAAQ7D,WACpBqF,SAAS,OAWFC,GAAqB,SAASxE,GACzC,IAAMqD,EAASgB,GAAUrE,GACzB,IAAIqD,EACF,OAAO,eAAKrD,GAGd,IAAMlB,EAAQ,eAAQkB,EAAMlB,UACtBb,EAAa+B,EAAMjC,OAAOE,WAExBA,EAAWe,MAAMC,UAAYtB,GAC7B0F,EAAOrE,MAAMC,UAAYtB,GACU,IAAnC0F,EAAO5E,kBAAkB,GAAG,MLmGT,SAASK,EAAUf,EAAQsF,GAC9BtF,EAAOE,WAAWe,MAAMC,UAEzBtB,GACrBmB,EAASI,WAAW6C,MAAMsB,EAAOrE,MAAMyF,YKnGvCC,CAAc1E,EAAMlB,SAAUkB,EAAMjC,OAAQsF,GAE5CvE,EAAS6F,UAAW,EAGlB1G,EAAWQ,kBAAkBR,EAAWQ,kBAAkBG,OAAS,GAErD,KAAOX,EAAWe,MAAMuD,uBACtCzD,EAAS8F,eAAgB,IAM7B,OAAO,2BACF5E,GADL,IAEElB,SAAUA,KAQR+F,GAAiC,SAAS7E,GAC9C,IAAMqD,EAASgB,GAAUrE,GACnB2E,EAAW3E,EAAMlB,SAAS6F,SAC1BC,EAAgB5E,EAAMlB,SAAS8F,cAC/BE,EAAsB9E,EAAMlB,SAASgG,oBACrCC,EAAoB/E,EAAMlB,SAASiG,kBACnCjG,EAAQ,2BACHkB,EAAMlB,UADH,IAEN6F,UAAU,EACVC,eAAe,IAEvB,OAAIvB,GAAUuB,GACZ9F,EAASgG,yBAAsBnI,EACxB,2BACFqD,GADL,IAEElB,SAAUA,KAIX6F,GLoC6B,SAAS7F,EAAUf,GAC3BA,EAAOE,WAAWe,MAAMC,UAEzBtB,GACrBmB,EAASI,WAAW8F,aKvCpBC,CAAmBjF,EAAMlB,SAAUkB,EAAMjC,QACzCe,EAASgG,yBAAsBnI,EACxB,2BACFqD,GADL,IAEElB,SAAUA,MAIdoG,aAAaJ,GACbI,aAAaH,GACbjG,EAASkC,WAAY,EACrBlC,EAASgG,yBAAsBnI,EAC/BmC,EAASiG,uBAAoBpI,EACtB,2BACFqD,GADL,IAEElB,SAAUA,MAQDqG,GAA2B,SAASnF,EAAO+C,GACtD,IAAIqC,EAAepF,EACnBoF,EAAeP,GAA+BO,GAC9C,IAAMC,EAAetC,EAAQA,QACvBuC,EAAoBF,EAAarH,OAAOE,WAK9C,OAJAoH,EAAarH,UACXoH,EAAarH,OAAOC,UAAYsH,EAAkBnD,0BAEpDiD,EAAejB,GAAgBiB,EAAcC,IAQlCE,GAAgB,SAASvF,GACpC,IAAM8E,EAAsB9E,EAAMlB,SAASgG,oBACrCC,EAAoB/E,EAAMlB,SAASiG,kBACnCjG,EAAQ,2BACHkB,EAAMlB,UADH,IAEN6F,UAAU,EACVC,eAAe,EACf5D,WAAW,EACX8D,yBAAqBnI,IAM7B,OAHAuI,aAAaJ,GACbI,aAAaH,GAEN,2BACF/E,GADL,IAEElB,SAAUA,KAQD0G,GAAkB,SAASxF,GACtC,IAAMlB,EAAQ,2BACHkB,EAAMlB,UADH,IAENkC,WAAW,IAEnB,OAAO,2BACFhB,GADL,IAEElB,SAAUA,KAKD2G,GAA+B,SAASzF,GACnD,IAAM8E,EAAsB9E,EAAMlB,SAASgG,oBACrCC,EAAoB/E,EAAMlB,SAASiG,kBACnCjG,EAAQ,2BACHkB,EAAMlB,UADH,IAENgG,yBAAqBnI,EACrBoI,uBAAmBpI,IAM3B,OAHAuI,aAAaJ,GACbI,aAAaH,GAEN,2BACF/E,GADL,IAEElB,SAAUA,KAKD4G,GAA8B,SAAS1F,EAAO+C,GACzD,IAAMjE,EAAQ,2BACHkB,EAAMlB,UADH,IAENgG,oBAAqB/B,EAAQ+B,sBAErC,OAAO,2BACF9E,GADL,IAEElB,SAAUA,KAKD6G,GAA4B,SAAS3F,EAAO+C,GACvD,IAAMgC,EAAoB/E,EAAMlB,SAASiG,kBACnCjG,EAAQ,2BACHkB,EAAMlB,UADH,IAENiG,kBAAmBhC,EAAQgC,oBAKnC,OAFAG,aAAaH,GAEN,2BACF/E,GADL,IAEElB,SAAUA,KAKD8G,GAAkB,SAAS5F,GACtC,OAAO,2BACFA,GADL,IAEElB,SAAS,2BACJkB,EAAMlB,UADH,IAEN+G,iBAAiB,OAMVC,GAAiB,SAAS9F,GACrC,OAAO,2BACFA,GADL,IAEElB,SAAS,2BACJkB,EAAMlB,UADH,IAEN+G,iBAAiB,OAMVE,GAAoB,SAAS/F,EAAO+C,GAC/C,IAAMjE,EAAQ,eAAQkB,EAAMlB,UACtBO,EAAK,eAAQW,EAAMlB,SAASO,OAE5BC,EAAQ,IAAI0G,MAAMjD,EAAQ/D,MAAMiH,UAKtC,OAHA5G,EAAM0D,EAAQ/D,MAAMI,MAAQ,CAC1BE,MAAOA,GAEF,2BACFU,GADL,IAEElB,SAAS,2BACJA,GADG,IAENO,MAAOA,OC9PP6G,GAAa,SAAS9G,GAC1B,OAAQ,SAAA+G,GAAC,OAAIA,EAAE/G,OAASA,IAepBgH,GAAqB,SAASpM,EAAG+G,GACrC,OAAIA,EAAE4B,WAEK3I,EAAE2I,WAIT3I,EAAE2I,WAAWlC,sBACbzG,EAAE2I,WAAWlC,sBAJR,GAFC,GAeC4F,GAAsB,SAASrG,EAAOqB,GACjD,IAMsBiF,EANhBC,EAAgBlF,EAAOkF,cACvB9I,EAAY4D,EAAO5D,UACnB+I,EAAkBnF,EAAOmF,gBAG3BC,EAASzG,EAAMiD,aACfyD,GAAe,EAChBF,IACDE,EAAcD,EAAOE,UAAUT,GAAWM,IAC1CC,EAASA,EAAOC,GAAazE,UAE/BqE,EAAQG,EAAOE,UAAUT,GAAWzI,IACpC,IAAMmJ,EAAaH,EAAOH,GAIpBO,EADc,sBAAOD,EAAWpE,WAAlB,CAA6B+D,IACLzF,KAAKsF,IAG3CnD,EAAY,YAAOjD,EAAMiD,eACX,IAAjByD,EACDzD,EAAayD,GAAazE,SAASqE,GAAO9D,UAAYqE,EAEtD5D,EAAaqD,GAAO9D,UAAYqE,EAIlC,IAAMC,EAAwB7D,EAAa3C,IAAIwB,GAE/C,OAAO,2BACF9B,GADL,IAEEiD,aAAc6D,KAQLC,GAAsB,SAAS/G,EAAOqB,GACjD,IAMsBiF,EANhBC,EAAgBlF,EAAOkF,cACvB9I,EAAY4D,EAAO5D,UACnB+I,EAAkBnF,EAAOmF,gBAG3BC,EAASzG,EAAMiD,aACfyD,GAAe,EAChBF,IACDE,EAAcD,EAAOE,UAAUT,GAAWM,IAC1CC,EAASA,EAAOC,GAAazE,UAE/BqE,EAAQG,EAAOE,UAAUT,GAAWzI,IACpC,IA9E4B2B,EA8EtBwH,EAAaH,EAAOH,GAIpBU,EADc,YAAOJ,EAAWpE,WACQ5B,QAlFlBxB,EAkFsCmH,EAAcnH,KAjFxE,SAAA+G,GAAC,OAAIA,EAAE/G,OAASA,KAoFlB6D,EAAY,YAAOjD,EAAMiD,eACX,IAAjByD,EACDzD,EAAayD,GAAazE,SAASqE,GAAO9D,UAAYwE,EAEtD/D,EAAaqD,GAAO9D,UAAYwE,EAIlC,IAAMF,EAAwB7D,EAAa3C,IAAIwB,GAE/C,OAAO,2BACH9B,GADJ,IAECiD,aAAc6D,KCzGJG,GAAqB,SAASjH,EAAO+C,GAChD,IAAM5C,EAAe4C,EAAQ5C,aACvBiF,EAAY,2BACPpF,GADO,IAEVG,aAAcA,IAGtB,OAAO,2BACFiF,GADL,IAEEjE,KAAMpB,EAAaqF,MAQV8B,GAAoB,SAASlH,EAAOqB,GAC/C,IAAMlB,EAAY,sBAAOH,EAAMG,cAAb,CAA2BkB,EAAO8F,cAC9C/B,EAAY,2BACPpF,GADO,IAEVG,aAAcA,IAGtB,OAAO,2BACFiF,GADL,IAEEjE,KAAMpB,EAAaqF,MAQVgC,GAAoB,SAASpH,EAAOqB,GAC/C,IACMlB,EAAeH,EAAMG,aAAaS,QADnB,SAAAC,GAAC,OAAIA,EAAEzB,OAASiC,EAAOtF,mBAEtCqJ,EAAY,2BACPpF,GADO,IAEVG,aAAcA,IAGtB,OAAO,2BACFiF,GADL,IAEEjE,KAAMpB,EAAaqF,MC/CViC,GAAgC,SAASrH,EAAO+C,GAC3D,IAAMuE,EAA0BvE,EAAQuE,wBAClCvL,EAAkBgH,EAAQhH,gBAC1BoE,EAAY,YAAOH,EAAMG,cACzBoH,EAAmBpH,EAAawG,WAAU,SAAAa,GAAC,OACzCA,EAAEpI,OAASrD,KAEboL,EAAchH,EAAaoH,GAC3BE,EAAa,YAAON,EAAYM,eAEtCA,EAAc5E,KAAKyE,GACnB,IAAMI,EAAsBD,EAAc3G,MAAK,SAAC9G,EAAG+G,GACjD,OAAO/G,EAAE2N,SAAW5G,EAAE4G,YAIxB,OAFAxH,EAAaoH,GAAkBE,cAAgBC,EAExC,2BACF1H,GADL,IAEEG,aAAcA,KCfLyH,GAAwB,SAAS5H,EAAO+C,GACnD,IAAM3C,EAAkB2C,EAAQ3C,gBAC1BgF,EAAY,2BACPpF,GADO,IAEVI,gBAAiBA,IAGzB,OAAO,2BACFgF,GADL,IAEEjE,KAAMpB,EAAaqF,MAQVyC,GAAuB,SAAS7H,EAAOqB,GAClD,IAAMjB,EAAe,sBAAOJ,EAAMI,iBAAb,CAA8BiB,EAAOyG,iBACpD1C,EAAY,2BACPpF,GADO,IAEVI,gBAAiBA,IAGzB,OAAO,2BACFgF,GADL,IAEEjE,KAAMpB,EAAaqF,MAQV2C,GAAuB,SAAS/H,EAAOqB,GAClD,IACMjB,EAAkBJ,EAAMI,gBAAgBQ,QADzB,SAAAC,GAAC,OAAIA,EAAEzB,OAASiC,EAAO2G,sBAEtC5C,EAAY,2BACPpF,GADO,IAEVI,gBAAiBA,IAGzB,OAAO,2BACFgF,GADL,IAEEjE,KAAMpB,EAAaqF,MCHjB6C,GAAe,CACnBhF,aAAc,GACdD,aAAc,GACdE,iBAAavG,EACbwD,aAAc,GACdC,gBAAiB,GACjBe,KAAM,GACN+G,kBAAcvL,EACd2E,eAAgB,GAChBxC,SAAU,CACR+G,iBAAiB,EACjB3G,gBAAYvC,EACZqE,WAAW,EACX2D,UAAU,EACVC,eAAe,EACfE,yBAAqBnI,EACrB4H,SAAS,EACTlF,MAAO,KAKX,SAAS8I,GAAanI,EAAOqB,GAC3B,IAAMtD,EAAM,eAAQiC,EAAMjC,QACpBmF,EAAcnF,EAAOE,WAM3B,OAJAF,EAAOiD,WAAY,EACnBjD,EAAOoF,UAAW,EAClBpF,EAAOE,gBAAatB,EAEb,2BAAKqD,GAAZ,IAAmBjC,OAAQA,EAAQmF,YAAaA,IAIlD,SAASkF,GAAgBpI,EAAOqB,GAC9B,IACMgH,EADSrI,EAAMiD,aACSrC,QAAO,SAAAC,GAAC,OAAIA,EAAEzB,OAASiC,EAAO5D,aAE5D,OAAO,2BACFuC,GADL,IAEEiD,aAAcoF,IAKlB,SAASC,GAAqBtI,EAAOqB,GACnC,IAAIoF,EAAM,YAAOzG,EAAMiD,cACjByD,EAAcD,EAAOE,WAAU,SAAA9F,GAAC,OAAIA,EAAEzB,OAASiC,EAAO2C,cAEtDuE,EADW9B,EAAOC,GAAazE,SACHrB,QAAO,SAAAC,GAAC,OAAIA,EAAEzB,OAASiC,EAAO5D,aAQhE,OANAgJ,EAAOC,GAAazE,SAAWsG,EAE3BA,EAAiB3J,SACnB6H,EAASA,EAAO7F,QAAO,SAAAC,GAAC,OAAIA,EAAEzB,OAASiC,EAAO2C,eAGzC,2BACFhE,GADL,IAEEiD,aAAcwD,IAKlB,SAAS+B,GAA8BxI,EAAOqB,GAC5C,IAAMkG,EAAmBvH,EAAMG,aAAawG,WAAU,SAAAa,GAAC,OAAIA,EAAEpI,OAASiC,EAAOtF,mBACvEoE,EAAY,YAAOH,EAAMG,cAI/B,OAFAA,EAAaoH,GAAkBE,cAAgB,GAExC,2BACFzH,GADL,IAEEG,aAAcA,IAKlB,SAASsI,GAAgBzI,EAAOqB,GAC9B,OAAO,2BACFrB,GADL,IAEEkI,aAAc7G,EAAO6G,eAKzB,IA8EaQ,GAAQC,aA9EL,WAAmC,IAAlC3I,EAAiC,uDAAzBiI,GAAc5G,EAAW,uCAChD,OAAQA,EAAOuH,MACb,IAAK,aACH,OAAOtF,GAAUtD,EAAOqB,EAAO0B,SACjC,IAAK,cACH,OAAOS,GAAWxD,EAAOqB,EAAO0B,SAClC,IAAK,eACH,OAAOW,GAAY1D,EAAOqB,EAAO0B,SACnC,IAAK,mBACH,OAAOY,GAAgB3D,EAAOqB,EAAO0B,SACvC,IAAK,mBACH,OAAOoB,GAAgBnE,EAAOqB,EAAO0B,SACvC,IAAK,gBACH,OAAOoF,GAAanI,GACtB,IAAK,gBACH,OAAO8C,EAAa9C,EAAOqB,EAAO0B,SACpC,IAAK,mBACH,OAAOqF,GAAgBpI,EAAOqB,GAChC,IAAK,wBACH,OAAOiH,GAAqBtI,EAAOqB,GACrC,IAAK,sBACH,OAAO4F,GAAmBjH,EAAOqB,EAAO0B,SAC1C,IAAK,qBACH,OAAOmE,GAAkBlH,EAAOqB,GAClC,IAAK,qBACH,OAAO+F,GAAkBpH,EAAOqB,GAClC,IAAK,iCACH,OAAOgG,GAA8BrH,EAAOqB,EAAO0B,SACrD,IAAK,iCACH,OAAOyF,GAA8BxI,EAAOqB,GAC9C,IAAK,wBACH,OAAOwG,GAAqB7H,EAAOqB,GACrC,IAAK,yBACH,OAAOuG,GAAsB5H,EAAOqB,EAAO0B,SAC7C,IAAK,wBACH,OAAOgF,GAAqB/H,EAAOqB,GACrC,IAAK,oBACH,OAAOoH,GAAgBzI,EAAOqB,GAChC,IAAK,gBACH,OAAOD,EAAapB,EAAOqB,EAAO0B,SACpC,IAAK,gBACH,OAAOtB,EAAazB,EAAOqB,EAAO0B,SACpC,IAAK,cACH,OAAOnB,EAAW5B,EAAOqB,EAAO0B,SAClC,IAAK,uBACH,OAAOsD,GAAoBrG,EAAOqB,EAAO0B,SAC3C,IAAK,uBACH,OAAOgE,GAAoB/G,EAAOqB,EAAO0B,SAC3C,IAAK,mBACH,OAAO6C,GAAgB5F,GACzB,IAAK,kBACH,OAAO8F,GAAe9F,GACxB,IAAK,mBACH,OAAOsE,GAAgBtE,EAAOqB,EAAO0B,SACvC,IAAK,sBACH,OAAOyB,GAAmBxE,GAC5B,IAAK,4BACH,OAAOmF,GAAyBnF,EAAOqB,EAAO0B,SAChD,IAAK,iBACH,OAAOwC,GAAcvF,GACvB,IAAK,mBACH,OAAOwF,GAAgBxF,GACzB,IAAK,gCACH,OAAOyF,GAA6BzF,GACtC,IAAK,+BACH,OAAO0F,GAA4B1F,EAAOqB,EAAO0B,SACnD,IAAK,6BACH,OAAO4C,GAA0B3F,EAAOqB,EAAO0B,SACjD,IAAK,qBACH,OAAOgD,GAAkB/F,EAAOqB,EAAO0B,SACzC,IAAK,cACH,OAAO7B,EAAWlB,GACpB,QACE,OAAOA,KAK6B6I,OAAOC,8BAAgCD,OAAOC,6BAA6B,CAAEC,OAAO,K,6BCtI/GC,OArEf,SAAeC,GAAO,MAKYC,mBAAS,IALrB,mBAKb5M,EALa,KAKH6M,EALG,OAMYD,mBAAS,IANrB,mBAMb3M,EANa,KAMH6M,EANG,OAOgBF,oBAAS,GAPzB,mBAObG,EAPa,KAODC,EAPC,KAYdC,EAAY,uCAAG,WAAeC,GAAf,eAAAxP,EAAA,6DACnBwP,EAAEC,iBADiB,SAGQpN,EAAeC,EAAUC,GAHjC,WAGbL,EAHa,QAIFwN,QAAWxN,EAAayN,QAJtB,wDAQnB7O,aAAa8O,QAAQ,cAAe1N,EAAawN,QACjD5O,aAAa8O,QAAQ,eAAgB1N,EAAayN,SAT/B,UAWbnN,IAXa,QAanBqM,OAAOgB,SAASC,SAbG,4CAAH,sDAgBlB,OACE,uBAAMC,UAAWC,KAAOhB,MAAOiB,SAAQ,uCAAE,WAAOT,GAAP,SAAAxP,EAAA,sEAAqBuP,EAAaC,GAAlC,2CAAF,sDAAvC,UACE,yCACA,qFAAuD,cAAC,KAAD,CAAMU,GAAG,UAAT,qBAAvD,aAEA,wBAAOH,UAAWC,KAAOG,UAAzB,qBAEE,uBAAOvB,KAAK,OACLwB,KAAK,WACLC,YAAY,WACZ5P,MAAO6B,EACPgO,SAAU,SAACd,GAAOL,EAAYK,EAAEe,OAAO9P,aAGhD,wBAAOsP,UAAWC,KAAOG,UAAzB,qBAEE,uBAAOvB,KAAK,WACLwB,KAAK,WACLC,YAAY,WACZ5P,MAAO8B,EACP+N,SAAU,SAACd,GAAOJ,EAAYI,EAAEe,OAAO9P,aAGhD,wBAAOsP,UAAWC,KAAOG,UAAzB,UACE,uBAAOvB,KAAK,WACLwB,KAAK,cACL3P,MAAO4O,EACPiB,SAAU,SAACd,GAAOF,EAAcE,EAAEe,OAAO9P,UAJlD,iBAQA,sBAAKsP,UAAWC,KAAOG,UAAvB,UACE,wBAAQvB,KAAK,SAAb,qBAGA,+BAAM,cAAC,KAAD,CAAMsB,GAAG,kBAAT,uC,6EC9DDM,GAAyB,uCAAG,WAAOC,EAAWC,EAAgBC,GAAlC,iBAAA3Q,EAAA,sEAChBD,EACrBD,ElBU2C,oCkBR3C,CACE2Q,UAAWA,EACXC,eAAgBA,EAChBC,gBAAiBA,IAPkB,cACjCrP,EADiC,gBAUZA,EAASW,OAVG,cAUjCC,EAViC,yBAWhCA,GAXgC,2CAAH,0DAiBzB0O,GAAyB,uCAAG,WAAO5C,GAAP,iBAAAhO,EAAA,sEAChBD,EACrBD,ElBN2C,oCkBQ3C,CAAEkO,mBAAoBA,IAJe,cACjC1M,EADiC,gBAMZA,EAASW,OANG,cAMjCC,EANiC,yBAOhCA,GAPgC,2CAAH,sD,6BCfzB2O,GAAkC,uCAAG,WAAO9O,EAAiB+O,EAAOC,EAAcC,GAA7C,iBAAAhR,EAAA,sEACzBD,EACrBD,EnBIqD,8CmBFrD,CACEiC,gBAAiBA,EACjB+O,MAAOA,EACPC,aAAcA,EACdC,YAAaA,IAR+B,cAC1C1P,EAD0C,gBAWrBA,EAASW,OAXY,cAW1CC,EAX0C,yBAYzCA,GAZyC,2CAAH,4DAgBlC+O,GAAa,OACbC,GAAkB,YAClBC,GAAsB,gBAEtBC,GAAgB,CAC3BH,GACAC,GACAC,IC6HF,IAOeE,iBAPS,SAACrL,GAAD,MAAY,CAChCjC,OAAQiC,EAAMjC,OACdoC,aAAcH,EAAMG,aACpBC,gBAAiBJ,EAAMI,gBACvBe,KAAMnB,EAAMmB,QAGDkK,EAxJf,SAAqBpC,GAKnB,IAAMqC,EAAYrC,EAAMqC,UAElBC,EAAgBC,iBAAO,MAPH,EAS8BtC,oBAAS,GATvC,mBASnBuC,EATmB,KASGC,EATH,OAUcxC,mBAAS,MAVvB,mBAUnB6B,EAVmB,KAULY,EAVK,OAWYzC,mBAAS,MAXrB,mBAWnB8B,EAXmB,KAWNY,EAXM,KAgBpBC,EAAc,uCAAG,WAAef,GAAf,iBAAA9Q,EAAA,6DACf+B,EAAkBkN,EAAM9O,KAAKiF,KADd,SAEMyL,GACzB9O,EACA+O,EACAC,EACAC,GANmB,OAEf9O,EAFe,OAQrB+M,EAAM6C,SAAS5P,EAAa6P,OAC5BL,GAAwB,GATH,2CAAH,sDAedM,EAAY,uCAAG,8BAAAhS,EAAA,0DACbiS,EAAYpD,OAAOqD,gBAGZC,aAAeF,EAAUG,UAJnB,uBAKjBV,GAAwB,GACxBC,EAAgB,MAChBC,EAAe,MAPE,0BAabS,EAASC,SAASL,EAAUE,WAAWI,WAAWC,aAAa,WACrEd,GAAwB,GACxBC,EAAgBU,EAASJ,EAAUlB,cACnCa,EAAeS,EAASJ,EAAUjB,aAhBf,4CAAH,qDAsBZyB,EAAc,uCAAG,sBAAAzS,EAAA,sDACrB0R,GAAwB,GACxBC,EAAgB,MAChBC,EAAe,MAHM,2CAAH,qDAqEpB,OACE,sBAAK7B,UAAWC,KAAO0C,YAAa5B,MAAO,CAAC6B,MAAOrB,GAAnD,UAEE,mBAAGsB,IAAKrB,EAAR,SA5DsB,WAOxB,IANA,IAAMpE,EAAc8B,EAAM9O,KACpB0S,EAAkB1F,EAAYtL,KAC9B4L,EAAgBN,EAAYM,cAE9BqF,EAAc,EACdC,EAAkB,6BACdlM,EAAI,EAAGA,EAAI4G,EAAc7I,OAAQiC,IAAK,CAC1C,IAAImM,EAAevF,EAAc5G,GAE3BoM,EAAeJ,EAAgBK,UACnCJ,EACAE,EAAarF,UAETwF,EAAkBN,EAAgBK,UACtCF,EAAarF,SACbqF,EAAaI,QAIfL,EACE,qCACGA,EACD,sBAAMV,OAAQS,EAAd,SAA4BG,IAC3BD,EAAapE,OAASqC,IACrB,4BAAG,+BAAOkC,MAEXH,EAAapE,OAASsC,IACrB,4BAAG,+BAAOiC,MAEXH,EAAapE,OAASuC,IACrB,iCAAQ,+BAAOgC,SAKrBL,EAAcE,EAAaI,OAG/B,IAAMH,EAAeJ,EAAgBK,UACnCJ,EACAD,EAAgBjO,QAUlB,OAPAmO,EACE,qCACGA,EACD,sBAAMV,OAAQS,EAAd,SAA4BG,OAc3BI,KAEH,cAAC,KAAD,CAASC,aAAc/B,EAAeS,aAAcA,EAAcS,eAAgBA,EAAgBc,OAAQ9B,EAA1G,SACGL,GAAc9K,KAAI,SAACwK,EAAOxE,GACzB,OACE,wBACQsC,KAAK,SACL4E,QAAO,sBAAE,sBAAAxT,EAAA,sEAAoB6R,EAAef,GAAnC,2CAFjB,SAGGA,GAHUxE,c,6BCpIZmH,GAAsB,uCAAG,WAAO1R,GAAP,iBAAA/B,EAAA,sEACbD,EACrBD,ErBFwC,iCqBIxC,CAAEiC,gBAAiBA,IAJe,cAC9BT,EAD8B,gBAMTA,EAASW,OANA,cAM9BC,EAN8B,yBAO7BA,GAP6B,2CAAH,sDA4BtBwR,GAAuC,uCAAG,WAAO3R,GAAP,iBAAA/B,EAAA,sEAC9BD,EACrBD,ErBzB0D,mDqB2B1D,CAAEiC,gBAAiBA,IAJgC,cAC/CT,EAD+C,gBAM1BA,EAASW,OANiB,cAM/CC,EAN+C,yBAO9CA,GAP8C,2CAAH,sDC0BpD,IAEemP,iBAFS,SAACrL,GAAD,MAAY,KAErBqL,EAzDf,SAAqBpC,GAEnB,IAmBIqC,EAnBEnE,EAAc8B,EAAM9O,KACpB4B,EAAkBoL,EAAY/H,KAE9BuO,EAAiB,uCAAG,sBAAA3T,EAAA,sEAClByT,GAAuB1R,GADL,uBAElBkN,EAAM6C,SAAS,CACnBlD,KAAM,qBACN7M,gBAAiBA,IAJK,2CAAH,qDAQjB6R,EAAkB,uCAAG,sBAAA5T,EAAA,sEACnB0T,GAAwC3R,GADrB,uBAEnBkN,EAAM6C,SAAS,CACnBlD,KAAM,iCACN7M,gBAAiBA,IAJM,2CAAH,qDAoBxB,OAVEuP,EAD8B,YAA7BnE,EAAYxG,aACD,OACyB,YAA7BwG,EAAYxG,aACR,QAEA,MAOZ,sBAAKoJ,UAAWC,KAAO6D,YAAvB,UAE0B,SAAvB1G,EAAYrL,OACX,cAAC,GAAD,CAAa3B,KAAMgN,EAAamE,UAAWA,IAC3C,cAAC,YAAD,CAAUwC,SAAU3G,EAAYtL,KAAMkS,eAAgB,CAAEC,WAAY,OAG9C,SAAvB7G,EAAYrL,QACX,wBAAQ8M,KAAK,SAAS4E,QAASI,EAA/B,iCAKF,wBAAQhF,KAAK,SAAS4E,QAASG,EAA/B,0B,oBCfN,IAEetC,iBAFS,SAACrL,GAAD,MAAY,KAErBqL,EAvCf,SAAwBpC,GAKtB,IAAMgF,EAAY,uCAAG,WAAezE,GAAf,eAAAxP,EAAA,6DACnBwP,EAAEC,iBACIzB,EAAqBiB,EAAM9O,KAAKiF,KAFnB,SAGbwL,GAA0B5C,GAHb,uBAIbiB,EAAM6C,SAAS,CACnBlD,KAAM,wBACNZ,mBAAoBA,IANH,2CAAH,sDAaZF,EAAiBmB,EAAM9O,KAC7B,OACE,sBAAK4P,UAAWC,KAAOkE,eAAvB,UACE,4BAAG,4BAEoC,SAAnCpG,EAAe6C,gBACf,6BAA+B7C,EAAe6C,oBAGlD,sBAAMV,SAAQ,uCAAE,WAAOT,GAAP,SAAAxP,EAAA,sEAAqBiU,EAAazE,GAAlC,2CAAF,sDAAd,SACE,wBAAQZ,KAAK,SAAb,4BCyJR,IAOeyC,iBAPS,SAACrL,GAAD,MAAY,CAChCjC,OAAQiC,EAAMjC,OACdoC,aAAcH,EAAMG,aACpBC,gBAAiBJ,EAAMI,gBACvBe,KAAMnB,EAAMmB,QAGDkK,EAhLf,SAAcpC,GAKZ,IAAM9H,EAAO8H,EAAM9H,KACbpD,EAASkL,EAAMlL,OANF,EAQKmL,mBAAS,IARd,mBAQZrN,EARY,KAQNsS,EARM,OAS2BjF,wBAASvM,GATpC,mBASZZ,EATY,KASKqS,EATL,OAUqClF,wBAASvM,GAV9C,mBAUZX,EAVY,KAUUqS,EAVV,OAWOnF,mBAAS,IAXhB,mBAWZoF,EAXY,KAWLC,EAXK,OAYmBrF,oBAAS,GAZ5B,mBAYZsF,EAZY,KAYCC,EAZD,OAaAvF,mBAAS,IAAIwF,KAAY,CAAEC,QAAS,OAAhDC,EAbY,sBAcM1F,mBAAS,IAA3BwB,EAdY,oBAkBnBmE,qBAAU,WAER,IAAMC,EAAeC,aAAY,WAC/B9F,EAAM6C,SAAS,CAAElD,KAAM,kBACtB,KAEH,OAAO,WACLoG,cAAcF,MAIf,IAEH,IAAMG,EAAmB,SAASzF,GAChC,IAAIzN,EAAiB,CACnB,IACMmT,EADMpR,EAAwBC,GACf,GACrBsQ,EAAwBa,GACxBd,EAAmBrQ,EAAOE,WAAWe,MAAMI,MAE7C+O,EAAQ3E,EAAEe,OAAO9P,QAMb0U,EAAiB,uCAAG,WAAe3F,GAAf,iBAAAxP,EAAA,6DACxBwP,EAAEC,iBACI3N,EAASwS,EAAQ,eAAiB,OAFhB,SAGG1S,EACzBC,EAAMC,EAAQC,EAAiBC,GAJT,cAGlBE,EAHkB,gBAOlB+M,EAAM6C,SAAS,CACnBlD,KAAM,qBACNzB,YAAajL,EAAa/B,OATJ,OAYxBkU,OAAwB1R,GACxByR,OAAmBzR,GACnBwR,EAAQ,IAdgB,4CAAH,sDA5CJ,EA6DqBiB,kCAAhCC,EA7DW,EA6DXA,WAAYC,EA7DD,EA6DCA,gBAyDpB,OACE,sBAAKvF,UAAWC,KAAOuF,KAAvB,UACE,8BACGpO,EAAKb,KAAI,SAAC7F,EAAO6L,GAChB,MC5IiB,gBD4Id7L,EAAM+U,MACA,cAAC,GAAD,CAAyBrV,KAAMM,GAAb6L,GC5IP,mBD6IV7L,EAAM+U,MACP,cAAC,GAAD,CAA4BrV,KAAMM,GAAb6L,GAErB,kCAKb,uBAAMyD,UAAWC,KAAOyF,kBAAmBxF,SAAQ,uCAAE,WAAOT,GAAP,SAAAxP,EAAA,sEAAqBmV,EAAkB3F,GAAvC,2CAAF,sDAAnD,UACE,uBAAOZ,KAAK,WACLnO,MAAO6T,EACPhE,SAAU,SAACd,GAAQ+E,EAAS/E,EAAEe,OAAOmF,YAC5C,wBAAQ9G,KAAK,SACL4E,QAvEO,WACfgB,GAmBEmB,KAAkBC,oCACpBD,KAAkBE,gBAGpBjB,EAASkB,OACNC,SAASC,MAAK,YAAqB,IAAD,mBAAlBC,EAAkB,KAAVC,EAAU,KACjC,sBAAC,8BAAAlW,EAAA,6DACOmW,EAAO,IAAIC,KAAKH,EAAQ,YAAa,CACzCrH,KAAMsH,EAAKtH,KACXyH,aAAcjS,KAAKC,QAHtB,SAM4BmM,GAA0B2F,EAAMG,KAAKC,UAAU7F,GAAiB2E,GAN5F,cAMOnT,EANP,gBAQO+M,EAAM6C,SAAS,CACnBlD,KAAM,wBACNd,eAAgB5L,EAAa/B,OAVhC,OAaKwV,KAAkBC,oCACpBN,IAdH,0CAAD,MAmBJb,GAAe,KA3CXkB,KAAkBC,oCACpBD,KAAkBa,eAAe,CAAEC,YAAY,IAcjD7B,EAAS8B,QACTjC,GAAe,KAsDLkC,UAAW5S,EAAOiD,UAF1B,oBAKCsN,EACC,0BAAU1F,KAAK,OACLwB,KAAK,OACLC,YAAY,OACZ5P,MAAOoB,EACPyO,SAAU2E,EACV0B,UAAW5S,EAAOiD,YAE5B,uBAAO4H,KAAK,OACLwB,KAAK,OACLC,YAAY,OACZ5P,MAAOoB,EACPyO,SAAU2E,EACV0B,UAAW5S,EAAOiD,YAE3B,wBAAQ4H,KAAK,SACL+H,UAAW5S,EAAOiD,UAD1B,qBAMF,8B,wCEvKO4P,GAAuB,uCAAG,WAAO9T,EAAW2D,EAAuBhD,GAAzC,eAAAzD,EAAA,sEACdD,EACrBD,E1BgCkC,0B0B9BlC,CAAEgD,YAAW2D,wBAAuBhD,cAJD,cAC/BnC,EAD+B,gBAMxBA,EAASW,OANe,mFAAH,0DAcvB4U,GAAuB,uCAAG,WAAOC,EAAYrT,GAAnB,eAAAzD,EAAA,sEACdD,EACrBD,E1BmBkC,0B0BjBlC,CAAEgX,aAAYrT,cAJqB,cAC/BnC,EAD+B,gBAMxBA,EAASW,OANe,mFAAH,wDAavB8U,GAAqB,uCAAG,WAAOjU,EAAWW,GAAlB,eAAAzD,EAAA,sEACZD,EACrBF,E1BOgC,uB0BLhC,CAAEiD,YAAWW,cAJoB,cAC7BnC,EAD6B,gBAMtBA,EAASW,OANa,mFAAH,wDC9BrB+U,GAA8B,uCAAG,WAAOvT,EAAWwT,EAAsBC,EAAsBC,EAASC,EAAa5K,GAApF,eAAAxM,EAAA,sEACrBD,EACrBD,E3BwC0C,kC2BtC1C,CAAE2D,YAAWwT,uBAAsBC,uBAAsBC,UAASC,cAAa5K,oBAJrC,cACtClL,EADsC,gBAM/BA,EAASW,OANsB,mFAAH,gEAa9BoV,GAA8B,uCAAG,WAAOC,EAAmB7T,EAAW+I,GAArC,eAAAxM,EAAA,sEACrBD,EACrBD,E3B4B0C,kC2B1B1C,CAAEwX,oBAAmB7T,YAAW+I,oBAJU,cACtClL,EADsC,gBAM/BA,EAASW,OANsB,mFAAH,0DCG3C,IAEeoP,iBAFS,SAACrL,GAAD,MAAY,KAErBqL,EAvBf,SAAqBpC,GAAQ,IAAD,EAESA,EAAM9O,KAAjCoX,EAFkB,EAElBA,YAAa9T,EAFK,EAELA,UAEf+T,EAAiB,uCAAG,4BAAAxX,EAAA,sEACG6W,GACzBU,EAAYnS,KAAM3B,GAFI,cAClBvB,EADkB,gBAIlB+M,EAAM6C,SAAS5P,EAAa6P,OAJV,2CAAH,qDAOvB,OACE,gCACE,sCACKwF,EAAY9Q,sBAAwB,OAEzC,wBAAQ+M,QAASgE,EAAjB,0BCYN,IAEenG,iBAFS,SAACrL,GAAD,MAAY,KAErBqL,EA9Bf,SAAuBpC,GAAQ,IAAD,EAE0BA,EAAM9O,KAApDoM,EAFoB,EAEpBA,cAAe9I,EAFK,EAELA,UAAW+I,EAFN,EAEMA,gBAE5BiL,EAAmB,uCAAG,4BAAAzX,EAAA,sEACCqX,GACzB9K,EAAcnH,KAAM3B,EAAW+I,GAFP,cACpBtK,EADoB,gBAIpB+M,EAAM6C,SAAS5P,EAAa6P,OAJR,2CAAH,qDAOnBrJ,EAAa6D,EAAc7D,WAC/B6D,EAAc7D,WAAWjC,sBAAwB,IAAO,YACpDkC,EAAa4D,EAAc5D,WAC/B4D,EAAc5D,WAAWlC,sBAAwB,IAAO,MAE1D,OACE,gCACE,iCACGiC,EADH,MAEGC,EAFH,IAGI4D,EAAc4K,QAAU,QAAU,SAHtC,OAKA,wBAAQ3D,QAASiE,EAAjB,0BC2EN,IAKepG,iBALS,SAACrL,GAAD,MAAY,CAClCsB,eAAgBtB,EAAMsB,eACtB2B,aAAcjD,EAAMiD,gBAGPoI,EA/Ff,SAAmBpC,GAEjB,IAAMlH,EAAQkH,EAAM9O,KACdsD,EAAYsE,EAAM3C,KAClBoH,EAAkBzE,EAAMiC,WAGxBnC,EAFiBoH,EAAM3H,eAEE7D,IAAc,GAPrB,EAS8ByL,mBAAS,IATvC,mBASjBwI,EATiB,KASIC,EATJ,OAUgCzI,mBAAS,QAVzC,mBAUjB+H,EAViB,KAUKW,EAVL,OAWgC1I,mBAAS,QAXzC,mBAWjBgI,EAXiB,KAWKW,EAXL,KAaxBhD,qBAAU,WAAM,4CACd,4BAAA7U,EAAA,sEAC6B+W,GACzBhP,EAAM/C,MAAMI,KAAM3B,GAFtB,cACQvB,EADR,gBAIQ+M,EAAM6C,SAAS5P,EAAa6P,OAJpC,4CADc,uBAAC,WAAD,wBAOd+F,KAEC,IAEH,IAAMC,EAAiB,uCAAG,4BAAA/X,EAAA,sEACG4W,GACzB7O,EAAM/C,MAAMI,KAAMsS,EAAqBjU,GAFjB,cAClBvB,EADkB,gBAIlB+M,EAAM6C,SAAS5P,EAAa6P,OAJV,OAKxB4F,EAAuB,IALC,2CAAH,qDAQjBK,EAAmB,uCAAG,4BAAAhY,EAAA,sEACCgX,GACzBjP,EAAM3C,KACN6R,EACAC,GACA,EACA,KACA1K,GAPwB,cACpBtK,EADoB,gBASpB+M,EAAM6C,SAAS5P,EAAa6P,OATR,2CAAH,qDAYzB,OACE,gCACE,wCACClK,EAAQvB,KAAI,SAAC7F,EAAO6L,GAAR,OACX,cAAC,GAAD,CACanM,KAAM,CACJoX,YAAa9W,EACbgD,UAAWA,IAHR6I,MAMpB,gCACE,uBAAOsC,KAAK,OACLwB,KAAK,wBACLC,YAAY,YACZ5P,MAAOiX,EACPpH,SAAU,SAACd,GAAOmI,EAAuBnI,EAAEe,OAAO9P,UACzD,wBAAQ+S,QAASuE,EAAjB,8BAEF,0CACChQ,EAAMS,UAAUlC,KAAI,SAAC7F,EAAO6L,GAAR,OACnB,cAAC,GAAD,CACenM,KAAM,CACJoM,cAAe9L,EACfgD,UAAWA,EACX+I,gBAAiBA,IAJdF,MAOtB,gCACE,yBAAQ7L,MAAOwW,EAAsB3G,SAAU,SAACd,GAAOoI,EAAwBpI,EAAEe,OAAO9P,QAAxF,UACE,wBAAQA,MAAO,OAAf,uBACCoH,EAAQvB,KAAI,SAAC7F,EAAO6L,GAAR,OACX,yBAAoB7L,MAAOA,EAAM2E,KAAjC,eAA0C3E,EAAMgG,wBAAnC6F,SAGjB,yBAAQ7L,MAAOyW,EAAsB5G,SAAU,SAACd,GAAOqI,EAAwBrI,EAAEe,OAAO9P,QAAxF,UACGoH,EAAQvB,KAAI,SAAC7F,EAAO6L,GAAR,OACX,yBAAoB7L,MAAOA,EAAM2E,KAAjC,eAA0C3E,EAAMgG,wBAAnC6F,MAEf,wBAAQ7L,MAAO,OAAf,oBAEF,wBAAQ+S,QAASwE,EAAjB,oC,oBCpCR,IAKe3G,iBALS,SAACrL,GAAD,MAAY,CAClCjC,OAAQiC,EAAMjC,OACdqF,OAAQpD,EAAMoD,UAGDiI,EA5Df,SAAoBpC,GAAQ,IAAD,EAKnBlH,EAAQkH,EAAM9O,KACd4D,EAASkL,EAAMlL,OACfqF,EAAS6F,EAAM7F,OAPI,EASa8F,oBAAS,GATtB,mBASlB+I,EATkB,KASLC,EATK,KAWnBC,EAAI,uCAAG,WAAe3I,GAAf,SAAAxP,EAAA,sDACXkY,GAAe,GADJ,2CAAH,sDAIJE,EAAI,uCAAG,WAAe5I,GAAf,SAAAxP,EAAA,sDACXkY,GAAe,GADJ,2CAAH,sDAOJG,GAAqB,OAANtU,QAAM,IAANA,GAAA,UAAAA,EAAQE,kBAAR,eAAoBqI,SAApB,OAA6BlD,QAA7B,IAA6BA,OAA7B,EAA6BA,EAAQkD,OACpDgM,GAAYD,GAAgBA,EAAetQ,EAAMuE,MACjDiM,EAASxQ,EAAMiC,YAAcsO,EAAW,IAAM,GACpD,OACE,sBAAKvI,UAAWC,KAAOwI,WAAvB,UACE,iCACGD,EACAxQ,EAAM/C,MAAMoL,QAEdkI,GACC,qCACE,wBAAQvI,UAAWC,KAAOyI,OAAQ7J,KAAK,SAAS4E,QAAO,uCAAE,WAAOhE,GAAP,SAAAxP,EAAA,sEAAqBiP,EAAMyJ,QAAQ3Q,GAAnC,2CAAF,sDAAvD,qBAGEkQ,GACA,wBAAQlI,UAAWC,KAAOyI,OAAQ7J,KAAK,SAAS4E,QAAS2E,EAAzD,kBAIDF,GACC,wBAAQlI,UAAWC,KAAOyI,OAAQ7J,KAAK,SAAS4E,QAAS4E,EAAzD,qBAMLH,GACC,cAAC,GAAD,CAAW9X,KAAM4H,UCmBzB,IAKesJ,iBALS,SAACrL,GAAD,MAAY,CAClCjC,OAAQiC,EAAMjC,OACdiF,aAAchD,EAAMgD,gBAGPqI,EAzEf,SAAyBpC,GAAQ,IAAD,EAKxBlH,EAAQkH,EAAM9O,KACd4D,EAASkL,EAAMlL,OACfiF,EAAeiG,EAAMjG,aACrBI,EAASJ,EAAaA,EAAapE,OAAS,GAC5CnB,EAAYwL,EAAM9O,KAAKiF,KAEvBuT,GAEG,OAAN5U,QAAM,IAANA,OAAA,EAAAA,EAAQiD,aAAmB,OAANjD,QAAM,IAANA,GAAA,UAAAA,EAAQE,kBAAR,eAAoB+F,cAAevG,KAExD,OAACM,QAAD,IAACA,OAAD,EAACA,EAAQiD,aAAT,OAAsBoC,QAAtB,IAAsBA,OAAtB,EAAsBA,EAAQY,cAAoB,OAANZ,QAAM,IAANA,OAAA,EAAAA,EAAQY,cAAevG,EAfxC,EAmBFyL,mBAASyJ,GAnBP,mBAmBvBC,EAnBuB,KAmBfC,EAnBe,KAwBxBC,EAAe,SAAStJ,GAC5BqJ,GAAWD,IAMb,OACE,sBAAK7I,UAAWC,KAAO+I,gBAAvB,UACE,sBAAKhJ,UAAWC,KAAOgJ,KAAvB,UACE,+BACGjR,EAAMkR,WAAW7I,QAElBuI,GACA,wBAAQ5I,UAAWC,KAAOyI,OAAQ7J,KAAK,SAAS4E,QAAO,uCAAE,WAAOhE,GAAP,SAAAxP,EAAA,sEAAqBiP,EAAMyJ,QAAQ3Q,GAAnC,2CAAF,sDAAvD,oBAIDA,EAAME,SAASrD,OAAS,IAAMgU,GAC7B,wBAAQ7I,UAAWC,KAAOyI,OAAQ7J,KAAK,SAAS4E,QAASsF,EAAzD,kBAID/Q,EAAME,SAASrD,OAAS,GAAKgU,GAC5B,wBAAQ7I,UAAWC,KAAOyI,OAAQ7J,KAAK,SAAS4E,QAASsF,EAAzD,qBAKH/Q,EAAME,SAASrD,OAAS,GAAKgU,GAC5B,qBAAK7I,UAAWC,KAAOkJ,SAAvB,SACGnR,EAAME,SAAS3B,KAAI,SAAC7F,EAAO6L,GAAR,OAClB,cAAC,GAAD,CACYnM,KAAMM,EACNiY,QAASzJ,EAAMyJ,SAFVpM,cCsB7B,IAMe+E,iBANS,SAACrL,GAAD,MAAY,CAClCjC,OAAQiC,EAAMjC,OACdkF,aAAcjD,EAAMiD,aACpBD,aAAchD,EAAMgD,gBAGPqI,EAnFf,SAAepC,GAAQ,IAAD,IAOdkK,EAAgB,uCAAG,WAAepR,GAAf,iBAAA/H,EAAA,6DACjByD,EAAYsE,EAAM3C,KADD,SAGjB5B,EAAiBC,GAHA,QAKjBuG,EAAajC,EAAMiC,YAEvBiF,EAAM6C,SAAS,CACblD,KAAM,wBACN5E,WAAYA,EACZvG,UAAWA,IAGbwL,EAAM6C,SAAS,CACblD,KAAM,mBACNnL,UAAWA,IAfQ,2CAAH,sDAuBtB,OACE,sBAAKsM,UAAWC,KAAOoJ,MAAvB,UACE,4BAAG,6CACH,8BACGnK,EAAMjG,aAAa1C,KAAI,SAAC7F,EAAO6L,GAC9B,OAAG7L,EAAMuE,MAEL,cAAC,GAAD,CACY7E,KAAMM,EACNiY,QAAS,cAFJpM,GAMZ,kCAIb,gCACE,4BAAG,iDACH,sCAAI2C,EAAMlL,cAAV,iBAAI,EAAcE,kBAAlB,aAAI,EAA0Be,MAAMoL,UAEtC,4BAAG,6CACH,8BACGnB,EAAMhG,aAAa3C,KAAI,SAAC7F,EAAO6L,GAC9B,OAAG7L,EAAMwY,WAEL,cAAC,GAAD,CACiB9Y,KAAMM,EACNiY,QAASS,GAFJ1Y,EAAM2E,MAKtB3E,EAAMuE,MAEZ,cAAC,GAAD,CACY7E,KAAMM,EACNiY,QAASS,GAFJ1Y,EAAM2E,MAMlB,wC,oBCrENiU,GAAuB,uCAAG,WAAOC,EAAOC,EAAiBC,EAAiBC,EAAsBC,EAAaC,EAAaC,EAAgBC,GAAhH,iBAAA7Z,EAAA,sEACdD,EACrBF,ElCoBiC,gBkClBjC,CACEyZ,QACAC,kBACAC,kBACAC,uBACAC,cACAC,cACAC,iBACAC,gBAZiC,cAC/BvY,EAD+B,gBAeVA,EAASW,OAfC,cAe/BC,EAf+B,yBAgB9BA,GAhB8B,2CAAH,oEAuBvB4X,GAAgB,uCAAG,WAAO/J,EAAWgK,GAAlB,iBAAA/Z,EAAA,sEACPD,EACrBD,ElCAiC,yBkCEjC,CAAEiQ,YAAWgK,gBAJe,cACxBzY,EADwB,gBAMHA,EAASW,OANN,cAMxBC,EANwB,yBAOvBA,GAPuB,2CAAH,wDCbd8X,OAdf,SAAsB/K,GACpB,IAAMgL,EAAehL,EAAM9O,KAC3B,OACE,gCACE,iCACG8Z,EAAaC,SADhB,IAC2BD,EAAanY,OADxC,IACiDmY,EAAa7J,QAE9D,wBAAQxB,KAAK,SAAS4E,QAAO,uCAAE,WAAOhE,GAAP,SAAAxP,EAAA,sEAAqBiP,EAAMkL,WAAWlL,EAAM9O,KAAKqV,MAAOvG,EAAM9O,KAAKiF,MAAnE,2CAAF,sDAA7B,qBC+IN,IAEeiM,iBAFS,SAACrL,GAAD,MAAY,KAErBqL,EAlJf,SAAgBpC,GAAO,MAMqBC,mBAAS,IAN9B,mBAMdkL,EANc,KAMCC,EAND,OAQKnL,mBAAS,IARd,mBAQdoK,EARc,KAQPgB,EARO,OAWuBpL,oBAAS,GAXhC,mBAWdqL,EAXc,KAWEC,EAXF,OAYuBtL,oBAAS,GAZhC,mBAYduL,EAZc,KAYEC,EAZF,OAaiCxL,oBAAS,GAb1C,mBAadyL,EAbc,KAaOC,EAbP,OAeiB1L,oBAAS,GAf1B,mBAedwK,EAfc,KAeDmB,EAfC,OAgBiB3L,oBAAS,GAhB1B,mBAgBdyK,EAhBc,KAgBDmB,EAhBC,OAiBuB5L,oBAAS,GAjBhC,mBAiBd0K,EAjBc,KAiBEmB,EAjBF,OAkBiB7L,oBAAS,GAlB1B,mBAkBd2K,EAlBc,KAkBDmB,EAlBC,KAuBfzL,EAAY,uCAAG,WAAeC,GAAf,eAAAxP,EAAA,6DACnBwP,EAAEC,iBADiB,SAEQ4J,GACzBC,EACAiB,EACAE,EACAE,EACAjB,EACAC,EACAC,EACAC,GAViB,OAEb3X,EAFa,OAYnBmY,EAAiBnY,EAAa/B,MAZX,2CAAH,sDAkBZga,EAAU,uCAAG,WAAepK,EAAWgK,GAA1B,eAAA/Z,EAAA,sEACX8Z,GACJ/J,EACAgK,GAHe,cAMjBM,EAAiB,IANA,SAQmB9W,IARnB,cAQX0X,EARW,gBASXhM,EAAM6C,SAASmJ,EAAsBlJ,OAT1B,2CAAH,wDAYhB,OACE,gCACE,uBAAMhC,UAAWC,KAAOhB,MAAOiB,SAAQ,uCAAE,WAAOT,GAAP,SAAAxP,EAAA,sEAAqBuP,EAAaC,GAAlC,2CAAF,sDAAvC,UACE,wCAEA,wBAAOO,UAAWC,KAAOG,UAAzB,uBAEE,uBAAOvB,KAAK,OACLwB,KAAK,QACLC,YAAY,GACZ5P,MAAO6Y,EACPhJ,SAAU,SAACd,GAAO8K,EAAS9K,EAAEe,OAAO9P,aAG7C,uBAEA,sBAAKsP,UAAWC,KAAOG,UAAvB,UACE,kCACE,uBAAOvB,KAAK,WACL8G,QAAS6E,EACTjK,SAAU,SAACd,GAAOgL,EAAkBhL,EAAEe,OAAOmF,YAHtD,aAOA,kCACE,uBAAO9G,KAAK,WACLwB,KAAK,mBACLsF,QAAS+E,EACTnK,SAAU,SAACd,GAAOkL,EAAkBlL,EAAEe,OAAOmF,YAJtD,aAQA,kCACE,uBAAO9G,KAAK,WACLwB,KAAK,wBACLsF,QAASiF,EACTrK,SAAU,SAACd,GAAOoL,EAAuBpL,EAAEe,OAAOmF,YAJ3D,sBASF,sBAAK3F,UAAWC,KAAOG,UAAvB,UACE,kCACE,uBAAOvB,KAAK,WACL8G,QAASgE,EACTpJ,SAAU,SAACd,GAAOqL,EAAerL,EAAEe,OAAOmF,YAHnD,WAOA,kCACE,uBAAO9G,KAAK,WACL8G,QAASiE,EACTrJ,SAAU,SAACd,GAAOsL,EAAetL,EAAEe,OAAOmF,YAHnD,WAOA,kCACE,uBAAO9G,KAAK,WACL8G,QAASkE,EACTtJ,SAAU,SAACd,GAAOuL,EAAkBvL,EAAEe,OAAOmF,YAHtD,cAOA,kCACE,uBAAO9G,KAAK,WACL8G,QAASmE,EACTvJ,SAAU,SAACd,GAAOwL,EAAexL,EAAEe,OAAOmF,YAHnD,cAQF,uBAEA,qBAAK3F,UAAWC,KAAOG,UAAvB,SACE,wBAAQvB,KAAK,SAAb,yBAMJ,uBAEA,8BACGwL,EAAc9T,KAAI,SAAC7F,EAAO6L,GAAR,OACjB,cAAC,GAAD,CAA0BnM,KAAMM,EAAO0Z,WAAYA,GAAhC7N,cC3IhB4O,GAAuB,uCAAG,WAAOC,EAAMC,GAAb,iBAAApb,EAAA,sEACdD,EACrBD,ErCFyC,+BqCIzC,CAAEqb,OAAMC,UAJ2B,cAC/B9Z,EAD+B,gBAMVA,EAASW,OANC,cAM/BC,EAN+B,yBAO9BA,GAP8B,2CAAH,wDCoBrBmZ,OArBf,SAAqBpM,GAgBnB,OAdA4F,qBAAU,WAAM,4CACd,kCAAA7U,EAAA,6DACQsb,EAAczM,OAAOgB,SAAS0L,OAC9BC,EAAY,IAAIha,gBAAgB8Z,GAChCH,EAAOK,EAAUC,IAAI,QACrBL,EAAQI,EAAUC,IAAI,SAJ9B,SAMQP,GAAwBC,EAAMC,GANtC,OAQEvM,OAAOgB,SAAS6L,KAAO,4BARzB,4CADc,uBAAC,WAAD,wBAWdC,KACC,IAGD,gD,oBChBSC,GAAgB,uCAAG,WAAOnL,EAAWoL,EAAWC,EAAWC,EAAYC,GAApD,iBAAAhc,EAAA,sEACPD,EACrBD,EvCgBiC,uBuCdjC,CACE2Q,UAAWA,EACXoL,UAAWA,EACXC,UAAWA,EACXC,WAAYA,EACZC,UAAWA,IATe,cACxB1a,EADwB,gBAYHA,EAASW,OAZN,cAYxBC,EAZwB,yBAavBA,GAbuB,2CAAH,8DCqFd+Z,OAtFf,SAAgBhN,GAAO,MAKaC,mBAAS,IALtB,mBAKduB,EALc,KAKHyL,EALG,OAMahN,mBAAS,IANtB,mBAMd2M,EANc,KAMHM,EANG,OAOajN,mBAAS,IAPtB,mBAOd4M,EAPc,KAOHM,EAPG,OAQelN,mBAAS,IARxB,mBAQd6M,EARc,KAQFM,EARE,OASanN,mBAAS,IATtB,mBASd8M,EATc,KASHM,EATG,KAcf/M,EAAY,uCAAG,WAAeC,GAAf,SAAAxP,EAAA,6DACnBwP,EAAEC,iBADiB,SAEbmM,GACJnL,EACAoL,EACAC,EACAC,EACAC,GAPiB,OASnBI,EAAa,IACbC,EAAc,IACdC,EAAa,IAXM,2CAAH,sDAclB,OACE,uBAAMvM,UAAWC,KAAOhB,MAAOiB,SAAQ,uCAAE,WAAOT,GAAP,SAAAxP,EAAA,sEAAqBuP,EAAaC,GAAlC,2CAAF,sDAAvC,UACE,wCAEA,wBAAOO,UAAWC,KAAOG,UAAzB,uBAEE,uBAAOvB,KAAK,OACLwB,KAAK,YACLE,SAAU,SAACd,GAAO0M,EAAa1M,EAAEe,OAAOlL,MAAM,UAGvD,wBAAO0K,UAAWC,KAAOG,UAAzB,uBAEE,uBAAOvB,KAAK,OACLwB,KAAK,YACLE,SAAU,SAACd,GAAO2M,EAAa3M,EAAEe,OAAOlL,MAAM,UAGvD,uBAEA,wBAAO0K,UAAWC,KAAOG,UAAzB,uBAEE,uBAAOvB,KAAK,OACLwB,KAAK,YACLC,YAAY,aACZ5P,MAAOqb,EACPxL,SAAU,SAACd,GAAO4M,EAAa5M,EAAEe,OAAO9P,aAGjD,wBAAOsP,UAAWC,KAAOG,UAAzB,wBAEE,uBAAOvB,KAAK,OACLwB,KAAK,aACLC,YAAY,cACZ5P,MAAOsb,EACPzL,SAAU,SAACd,GAAO6M,EAAc7M,EAAEe,OAAO9P,aAGlD,wBAAOsP,UAAWC,KAAOG,UAAzB,uBAEE,uBAAOvB,KAAK,OACLwB,KAAK,YACLC,YAAY,aACZ5P,MAAOub,EACP1L,SAAU,SAACd,GAAO8M,EAAa9M,EAAEe,OAAO9P,aAGjD,uBAEA,qBAAKsP,UAAWC,KAAOG,UAAvB,SACE,wBAAQvB,KAAK,SAAb,0B,oBCiDR,IAOeyC,iBAPS,SAACrL,GAAD,MAAY,CAChCjC,OAAQiC,EAAMjC,OACdiF,aAAchD,EAAMgD,aACpBC,aAAcjD,EAAMiD,aACpBnE,SAAUkB,EAAMlB,YAGLuM,EAtIf,SAAgBpC,GAAQ,IAAD,MAKflL,EAASkL,EAAMlL,OACfe,EAAWmK,EAAMnK,SACjBE,EAAK,OAAGjB,QAAH,IAAGA,GAAH,UAAGA,EAAQE,kBAAX,aAAG,EAAoBe,MAC5BgE,EAAeiG,EAAMjG,aACrBI,EAASJ,EAAaA,EAAapE,OAAS,GAC5CqE,EAAegG,EAAMhG,aACrBI,EACEJ,EAAarE,OACVqE,EAAa,GAAGhB,SAASrD,OACxBqE,EAAa,GAAGhB,SAAS,GACzBgB,EAAa,QACftG,EAhBW,EAsBSuM,mBAAS,GAtBlB,mBAsBLqN,GAtBK,WAgDrB,OAJiC,KAAxB,OAANxY,QAAM,IAANA,GAAA,UAAAA,EAAQE,kBAAR,eAAoBqI,QAAgBlD,GACrCyF,OAAOgB,SAASC,SAIhB,qCACE,sBAAKC,UAAWC,KAAOwM,IAAvB,UACE,4BAAG,0CACH,mCAAIpT,QAAJ,IAAIA,GAAJ,UAAIA,EAAQpE,aAAZ,aAAI,EAAeoL,UAGrB,sBAAKL,UAAWC,KAAOwM,IAAvB,UACE,4BAAG,mDACK,OAANzY,QAAM,IAANA,OAAA,EAAAA,EAAQiD,aAAR,OAAqBjD,QAArB,IAAqBA,OAArB,EAAqBA,EAAQoF,YAC7B,mCAAInE,QAAJ,IAAIA,OAAJ,EAAIA,EAAOoL,SAEX,OAACrM,QAAD,IAACA,OAAD,EAACA,EAAQiD,cAAa,OAACjD,QAAD,IAACA,OAAD,EAACA,EAAQoF,WAC/B,8CAIJ,sBAAK4G,UAAWC,KAAOwM,IAAvB,UACE,4BAAG,0CACH,mCAAInT,QAAJ,IAAIA,OAAJ,EAAIA,EAAQrE,MAAMoL,UAGpB,qBAAKL,UAAWC,KAAOwM,IAAvB,WAzCF,OAAGzY,QAAH,IAAGA,OAAH,EAAGA,EAAQoF,UACFpF,EAAOkD,SAAWlD,EAAOC,WAC3B,OAAGD,QAAH,IAAGA,OAAH,EAAGA,EAAQiD,WACT5C,KAAKC,MAAQN,EAAOC,eAE3B,IAqCoB,eAGpB,sBAAK+L,UAAWC,KAAOwM,IAAvB,UACE,wBAAQzM,UAAWC,KAAOyI,OAClBjF,QAASvE,EAAMwN,UACf9F,UAAW7R,EAAS+G,gBAF5B,mBAKO,OAAN9H,QAAM,IAANA,OAAA,EAAAA,EAAQoF,WACP,wBAAQ4G,UAAWC,KAAOyI,OAClBjF,QAASvE,EAAMrJ,KACf+Q,UAAW7R,EAAS+G,gBAF5B,mBAMK,OAAN9H,QAAM,IAANA,OAAA,EAAAA,EAAQiD,YACP,wBAAQ+I,UAAWC,KAAOyI,OAClBjF,QAASvE,EAAM9J,MACfwR,UAAW7R,EAAS+G,gBAF5B,mBAMF,wBAAQkE,UAAWC,KAAOyI,OAClBjF,QAASvE,EAAMyN,UACf/F,UAAW7R,EAAS+G,gBAF5B,qBAMF,sBAAKkE,UAAWC,KAAOwM,IAAvB,WACG,OAACzY,QAAD,IAACA,OAAD,EAACA,EAAQiD,YACR,wBAAQ+I,UAAWC,KAAOyI,OAClBjF,QAAS,WAAQvE,EAAMxJ,KAAK,aAC5BkR,UAAW7R,EAAS+G,gBAF5B,uBAMD,OAAC9H,QAAD,IAACA,OAAD,EAACA,EAAQiD,YACR,wBAAQ+I,UAAWC,KAAOyI,OAClBjF,QAAS,WAAQvE,EAAMxJ,KAAK,YAC5BkR,UAAW7R,EAAS+G,gBAF5B,sBAMD,OAAC9H,QAAD,IAACA,OAAD,EAACA,EAAQiD,YACR,wBAAQ+I,UAAWC,KAAOyI,OAClBjF,QA/Ec,WAC5B+I,GAAW,SAAAI,GAAI,OAAIA,EAAO,MA+EZhG,UAAW7R,EAAS+G,gBAF5B,+BC7GV,IAIewF,iBAJS,SAACrL,GAAD,MAAY,CAClCkI,aAAclI,EAAMkI,gBAGPmD,EAdf,SAAsBpC,GACpB,OAAKA,EAAMf,aAKT,mBAAGwN,KAAMzM,EAAMf,aAAa0O,QAAQC,iBAApC,0CAJO,gCC6WX,IAOexL,iBAPS,SAACrL,GAAD,MAAY,CAChCjC,OAAQiC,EAAMjC,OACde,SAAUkB,EAAMlB,SAChBkE,aAAchD,EAAMgD,aACpBC,aAAcjD,EAAMiD,gBAGToI,EAtVf,SAAyBpC,GAKvB,IAAMlL,EAASkL,EAAMlL,OACfe,EAAWmK,EAAMnK,SACjBkE,EAAeiG,EAAMjG,aACrBI,EAASJ,EAAaA,EAAapE,OAAS,GAC5CqE,EAAegG,EAAMhG,aACrBI,EACQJ,EAAarE,OACVqE,EAAa,GAAGhB,SAASrD,OACxBqE,EAAa,GAAGhB,SAAS,GACzBgB,EAAa,QACftG,EAfc,EAkBkCuM,oBAAS,GAlB3C,mBAkBvB4N,EAlBuB,KAkBGC,EAlBH,OAmBoC7N,mBAAS,IAnB7C,mBAmBvB8N,EAnBuB,KAmBIC,EAnBJ,OAoBY/N,mBAAS,IApBrB,mBAoBvBgO,EApBuB,KAoBRC,EApBQ,KAyBxBC,EAAU,uCAAG,8BAAApd,EAAA,sEACyBmC,IADzB,cACXkb,EADW,gBAE4Bjb,IAF5B,cAEXkb,EAFW,gBAGXrO,EAAM6C,SAASuL,EAA4BtL,OAHhC,wBAIX9C,EAAM6C,SAASwL,EAA+BvL,OAJnC,4CAAH,qDA0BVoI,EAAU,uCAAG,gCAAAna,EAAA,sEAGXiP,EAAM6C,SAAS,CAAElD,KAAM,qBAHZ,uBAMmB7L,EAAc,UAChDgB,EAAOE,kBADyC,aAChD,EAAmBkE,2BAA2B,GAP/B,UAMXoV,EANW,OAUdlU,EAAOrE,MAAMC,UAAYpB,EAVX,iCAWYhB,EAAmBwG,EAAOrE,MAAMI,MAX5C,cAWTlD,EAXS,iBAYT+M,EAAM6C,SAAS5P,EAAa6P,OAZnB,eAgBjBoL,EAAiBI,GAhBA,UAmBXtO,EAAM6C,SAAS,CAAElD,KAAM,wBAnBZ,QAsBjBmO,GAA4B,GAtBX,4CAAH,qDA4BVS,EAAgB,uCAAG,sBAAAxd,EAAA,6DACpB+D,EAAOE,WAAWe,MAAMC,UAAYpB,GACrCgB,EAAcC,EAAUf,GAFH,SAIjBkL,EAAM6C,SAAS,CACnBlD,KAAM,4BACN7F,QAAS,CAAEA,QAASmU,EAAcnL,SANb,uBAQjB9C,EAAM6C,SAAS,CAAElD,KAAM,oBARN,uBASjBwO,IATiB,2CAAH,qDAehBX,EAAS,uCAAG,8BAAAzc,EAAA,sEACViP,EAAM6C,SAAS,CAAElD,KAAM,qBADb,UAEb7K,EAAOE,WAAWe,MAAMC,UAAYpB,GACrCgB,EAAcC,EAAUf,GAEvBqF,EAAOpE,MAAMC,UAAYpB,EALZ,gCAMahB,EAAmBuG,EAAOpE,MAAMI,MAN7C,cAMRlD,EANQ,gBAOR+M,EAAM6C,SAAS5P,EAAa6P,OAPpB,wBASoB3O,IATpB,eASVqa,EATU,iBAUVxO,EAAM6C,SAAS2L,EAAsB1L,OAV3B,yBAWV9C,EAAM6C,SAAS,CAAElD,KAAM,mBAXb,yBAYVK,EAAM6C,SAAS,CAAElD,KAAM,oBAZb,yBAaVwO,IAbU,4CAAH,qDAmBTV,EAAS,uCAAG,gCAAA1c,EAAA,sEACViP,EAAM6C,SAAS,CAAElD,KAAM,qBADb,UAEb7K,EAAOE,WAAWe,MAAMC,UAAYpB,GACrCgB,EAAcC,EAAUf,GAEvBsF,EAAOrE,MAAMC,UAAYpB,EALZ,gCAMahB,EAAmBwG,EAAOrE,MAAMI,MAN7C,cAMRlD,EANQ,gBAOR+M,EAAM6C,SAAS5P,EAAa6P,OAPpB,wBASoBhP,EAAc,UAChDgB,EAAOE,kBADyC,aAChD,EAAmBkE,2BAA2B,GAVhC,eASVoV,EATU,iBAYVtO,EAAM6C,SAASyL,EAAsBxL,OAZ3B,yBAaV9C,EAAM6C,SAAS,CAAElD,KAAM,mBAbb,yBAcVK,EAAM6C,SAAS,CAAElD,KAAM,oBAdb,yBAeVwO,IAfU,4CAAH,qDA0BT3X,EAAI,uCAAG,sDAAAzF,EAAA,6DAAe0d,EAAf,oCAA2B/a,EAA3B,SACLsM,EAAM6C,SAAS,CAAElD,KAAM,qBADlB,UAIM,YAAd8O,EAJQ,iCAKcpa,EACrBS,EAAOE,WAAWkE,2BANX,UASqB,MATrB,OASGwV,OAAOjb,OATV,kCAUDuM,EAAM6C,SAAS,CAAElD,KAAM,oBAVtB,0CAaT5K,EAAYD,EAAOC,UAAa,IAbvB,2BAca,aAAd0Z,EAdC,kCAeHra,IAfG,QAgBHua,EAAO,IAAIxZ,KACXyZ,EAAWD,EAAKE,UAChBC,EAAoBha,EAAOC,UAAY,IAE7CA,EADyB6Z,EAAWE,EACL,EAAIA,EAAoBF,EApB9C,wBAsBT7Z,EAAYD,EAAOC,UAtBV,yBAyBLiL,EAAM6C,SAAS,CACnBlD,KAAM,aACN7F,QAAS,CAAChF,OAAO,2BAAMA,GAAP,IAAeC,UAAWA,OA3BjC,eA8BLga,EAAMla,EAAwBC,EAAQC,GACtCia,EAAsBD,EAAI,GAChCzY,EAAaT,EAAUf,EAAQC,GAhCpB,UAiCLiL,EAAM6C,SAAS,CAAElD,KAAM,kCAjClB,eAoCRqP,IACKC,EAAgBC,YAAW,WAC/B1Y,MACCwY,GAEHhP,EAAM6C,SAAS,CACblD,KAAM,6BACN7F,QAAS,CAAEgC,kBAAmBmT,MA3CvB,UA+CLjP,EAAM6C,SAAS,CAAElD,KAAM,oBA/ClB,4CAAH,qDAqDJzJ,EAAK,uCAAG,4BAAAnF,EAAA,sEACNiP,EAAM6C,SAAS,CAAElD,KAAM,qBADjB,uBAEe1L,IAFf,cAENkb,EAFM,gBAGNnP,EAAM6C,SAASsM,EAAarM,OAHtB,uBAIN9C,EAAM6C,SAAS,CAAElD,KAAM,kCAJjB,cAKZ/J,EAAcC,EAAUf,GACxBmH,aAAa8R,GAND,UAON/N,EAAM6C,SAAS,CAAElD,KAAM,oBAPjB,4CAAH,qDAaLhJ,EAAI,uCAAG,4BAAA5F,EAAA,sEACLiP,EAAM6C,SAAS,CAAElD,KAAM,qBADlB,uBAEgBzL,IAFhB,cAELib,EAFK,gBAGLnP,EAAM6C,SAASsM,EAAarM,OAHvB,UAOPjN,EAASkC,UAPF,kCAQHiI,EAAM6C,SAAS,CAAElD,KAAM,oBARpB,2DAYLK,EAAM6C,SAAS,CAAElD,KAAM,kCAZlB,eAaX/I,EAAaf,EAAUf,GAbZ,UAcLkL,EAAM6C,SAAS,CAAElD,KAAM,oBAdlB,4CAAH,qDAiGV,OA7EAiG,qBAAU,WAQR,GAJE9Q,EAAOiD,WACPlC,EAASkC,YACRlC,EAASgG,sBAMT,OAAC/G,QAAD,IAACA,OAAD,EAACA,EAAQE,YAAZ,CAKA,IAAME,EAAWC,KAAKC,MAAQN,EAAOC,UAC/Bqa,EACEta,EAAOE,WAAWkE,0BAA4BhE,EAGhDma,EAAYH,YAAW,WAC3BhE,MAFsBkE,EAAW,KAInCpP,EAAM6C,SAAS,CACblD,KAAM,+BACN7F,QAAS,CAAE+B,oBAAqBwT,KAIlC,IACML,EADMna,EAAwBC,EAAQA,EAAOC,WACnB,GAChC,GAAGia,EAAqB,CACtB,IAAMC,EAAgBC,YAAW,WAC/B1Y,MACCwY,GAEHhP,EAAM6C,SAAS,CACblD,KAAM,6BACN7F,QAAS,CAAEgC,kBAAmBmT,SAKjC,CAACpZ,IAKJ+P,qBAAU,WAGR,GAAIiI,EAAJ,CAGAC,GAA4B,GAG5B,IAAM5Y,EAAWC,KAAKC,MAAQN,EAAOC,UAC/Bua,EACExa,EAAOE,WAAWkE,0BAA4BhE,EAEhDma,EAAYH,YAAW,WAC3BX,MACCe,GACHrT,aAAa8R,GACbC,EAA6BqB,MAG5B,CAACxB,IAGD/Y,EAAOiD,YAAclC,EAASkC,WAAalC,EAASyF,SAnQjDxG,EAAOE,WAAWe,QAGtBiK,EAAM6C,SAAS,CAAElD,KAAM,qBrC5BE,SAAS9J,EAAUf,GAC9C,IACMyB,EADM1B,EAAwBC,EAAQA,EAAOC,WAClB,GAC3Be,EAAkBhB,EAAOE,WAAWe,MAAMC,QAEhD,GAAGF,IAAoBpB,EACrBmB,EAASI,WAAWU,KAAK,CACvB4Y,KAAM,CAACza,EAAOE,WAAWe,MAAMyF,YAC/BgU,YAAajZ,SAEV,GAAGT,IAAoBnB,QAEvB,GAAGmB,IAAoBlB,EAAuB,CACnD,IAAMf,EAAYiB,EAAOE,WAAWe,MAAMI,KACpCE,EAAQR,EAASO,MAAMvC,GAAWwC,MACxCoZ,QAAQC,IAAInZ,GACTA,EAAuB,EACxB2Y,YAAW,WACT7Y,EAAMM,UACJJ,IAEJF,EAAMK,YAAcH,EAAuB,IAC3CF,EAAMM,SqCQR2F,CAAczG,EAAUf,IAmQxB,mCACA,eAAC,KAAD,WACE,cAAC,KAAD,CAAO6a,KAAK,YAAZ,SACE,cAAC,GAAD,MAEF,cAAC,KAAD,CAAOA,KAAK,QAAZ,SACE,cAAC,GAAD,MAEF,cAAC,KAAD,CAAOA,KAAK,UAAZ,SACE,cAAC,GAAD,CAAQlC,UAAWA,EACXD,UAAWA,EACXhX,KAAMA,EACNN,MAAOA,EACPS,KAAMA,MAEhB,cAAC,KAAD,CAAOgZ,KAAK,SAAZ,SACE,cAAC,GAAD,MAEF,cAAC,KAAD,CAAOA,KAAK,UAAZ,SACE,cAAC,GAAD,MAEF,cAAC,KAAD,CAAOA,KAAK,UAAZ,SACE,cAAC,GAAD,MAEF,cAAC,KAAD,CAAOA,KAAK,WAAZ,SACE,cAAC,GAAD,cClVFC,GAAgBC,EAAQ,KA8KfC,OA3Kf,WAAe,MAOe7P,mBAAS,WAPxB,mBAONxM,EAPM,KAOEsc,EAPF,KA8Fb,OApFAnK,qBAAU,WAAM,4CACd,4CAAA7U,EAAA,sEAI6ByC,IAJ7B,wCAMMuc,EAAU,mBANhB,iCAWEA,EAAU,iBAXZ,SAcuBpc,IAdvB,cAcEV,EAdF,iBAeQwM,GAAMoD,SAAS5P,EAAa6P,OAfpC,WAiBQhJ,EAAU7G,EAAa6P,MAAMhJ,SAEjB,QADZkW,EAlBR,UAkB0BlW,EAAQhF,OAAOE,kBAlBzC,aAkB0B,EAA2Be,aACjC,IAAfia,OAAA,EAAAA,EAAiBha,WAAYpB,EAnBlC,wBAoBUf,EAAYmc,EAAgB7Z,KApBtC,UAqByBvC,EAAmBC,GArB5C,eAqBIZ,EArBJ,iBAsBUwM,GAAMoD,SAAS5P,EAAa6P,OAtBtC,yBAsCuBxO,IAtCvB,eAsCErB,EAtCF,iBAuCQwM,GAAMoD,SAAS5P,EAAa6P,OAvCpC,yBA0CyC5P,IA1CzC,eA0CQ+c,EA1CR,iBA2CQxQ,GAAMoD,SAASoN,EAAyBnN,OA3ChD,yBA8C4C3P,IA9C5C,eA8CQ+c,EA9CR,iBA+CQzQ,GAAMoD,SAASqN,EAA4BpN,OA/CnD,yBAkDyCrO,IAlDzC,eAkDQ0b,EAlDR,iBAmDQ1Q,GAAMoD,SAAS,CACnBlD,KAAM,oBACNV,aAAckR,EAAyBjf,OArD3C,eAyDQ+E,EAAa,IAAI2Z,IACZQ,eAAeD,EAAyBjf,KAAKyc,QAAQ0C,aA1DlE,UA2DQ5Q,GAAMoD,SAAS,CACnBlD,KAAM,mBACN7F,QAAS,CAAE7D,WAAYA,KA7D3B,yBAiEQwJ,GAAMoD,SAAS,CAAElD,KAAM,oBAjE/B,QAmEEoQ,EAAU,SAnEZ,6CADc,uBAAC,WAAD,wBAsEdlH,GAEAjJ,OAAO0Q,iBAAiB,gBAAgB,SAAC/P,GACvCA,EAAEC,iBACF,IAAMzJ,EAAQ0I,GAAM8Q,WAChBxZ,EAAMjC,OAAOiD,YAGjB9D,IACA2B,EAAcmB,EAAMlB,SAAUkB,EAAMjC,cAErC,IAGW,YAAXrB,EAEC,cAAC,KAAD,UACE,cAAC,KAAD,CAAUgM,MAAOA,GAAjB,SACE,iCAOM,oBAAXhM,EAEC,cAAC,KAAD,UACE,cAAC,KAAD,CAAUgM,MAAOA,GAAjB,SACE,qBAAKqB,UAAU,qBAAf,SACE,qBAAKA,UAAU,WAAf,SACE,cAAC,GAAD,YASE,kBAAXrN,EAEC,cAAC,KAAD,UACE,cAAC,KAAD,CAAUgM,MAAOA,GAAjB,0BASJ,cAAC,KAAD,UACE,eAAC,KAAD,CAAUA,MAAOA,GAAjB,UAGE,8BACE,+BACE,6BACE,cAAC,KAAD,CAAMwB,GAAG,YAAT,wBAEF,6BACE,cAAC,KAAD,CAAMA,GAAG,QAAT,oBAEF,6BACE,cAAC,KAAD,CAAMA,GAAG,UAAT,sBAEF,6BACE,cAAC,KAAD,CAAMA,GAAG,SAAT,qBAEF,6BACE,cAAC,KAAD,CAAMA,GAAG,UAAT,sBAEF,6BACE,cAAC,KAAD,CAAMA,GAAG,UAAT,2BAMN,qBAAKH,UAAU,qBAAf,SACE,qBAAKA,UAAU,WAAf,SACE,cAAC,GAAD,cClLG0P,GAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,8BAAqB3J,MAAK,YAAkD,IAA/C4J,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCDdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,GAAD,MAEFC,SAASC,eAAe,SAM1BZ,M,mBCfAhgB,EAAOC,QAAU,CAAC,OAAS,uBAAuB,UAAY,4B,mBCA9DD,EAAOC,QAAU,CAAC,gBAAkB,yCAAyC,KAAO,8BAA8B,OAAS,gCAAgC,SAAW,oC,mBCAtKD,EAAOC,QAAU,CAAC,MAAQ,qBAAqB,UAAY,2B,mBCA3DD,EAAOC,QAAU,CAAC,OAAS,uBAAuB,UAAY,4B,mBCA9DD,EAAOC,QAAU,CAAC,WAAa,+BAA+B,OAAS,6B,mBCAvED,EAAOC,QAAU,CAAC,KAAO,mBAAmB,SAAW,uBAAuB,QAAU,wB,mBCAxFD,EAAOC,QAAU,CAAC,YAAc,iCAAiC,QAAU,+B,mBCA3ED,EAAOC,QAAU,CAAC,YAAc,iCAAiC,QAAU,+B,mBCA3ED,EAAOC,QAAU,CAAC,eAAiB,yC,mBCAnCD,EAAOC,QAAU,CAAC,MAAQ,uB","file":"static/js/main.5fd8cd81.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"Player\":\"Player_Player__RgpZ6\",\"Div\":\"Player_Div__HhfjS\",\"Button\":\"Player_Button__1m74t\"};","const BACKEND_DOMAIN = process.env.REACT_APP_BACKEND_DOMAIN;\nconst TYPE_GET = 'GET';\nconst TYPE_POST = 'POST';\n\nexport { BACKEND_DOMAIN, TYPE_GET, TYPE_POST }\n","import { BACKEND_DOMAIN } from '../config/global'\n\n\nasync function fetchBackend(method = '', url = '', data = {}) {\n  let response;\n\n  url = BACKEND_DOMAIN + url;\n\n  if(method !== 'GET') {\n\n    // aggregate form data in one place\n    const formData = new FormData();\n    for (const [key, value] of Object.entries(data)) {\n      formData.append(key, value);\n    }\n    // for (const [key, value] of Object.entries(files)) {\n    //   formData.append(key, value);\n    // }\n\n    // authenticate request if possible\n    let requestOptions = {headers: {}}\n    const token = localStorage.getItem('accessToken');\n    if(token) {\n      requestOptions.headers.Authorization = `Bearer ${token}`;\n    }\n    const request = new Request(url, requestOptions);\n\n    // make the request\n    response = await fetch(request, {\n      method: method,\n      mode: 'cors',\n      body: formData,\n    });\n  } else {\n\n    // translate form data for GET\n    let searchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(data)) {\n      searchParams.set(key, value);\n    }\n    const getUrl = url + '/?' + searchParams.toString();\n\n    // authenticate request if possible\n    let requestOptions = {headers: {'Content-Type': 'application/json'}}\n    const token = localStorage.getItem('accessToken');\n    if(token) {\n      requestOptions.headers.Authorization = `Bearer ${token}`;\n    }\n    const request = new Request(getUrl, requestOptions);\n\n    // make the request\n    response = await fetch(request, {\n      method: method,\n      mode: 'cors',\n    });\n  }\n\n  return response;\n}\n\nexport { fetchBackend }\n","import {\n  ENDPOINT_TEXT_COMMENT_CREATE,\n  ENDPOINT_TEXT_COMMENT_LIST,\n  ENDPOINT_VOICE_RECORDING_LIST\n} from '../../config/api'\nimport { TYPE_GET, TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n\n/*\n * Fetches...\n */\nexport const fetchTextCommentCreate = async (text, format, textCommentUuid, textCommentTimestamp) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_TEXT_COMMENT_CREATE,\n    { text, format, textCommentUuid, textCommentTimestamp },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nexport const fetchTextCommentList = async () => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_TEXT_COMMENT_LIST\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nexport const fetchVoiceRecordingList = async () => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_VOICE_RECORDING_LIST\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","// AUTHENTICATION\nexport const ENDPOINT_OBTAIN_TOKENS = '/auth/obtain-tokens/'\nexport const ENDPOINT_REFRESH_TOKEN = '/auth/refresh-token/'\nexport const ENDPOINT_VERIFY_TOKEN = '/auth/verify-token/'\n\n// USER\nexport const ENDPOINT_USER_GET_SETTINGS = '/users/user/get-settings'\nexport const ENDPOINT_USER_CONNECT_SPOTIFY = '/users/user/connect-spotify/'\n\n// TEXT COMMENT\nexport const ENDPOINT_TEXT_COMMENT_CREATE = '/comments/text-comment/create/'\nexport const ENDPOINT_TEXT_COMMENT_UPDATE = '/comments/text-comment/update/'\nexport const ENDPOINT_TEXT_COMMENT_DELETE = '/comments/text-comment/delete/'\nexport const ENDPOINT_TEXT_COMMENT_LIST = '/comments/text-comment/list'\n\n// TEXT COMMENT MODIFICATION\nexport const ENDPOINT_TEXT_COMMENT_MODIFICATION_CREATE = '/comments/text-comment-modification/create/'\nexport const ENDPOINT_TEXT_COMMENT_MODIFICATION_LIST_DELETE = '/comments/text-comment-modification/list-delete/'\n\n// VOICE RECORDING\nexport const ENDPOINT_VOICE_RECORDING_CREATE = '/comments/voice-recording/create/'\nexport const ENDPOINT_VOICE_RECORDING_DELETE = '/comments/voice-recording/delete/'\nexport const ENDPOINT_VOICE_RECORDING_LIST = '/comments/voice-recording/list'\n\n// TRACK\nexport const ENDPOINT_TRACK_CREATE = '/music/track/create/'\nexport const ENDPOINT_TRACK_GET_FILES = '/music/track/get-files'\n\n// MUSIC\nexport const ENDPOINT_MUSIC_SEARCH = '/music/search'\n\n// QUEUE\nexport const ENDPOINT_QUEUE_CREATE = '/streams/queue/create/'\nexport const ENDPOINT_QUEUE_DELETE = '/streams/queue/delete/'\nexport const ENDPOINT_QUEUE_LIST = '/streams/queue/list'\n\n// STREAM\nexport const ENDPOINT_STREAM_GET = '/streams/stream/get'\nexport const ENDPOINT_STREAM_INITIALIZE = '/streams/stream/initialize/'\nexport const ENDPOINT_STREAM_NEXT_TRACK = '/streams/stream/next-track/'\nexport const ENDPOINT_STREAM_PAUSE_TRACK = '/streams/stream/pause-track/'\nexport const ENDPOINT_STREAM_PLAY_TRACK = '/streams/stream/play-track/'\nexport const ENDPOINT_STREAM_PREV_TRACK = '/streams/stream/prev-track/'\nexport const ENDPOINT_STREAM_SCAN_BACKWARD = '/streams/stream/scan-backward/'\nexport const ENDPOINT_STREAM_SCAN_FORWARD = '/streams/stream/scan-forward/'\n\n// MARKER\nexport const ENDPOINT_MARKER_CREATE = '/streams/marker/create/'\nexport const ENDPOINT_MARKER_DELETE = '/streams/marker/delete/'\nexport const ENDPOINT_MARKER_LIST = '/streams/marker/list'\n\n// QUEUE INTERVAL\nexport const ENDPOINT_QUEUE_INTERVAL_CREATE = '/streams/queue-interval/create/'\nexport const ENDPOINT_QUEUE_INTERVAL_DELETE = '/streams/queue-interval/delete/'\n","import {\n  ENDPOINT_OBTAIN_TOKENS,\n  ENDPOINT_STREAM_INITIALIZE,\n  ENDPOINT_VERIFY_TOKEN,\n} from '../../config/api'\nimport { TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n/*\n * Fetches an auth token from the server.\n */\nexport const fetchAuthToken = async (username, password) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_OBTAIN_TOKENS,\n    { username: username, password: password },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n\n/*\n * Fetches an auth token from the server.\n */\nexport const fetchInitializeStream = async () => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_INITIALIZE,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n\n/*\n * Fetches...\n */\nexport const fetchVerifyToken = async () => {\n  const token = localStorage.getItem('accessToken');\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_VERIFY_TOKEN,\n    { token: token }\n  );\n  if(response.status !== 200) {\n    //throw new Error(\"Not logged in!\");\n    return undefined;\n  }\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import {\n  ENDPOINT_STREAM_GET,\n  ENDPOINT_TRACK_GET_FILES,\n  ENDPOINT_STREAM_NEXT_TRACK,\n  ENDPOINT_STREAM_PAUSE_TRACK,\n  ENDPOINT_STREAM_PLAY_TRACK,\n  ENDPOINT_STREAM_PREV_TRACK,\n  ENDPOINT_STREAM_SCAN_BACKWARD,\n  ENDPOINT_STREAM_SCAN_FORWARD,\n} from '../../config/api'\nimport { TYPE_GET, TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n\n/*\n * Fetches...\n */\nconst fetchStreamGet = async () => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_STREAM_GET,\n  );\n  return await response.json();\n};\n\n\nconst fetchTrackGetFiles = async(trackUuid) => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_TRACK_GET_FILES,\n    { trackUuid },\n  );\n  return await response.json();\n}\n\n\n/*\n * Fetches...\n */\nconst fetchNextTrack = async (nowPlayingTotalDurationMilliseconds, isPlanned) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_NEXT_TRACK,\n    { nowPlayingTotalDurationMilliseconds, isPlanned }\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nconst fetchPauseTrack = async () => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_PAUSE_TRACK,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nconst fetchPlayTrack = async () => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_PLAY_TRACK,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nconst fetchPrevTrack = async () => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_PREV_TRACK,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nconst fetchScanBackward = async () => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_SCAN_BACKWARD,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nconst fetchScanForward = async (nowPlayingTotalDurationMilliseconds) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_SCAN_FORWARD,\n    { nowPlayingTotalDurationMilliseconds }\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\nexport {\n  fetchStreamGet,\n  fetchNextTrack,\n  fetchPauseTrack,\n  fetchPlayTrack,\n  fetchPrevTrack,\n  fetchScanBackward,\n  fetchScanForward,\n  fetchTrackGetFiles,\n}\n","import { ENDPOINT_QUEUE_LIST, ENDPOINT_QUEUE_DELETE } from '../../config/api'\nimport { TYPE_GET, TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n/*\n * Fetches...\n */\nexport const fetchQueueList = async () => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_QUEUE_LIST,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nexport const fetchDeleteQueue = async (queueUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_QUEUE_DELETE,\n    { queueUuid: queueUuid },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import {\n  ENDPOINT_USER_GET_SETTINGS\n} from '../../config/api'\nimport { TYPE_GET } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n/*\n * Fetches an user settings from the server.\n */\nexport const fetchGetUserSettings = async () => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_USER_GET_SETTINGS,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n","export const SERVICE_SPOTIFY = 'spotify';\nexport const SERVICE_YOUTUBE = 'youtube';\nexport const SERVICE_JUKEBOX_RADIO = 'jukebox_radio';\n","import {\n  SERVICE_SPOTIFY,\n  SERVICE_YOUTUBE,\n  SERVICE_JUKEBOX_RADIO,\n} from '../../config/services';\n\n\n/*\n * This gets the position that the track should be at.\n *\n * @return [\n *   progress: Time in milliseconds,\n *   seekTimeout: Time in milliseconds until the next seek should happen,\n * ]\n */\nexport const getPositionMilliseconds = function(stream, startedAt) {\n  if(!stream.nowPlaying) {\n    return [undefined, undefined];\n  }\n\n  let progress = Date.now() - startedAt,\n      seekTimeout,\n      playbackIntervalIdx = 0,\n      cumulativeProgress = 0;\n\n  while(true) {\n    const playbackInterval = stream.nowPlaying.playbackIntervals[playbackIntervalIdx],\n          playbackIntervalDuration = playbackInterval[1] - playbackInterval[0],\n          remainingProgress = progress - cumulativeProgress;\n    if(remainingProgress < playbackIntervalDuration) {\n      progress = playbackInterval[0] + remainingProgress;\n      seekTimeout = playbackInterval[1] - progress;\n      break;\n    }\n    playbackIntervalIdx += 1;\n    cumulativeProgress += playbackIntervalDuration;\n  }\n\n  if(playbackIntervalIdx === stream.nowPlaying.playbackIntervals.length - 1) {\n    seekTimeout = undefined;\n  }\n\n  return [progress, seekTimeout];\n}\n\n\n/*\n *\n */\nexport const playbackStart = function(playback, stream) {\n  const arr = getPositionMilliseconds(stream, stream.startedAt),\n        positionMilliseconds = arr[0],\n        playbackService = stream.nowPlaying.track.service;\n\n  if(playbackService === SERVICE_SPOTIFY) {\n    playback.spotifyApi.play({\n      uris: [stream.nowPlaying.track.externalId],\n      position_ms: positionMilliseconds,\n    });\n  } else if(playbackService === SERVICE_YOUTUBE) {\n    // TODO\n  } else if(playbackService === SERVICE_JUKEBOX_RADIO) {\n    const trackUuid = stream.nowPlaying.track.uuid,\n          audio = playback.files[trackUuid].audio;\n    console.log(positionMilliseconds)\n    if(positionMilliseconds < 0) {\n      setTimeout(function() {\n        audio.play();\n      }, -positionMilliseconds);\n    } else {\n      audio.currentTime = positionMilliseconds / 1000;\n      audio.play();\n    }\n  }\n};\n\n\n/*\n *\n */\nexport const playbackPause = function(playback, stream) {\n  const playbackService = stream.nowPlaying.track.service;\n\n  if(playbackService === SERVICE_SPOTIFY) {\n    playback.spotifyApi.pause();\n  } else if(playbackService === SERVICE_YOUTUBE) {\n    // TODO\n  } else if(playbackService === SERVICE_JUKEBOX_RADIO) {\n    const trackUuid = stream.nowPlaying.track.uuid,\n          audio = playback.files[trackUuid].audio;\n    audio.pause();\n  }\n}\n\n\n/*\n *\n */\nexport const playbackSeek = function(playback, stream, startedAt) {\n  const arr = getPositionMilliseconds(stream, startedAt),\n        positionMilliseconds = arr[0],\n        playbackService = stream.nowPlaying.track.service;\n\n  if(playbackService === SERVICE_SPOTIFY) {\n    playback.spotifyApi.seek(positionMilliseconds);\n  } else if(playbackService === SERVICE_YOUTUBE) {\n    // TODO\n  } else if(playbackService === SERVICE_JUKEBOX_RADIO) {\n    const trackUuid = stream.nowPlaying.track.uuid,\n          audio = playback.files[trackUuid].audio;\n    audio.load();\n    audio.currentTime = positionMilliseconds / 1000;\n    audio.play();\n  }\n}\n\n\n/*\n *\n */\nexport const playbackPlay = function(playback, stream) {\n  const playbackService = stream.nowPlaying.track.service;\n\n  if(playbackService === SERVICE_SPOTIFY) {\n    playback.spotifyApi.play();\n  } else if(playbackService === SERVICE_YOUTUBE) {\n    // TODO\n  } else if(playbackService === SERVICE_JUKEBOX_RADIO) {\n    const trackUuid = stream.nowPlaying.track.uuid,\n          audio = playback.files[trackUuid].audio;\n    audio.play();\n  }\n}\n\n\n/*\n *\n */\nexport const playbackSkipToNext = function(playback, stream) {\n  const playbackService = stream.nowPlaying.track.service;\n\n  if(playbackService === SERVICE_SPOTIFY) {\n    playback.spotifyApi.skipToNext();\n  } else if(playbackService === SERVICE_YOUTUBE) {\n    // TODO\n  } else if(playbackService === SERVICE_JUKEBOX_RADIO) {\n    // TODO\n  }\n}\n\n\n/*\n *\n */\nexport const playbackQueue = function(playback, stream, nextUp) {\n  const playbackService = stream.nowPlaying.track.service;\n\n  if(playbackService === SERVICE_SPOTIFY) {\n    playback.spotifyApi.queue(nextUp.track.externalId);\n  } else if(playbackService === SERVICE_YOUTUBE) {\n    // TODO\n  } else if(playbackService === SERVICE_JUKEBOX_RADIO) {\n    // TODO\n  }\n}\n","/*\n * - history: A tag given to a feed item which signifies that it is no longer\n *            relevant. This is because it has been lingering on for a\n *            significant amount of time since its original context.\n * - display: A tag given to a feed item which signifies that it is still\n *            \"fresh.\" It is within a reasonable amount of time since its\n *            original context.\n */\nconst RENDER_STATUS_HISTORY = 'history',\n      RENDER_STATUS_DISPLAY = 'display',\n      RENDER_STATUS_HIDE = 'hide',\n      DISPLAY_DURATION = 30000,\n      HISTORY_DURATION = 45000;\n\n/*\n * ...\n */\nexport const feedGenerate = function(state) {\n\n  const stream = state.stream,\n        [progress, displayThreshold, historyThreshold] = getPositionMilliseconds(stream);\n\n  if(!progress) {\n    return [];\n  }\n\n  const textComments = [...state.textComments],\n        voiceRecordings = [...state.voiceRecordings];\n  let aggregateFeed = [...textComments, ...voiceRecordings];\n\n  aggregateFeed = aggregateFeed.map(el => {\n    const shouldTagHistory = (\n            el.timestampMilliseconds > historyThreshold &&\n            el.timestampMilliseconds <= displayThreshold\n          ),\n          shouldTagDisplay = (\n            el.timestampMilliseconds > displayThreshold &&\n            el.timestampMilliseconds <= progress\n          );\n\n    if(shouldTagHistory) {\n      el.renderStatus = RENDER_STATUS_HISTORY;\n    } else if(shouldTagDisplay) {\n      el.renderStatus = RENDER_STATUS_DISPLAY;\n    } else {\n      el.renderStatus = RENDER_STATUS_HIDE;\n    }\n\n    return { ...el };\n  });\n  aggregateFeed = aggregateFeed.filter(i => (\n    i.renderStatus !== RENDER_STATUS_HIDE\n  ));\n  aggregateFeed = aggregateFeed.sort((a, b) => {\n    return a.timestampMilliseconds - b.timestampMilliseconds;\n  });\n  return aggregateFeed;\n}\n\n\nexport const getPositionMilliseconds = function(stream) {\n\n  if(!stream?.nowPlaying?.track) {\n    return [undefined, undefined, undefined];\n  }\n\n  const startedAt = stream.startedAt;\n\n  let progress = (\n        stream.isPlaying ? Date.now() - startedAt : stream.pausedAt - startedAt\n      ),\n      playbackIntervalIdx = 0,\n      displayThreshold = 0,\n      historyThreshold = 0,\n      cumulativeProgress = 0;\n\n  while(true) {\n    const playbackInterval = stream.nowPlaying.playbackIntervals[playbackIntervalIdx],\n          playbackIntervalDuration = playbackInterval[1] - playbackInterval[0];\n    let remainingProgress;\n\n    // if display threshold progress definition has been reached\n    const displayProgress = (progress - DISPLAY_DURATION);\n    remainingProgress = displayProgress - cumulativeProgress;\n    if(remainingProgress >= 0 && remainingProgress < playbackIntervalDuration) {\n      displayThreshold = playbackInterval[0] + remainingProgress;\n    }\n\n    // if history threshold progress definition has been reached\n    const historyProgress = (progress - DISPLAY_DURATION - HISTORY_DURATION);\n    remainingProgress = historyProgress - cumulativeProgress;\n    if(remainingProgress >= 0 && remainingProgress < playbackIntervalDuration) {\n      historyThreshold = playbackInterval[0] + remainingProgress;\n    }\n\n    // if the progress definition has been reached\n    remainingProgress = progress - cumulativeProgress;\n    if(remainingProgress < playbackIntervalDuration) {\n      progress = playbackInterval[0] + remainingProgress;\n      break;\n    }\n\n    playbackIntervalIdx += 1;\n    cumulativeProgress += playbackIntervalDuration;\n  }\n\n  return [progress, displayThreshold, historyThreshold];\n}\n\n\n/*\n * ...\n */\nexport const feedUpdate = function(state) {\n  return {\n    ...state,\n    feed: feedGenerate(state),\n  }\n}\n","/*\n * Create a marker relevant to a queue item (track).\n */\nexport const markerCreate = function(state, action) {\n  const trackMarkerMap = { ...state.trackMarkerMap },\n        queueUuid = action.queueUuid,\n        marker = action.marker,\n        markers = [...trackMarkerMap[queueUuid], marker],\n        sortedMarkers = markers.sort((a, b) => {\n          return a.timestampMilliseconds - b.timestampMilliseconds;\n        });\n  trackMarkerMap[queueUuid] = sortedMarkers;\n  return {\n    ...state,\n    trackMarkerMap: trackMarkerMap,\n  };\n}\n\n/*\n * Delete a marker relevant to a queue item (track).\n */\nexport const markerDelete = function(state, action) {\n  const trackMarkerMap = { ...state.trackMarkerMap },\n        queueUuid = action.queueUuid,\n        marker = action.marker,\n        markers = trackMarkerMap[action.queueUuid],\n        filteredMarkers = markers.filter(m => m.uuid !== marker.uuid);\n  trackMarkerMap[queueUuid] = filteredMarkers;\n  return {\n    ...state,\n    trackMarkerMap: trackMarkerMap,\n  };\n}\n\n/*\n * Set the markers on a queue item (track).\n */\nexport const markerList = function(state, action) {\n  const queueUuid = action.queueUuid,\n        markers = action.markers,\n        trackMarkerMap = { ...state.trackMarkerMap };\n  trackMarkerMap[queueUuid] = markers;\n  return {\n    ...state,\n    trackMarkerMap: trackMarkerMap\n  };\n}\n","/*\n * A queue object is returned from the server with an assortment of\n * intervals. These intervals must be interpreted on the front-end\n * to put together the full picture - how long is the queue item\n * expected to play for?\n */\nexport const finalizeQueue = function(queue) {\n  const copy = { ...queue };\n\n  // Recursive case: parent node (queue item of format collection)\n  if(copy.children.length) {\n    const editedChildren = copy.children.map(finalizeQueue),\n          totalDurationMilliseconds = editedChildren.reduce((total, q) => (\n            total + q.durationMilliseconds\n          ), 0);\n    copy.children = editedChildren;\n    copy.totalDurationMilliseconds = totalDurationMilliseconds;\n    return copy;\n  }\n\n  const intervals = copy.intervals,\n        trackDurationMilliseconds = copy.track?.durationMilliseconds;\n  if(!intervals.length) {\n    copy.totalDurationMilliseconds = trackDurationMilliseconds;\n    copy.playbackIntervals = [[0, trackDurationMilliseconds]];\n    return copy;\n  }\n\n  const playbackIntervals = [];\n  let lowerBound,\n      upperBound;\n  // NOTE: here it is assumed that all intervals are muted.\n  for(const interval of intervals) {\n    if(!interval.lowerBound) {\n      lowerBound = interval.upperBound.timestampMilliseconds;\n      continue;\n    } else if(!interval.upperBound) {\n      if(!lowerBound) {\n        lowerBound = 0;\n      }\n      upperBound = interval.lowerBound.timestampMilliseconds;\n      playbackIntervals.push([lowerBound, upperBound]);\n      // Setting this value signifies that the playbackIntervals array is\n      // finished.\n      lowerBound = undefined;\n      // This is the end of the interval array anyways. Explicitly break here\n      // just for clarity.\n      break;\n    } else {\n      if(!lowerBound) {\n        lowerBound = 0;\n      }\n      upperBound = interval.lowerBound.timestampMilliseconds;\n      playbackIntervals.push([lowerBound, upperBound]);\n      lowerBound = interval.upperBound.timestampMilliseconds;\n      upperBound = undefined;\n      continue;\n    }\n  }\n\n  if(lowerBound) {\n    upperBound = trackDurationMilliseconds;\n    playbackIntervals.push([lowerBound, upperBound]);\n  }\n\n  const totalDurationMilliseconds = playbackIntervals.reduce((total, i) => (\n    total + (i[1] - i[0])\n  ), 0);\n\n  copy.totalDurationMilliseconds = totalDurationMilliseconds;\n  copy.playbackIntervals = playbackIntervals;\n\n  return copy;\n}\n\n\n/*\n * A queue object is returned from the server with an assortment of\n * intervals. These intervals must be interpreted on the front-end\n * to put together the full picture - how long is the queue item\n * expected to play for?\n */\nexport const queueListSet = function(state, payload) {\n  const lastUpQueues = payload.lastUpQueues.map(finalizeQueue),\n        nextUpQueues = payload.nextUpQueues.map(finalizeQueue),\n        _lastPlayed = state._lastPlayed;\n\n  if(_lastPlayed) {\n    lastUpQueues.push(_lastPlayed);\n  }\n\n  let stream = state.stream;\n  if(!stream.isPlaying && !stream.isPaused && stream.nowPlaying) {\n    lastUpQueues.push(stream.nowPlaying);\n    stream = { ...stream, nowPlaying: undefined }\n  }\n\n  const lastUp = (\n          !lastUpQueues.length ?\n            undefined :\n            lastUpQueues[lastUpQueues.length - 1]\n        ),\n        nextUp = (\n          !nextUpQueues.length ? undefined : (\n            !nextUpQueues[0].children.length ?\n              nextUpQueues[0] :\n              nextUpQueues[0].children[0]\n          )\n        );\n\n  return {\n    ...state,\n    stream: stream,\n    lastUp: lastUp,\n    lastUpQueues: lastUpQueues,\n    nextUp: nextUp,\n    nextUpQueues: nextUpQueues,\n  }\n}\n"," import { finalizeQueue } from './queue';\n\n\n/*\n * ...\n */\nexport const streamSet = function(state, payload) {\n  const stream = payload.stream,\n        nowPlaying = stream.nowPlaying,\n        obj = { ...state };\n\n  if(nowPlaying) {\n    stream.nowPlaying = finalizeQueue(nowPlaying);\n  }\n\n  obj.stream = stream;\n\n  if(!stream.isPlaying && !stream.isPaused && stream.nowPlaying) {\n    obj.lastUp = stream.nowPlaying;\n    obj._lastPlayed = stream.nowPlaying;\n    obj.stream.nowPlaying = undefined;\n    obj.stream.isPlaying = false;\n    obj.stream.isPaused = false;\n  } else if(stream.isPlaying) {\n    const progress = Date.now() - stream.startedAt;\n    if(progress && progress >= stream.nowPlaying.totalDurationMilliseconds) {\n      obj.lastUp = stream.nowPlaying;\n      obj._lastPlayed = stream.nowPlaying;\n      obj.stream.nowPlaying = undefined;\n      obj.stream.isPlaying = false;\n      obj.stream.isPaused = false;\n    }\n  }\n\n  return obj;\n}\n\n\n/*\n * ...\n */\nexport const streamPlay = function(state, payload) {\n  const updatedPayload = {\n    stream: {\n      ...state.stream,\n      isPlaying: true,\n      isPaused: false,\n      startedAt: payload.startedAt,\n    }\n  };\n  return streamSet(state, updatedPayload);\n}\n\n\n/*\n * ...\n */\nexport const streamPause = function(state, payload) {\n  const updatedPayload = {\n    stream: {\n      ...state.stream,\n      isPlaying: false,\n      isPaused: true,\n      pausedAt: payload.pausedAt,\n    }\n  };\n  return streamSet(state, updatedPayload);\n}\n\n\n/*\n * Set the stream context.\n */\nexport const streamPrevTrack = function(state, payload) {\n  const lastUpQueues = [...state.lastUpQueues],\n        nextUpQueues = [...state.nextUpQueues],\n        lastNowPlaying = state.stream.nowPlaying,\n        nextUpQueue = nextUpQueues[0],\n        nextNowPlaying = lastUpQueues[lastUpQueues.length - 1];\n\n  const isTrackInCollection = (\n    lastNowPlaying?.parentUuid &&\n    nextUpQueue?.uuid &&\n    lastNowPlaying?.parentUuid === nextUpQueue?.uuid\n  );\n  if(lastNowPlaying) {\n    if(isTrackInCollection) {\n      nextUpQueue.children.unshift(lastNowPlaying);\n    } else {\n      nextUpQueues.unshift(lastNowPlaying);\n    }\n  }\n\n  lastUpQueues.pop();\n\n  return {\n      ...state,\n      stream: {\n        ...state.stream,\n        startedAt: payload.startedAt,\n        nowPlaying: nextNowPlaying,\n        isPlaying: true,\n        isPaused: false,\n      },\n      lastUpQueues: lastUpQueues,\n      nextUpQueues: nextUpQueues,\n      _lastPlayed: undefined,\n  };\n}\n\n\n/*\n * ...\n */\nexport const streamNextTrack = function(state, payload) {\n  const lastUpQueues = [...state.lastUpQueues],\n        nextUpQueues = [...state.nextUpQueues],\n        lastNowPlaying = state.stream.nowPlaying,\n        nextUpQueue = nextUpQueues[0],\n        nextNowPlaying = (\n          nextUpQueue ?\n            (nextUpQueue.children.length ?\n              nextUpQueue.children[0] :\n              nextUpQueue) :\n            undefined\n        );\n\n  if(lastNowPlaying) {\n    lastUpQueues.push(lastNowPlaying);\n  }\n\n  if(nextUpQueue) {\n    if(nextUpQueue.children.length) {\n      nextUpQueue.children.shift();\n      if(!nextUpQueue.children.length) {\n        nextUpQueues.shift();\n      }\n    } else {\n      nextUpQueues.shift();\n    }\n  }\n\n  return {\n      ...state,\n      stream: {\n        ...state.stream,\n        startedAt: payload.startedAt,\n        nowPlaying: nextNowPlaying,\n        isPlaying: !!nextNowPlaying,\n        isPaused: false,\n      },\n      lastUpQueues: lastUpQueues,\n      nextUpQueues: nextUpQueues,\n      _lastPlayed: lastNowPlaying,\n  };\n}\n","import { SERVICE_SPOTIFY } from '../../config/services';\nimport {\n  playbackQueue,\n  playbackSkipToNext,\n} from '../../components/PlaybackWrapper/playback';\nimport { streamNextTrack } from './stream';\n\n\n/*\n *\n */\nconst getNextUp = function(state) {\n  const nextUpQueues = state.nextUpQueues,\n        nextUp = (\n          nextUpQueues.length ?\n            (nextUpQueues[0].children.length ?\n              nextUpQueues[0].children[0] :\n              nextUpQueues[0]) :\n            undefined\n        );\n  return nextUp;\n}\n\n\n/*\n *\n */\nexport const playbackSpotify = function(state, payload) {\n  return {\n    ...state,\n    playback: {\n      ...state.playback,\n      spotifyApi: payload.spotifyApi,\n      isReady: true,\n    }\n  }\n}\n\n\n/*\n * Assumptions:\n *   - There is currently something playing in the stream.\n *   - We are not certain that something is up next.\n */\nexport const playbackAddToQueue = function(state) {\n  const nextUp = getNextUp(state);\n  if(!nextUp) {\n    return { ...state };\n  }\n\n  const playback = { ...state.playback },\n        nowPlaying = state.stream.nowPlaying,\n        spotifyShouldAddToQueue = (\n          nowPlaying.track.service === SERVICE_SPOTIFY &&\n          nextUp.track.service === SERVICE_SPOTIFY &&\n          nextUp.playbackIntervals[0][0] === 0\n        );\n\n  if(spotifyShouldAddToQueue) {\n    playbackQueue(state.playback, state.stream, nextUp);\n\n    playback.queuedUp = true;\n\n    const lastInterval = (\n      nowPlaying.playbackIntervals[nowPlaying.playbackIntervals.length - 1]\n    );\n    if(lastInterval[1] === nowPlaying.track.durationMilliseconds) {\n      playback.noopNextTrack = true;\n    }\n  } else {\n    // TODO: do pre-loaded if needed\n  }\n\n  return {\n    ...state,\n    playback: playback,\n  }\n}\n\n\n/*\n *\n */\nconst playbackPlannedNextTrackHelper = function(state) {\n  const nextUp = getNextUp(state),\n        queuedUp = state.playback.queuedUp,\n        noopNextTrack = state.playback.noopNextTrack,\n        addToQueueTimeoutId = state.playback.addToQueueTimeoutId,\n        nextSeekTimeoutId = state.playback.nextSeekTimeoutId,\n        playback = {\n          ...state.playback,\n          queuedUp: false,\n          noopNextTrack: false,\n        };\n  if(!nextUp || noopNextTrack) {\n    playback.addToQueueTimeoutId = undefined;\n    return {\n      ...state,\n      playback: playback,\n    };\n  }\n\n  if(queuedUp) {\n    playbackSkipToNext(state.playback, state.stream);\n    playback.addToQueueTimeoutId = undefined;\n    return {\n      ...state,\n      playback: playback,\n    };\n  }\n\n  clearTimeout(addToQueueTimeoutId);\n  clearTimeout(nextSeekTimeoutId);\n  playback.isPlaying = false;\n  playback.addToQueueTimeoutId = undefined;\n  playback.nextSeekTimeoutId = undefined;\n  return {\n    ...state,\n    playback: playback,\n  };\n}\n\n\n/*\n *\n */\nexport const playbackPlannedNextTrack = function(state, payload) {\n  let updatedState = state;\n  updatedState = playbackPlannedNextTrackHelper(updatedState);\n  const childPayload = payload.payload,  // yes\n        updatedNowPlaying = updatedState.stream.nowPlaying;\n  childPayload.startedAt = (\n    updatedState.stream.startedAt + updatedNowPlaying.totalDurationMilliseconds\n  );\n  updatedState = streamNextTrack(updatedState, childPayload);\n  return updatedState;\n}\n\n\n/*\n *\n */\nexport const playbackStart = function(state) {\n  const addToQueueTimeoutId = state.playback.addToQueueTimeoutId,\n        nextSeekTimeoutId = state.playback.nextSeekTimeoutId,\n        playback = {\n          ...state.playback,\n          queuedUp: false,\n          noopNextTrack: false,\n          isPlaying: false,\n          addToQueueTimeoutId: undefined,\n        };\n\n  clearTimeout(addToQueueTimeoutId);\n  clearTimeout(nextSeekTimeoutId);\n\n  return {\n    ...state,\n    playback: playback,\n  };\n}\n\n\n/*\n *\n */\nexport const playbackStarted = function(state) {\n  const playback = {\n          ...state.playback,\n          isPlaying: true,\n        };\n  return {\n    ...state,\n    playback: playback,\n  };\n}\n\n\nexport const playbackAddToQueueReschedule = function(state) {\n  const addToQueueTimeoutId = state.playback.addToQueueTimeoutId,\n        nextSeekTimeoutId = state.playback.nextSeekTimeoutId,\n        playback = {\n          ...state.playback,\n          addToQueueTimeoutId: undefined,\n          nextSeekTimeoutId: undefined,\n        };\n\n  clearTimeout(addToQueueTimeoutId);\n  clearTimeout(nextSeekTimeoutId);\n\n  return {\n    ...state,\n    playback: playback,\n  };\n}\n\n\nexport const playbackAddToQueueScheduled = function(state, payload) {\n  const playback = {\n          ...state.playback,\n          addToQueueTimeoutId: payload.addToQueueTimeoutId,\n        };\n  return {\n    ...state,\n    playback: playback,\n  };\n}\n\n\nexport const playbackNextSeekScheduled = function(state, payload) {\n  const nextSeekTimeoutId = state.playback.nextSeekTimeoutId,\n        playback = {\n          ...state.playback,\n          nextSeekTimeoutId: payload.nextSeekTimeoutId,\n        };\n\n  clearTimeout(nextSeekTimeoutId);\n\n  return {\n    ...state,\n    playback: playback,\n  };\n}\n\n\nexport const playbackDisable = function(state) {\n  return {\n    ...state,\n    playback: {\n      ...state.playback,\n      controlsEnabled: false,\n    }\n  }\n}\n\n\nexport const playbackEnable = function(state) {\n  return {\n    ...state,\n    playback: {\n      ...state.playback,\n      controlsEnabled: true,\n    }\n  }\n}\n\n\nexport const playbackLoadFiles = function(state, payload) {\n  const playback = { ...state.playback },\n        files = { ...state.playback.files };\n\n  const audio = new Audio(payload.track.audioUrl);\n\n  files[payload.track.uuid] = {\n    audio: audio,\n  }\n  return {\n    ...state,\n    playback: {\n      ...playback,\n      files: files,\n    }\n  };\n}\n"," import { finalizeQueue } from './queue';\n\n\n/*\n * Used to \"findIndex\" by uuid in an array.\n */\nconst findByUuid = function(uuid) {\n  return (o => o.uuid === uuid);\n}\n\n\n/*\n * Used to \"filter\" out by uuid in an array.\n */\nconst filterByUuid = function(uuid) {\n  return (o => o.uuid !== uuid);\n}\n\n\n/*\n * Used to \"sort\" and array containing queue intervals.\n */\nconst sortQueueIntervals = function(a, b) {\n  if(!b.upperBound) {\n    return -1;\n  } else if(!a.upperBound) {\n    return 1;\n  } else {\n    return (\n      a.upperBound.timestampMilliseconds -\n      a.upperBound.timestampMilliseconds\n    );\n  }\n}\n\n\n/*\n * Create a queue interval relevant to a queue item (track).\n */\nexport const queueIntervalCreate = function(state, action) {\n  const queueInterval = action.queueInterval,\n        queueUuid = action.queueUuid,\n        parentQueueUuid = action.parentQueueUuid;\n\n  // get the queue that the queue interval belongs too.\n  let queues = state.nextUpQueues;\n  let parentIndex = -1, index;\n  if(parentQueueUuid) {\n    parentIndex = queues.findIndex(findByUuid(parentQueueUuid));\n    queues = queues[parentIndex].children;\n  }\n  index = queues.findIndex(findByUuid(queueUuid));\n  const trackQueue = queues[index];\n\n  // add queue interval to that queue (and sort).\n  const queueIntervals = [...trackQueue.intervals, queueInterval],\n        sortedQueueIntervals = queueIntervals.sort(sortQueueIntervals);\n\n  // save the state\n  const nextUpQueues = [...state.nextUpQueues];\n  if(parentIndex !== -1) {\n    nextUpQueues[parentIndex].children[index].intervals = sortedQueueIntervals;\n  } else {\n    nextUpQueues[index].intervals = sortedQueueIntervals;\n  }\n\n  // update playback intervals\n  const finalizedNextUpQueues = nextUpQueues.map(finalizeQueue);\n\n  return {\n    ...state,\n    nextUpQueues: finalizedNextUpQueues,\n  };\n}\n\n\n/*\n * Delete a queue interval relevant to a queue item (track).\n */\nexport const queueIntervalDelete = function(state, action) {\n  const queueInterval = action.queueInterval,\n        queueUuid = action.queueUuid,\n        parentQueueUuid = action.parentQueueUuid;\n\n  // get the queue that the queue interval belongs too.\n  let queues = state.nextUpQueues;\n  let parentIndex = -1, index;\n  if(parentQueueUuid) {\n    parentIndex = queues.findIndex(findByUuid(parentQueueUuid));\n    queues = queues[parentIndex].children;\n  }\n  index = queues.findIndex(findByUuid(queueUuid));\n  const trackQueue = queues[index];\n\n  // delete queue interval from that queue.\n  const queueIntervals = [...trackQueue.intervals],\n        filteredQueueIntervals = queueIntervals.filter(filterByUuid(queueInterval.uuid));\n\n  // save the state\n  const nextUpQueues = [...state.nextUpQueues];\n  if(parentIndex !== -1) {\n    nextUpQueues[parentIndex].children[index].intervals = filteredQueueIntervals;\n  } else {\n    nextUpQueues[index].intervals = filteredQueueIntervals;\n  }\n\n  // update playback intervals\n  const finalizedNextUpQueues = nextUpQueues.map(finalizeQueue);\n\n  return {\n   ...state,\n   nextUpQueues: finalizedNextUpQueues,\n  };\n}\n","import { feedGenerate } from './feed';\n\n\n/*\n * ...\n */\nexport const textCommentListSet = function(state, payload) {\n  const textComments = payload.textComments,\n        updatedState = {\n          ...state,\n          textComments: textComments,\n        };\n\n  return {\n    ...updatedState,\n    feed: feedGenerate(updatedState),\n  };\n}\n\n\n/*\n *\n */\nexport const textCommentCreate = function(state, action) {\n  const textComments = [...state.textComments, action.textComment],\n        updatedState = {\n          ...state,\n          textComments: textComments,\n        };\n\n  return {\n    ...updatedState,\n    feed: feedGenerate(updatedState),\n  };\n}\n\n\n/*\n *\n */\nexport const textCommentDelete = function(state, action) {\n  const deleteByUuid = i => i.uuid !== action.textCommentUuid,\n        textComments = state.textComments.filter(deleteByUuid),\n        updatedState = {\n          ...state,\n          textComments: textComments,\n        };\n\n  return {\n    ...updatedState,\n    feed: feedGenerate(updatedState),\n  };\n}\n","/*\n * ...\n */\nexport const textCommentModificationCreate = function(state, payload) {\n  const textCommentModification = payload.textCommentModification,\n        textCommentUuid = payload.textCommentUuid,\n        textComments = [...state.textComments],\n        textCommentIndex = textComments.findIndex(t => (\n          t.uuid === textCommentUuid\n        )),\n        textComment = textComments[textCommentIndex],\n        modifications = [...textComment.modifications];\n\n  modifications.push(textCommentModification);\n  const sortedModifications = modifications.sort((a, b) => {\n    return a.startPtr - b.startPtr;\n  });\n  textComments[textCommentIndex].modifications = sortedModifications;\n\n  return {\n    ...state,\n    textComments: textComments,\n  }\n}\n","import { feedGenerate } from './feed';\n\n\n/*\n * ...\n */\nexport const voiceRecordingListSet = function(state, payload) {\n  const voiceRecordings = payload.voiceRecordings,\n        updatedState = {\n          ...state,\n          voiceRecordings: voiceRecordings,\n        };\n\n  return {\n    ...updatedState,\n    feed: feedGenerate(updatedState),\n  };\n}\n\n\n/*\n * ...\n */\nexport const voiceRecordingCreate = function(state, action) {\n  const voiceRecordings = [...state.voiceRecordings, action.voiceRecording],\n        updatedState = {\n          ...state,\n          voiceRecordings: voiceRecordings,\n        };\n\n  return {\n    ...updatedState,\n    feed: feedGenerate(updatedState),\n  };\n}\n\n\n/*\n * ...\n */\nexport const voiceRecordingDelete = function(state, action) {\n  const deleteByUuid = i => i.uuid !== action.voiceRecordingUuid,\n        voiceRecordings = state.voiceRecordings.filter(deleteByUuid),\n        updatedState = {\n          ...state,\n          voiceRecordings: voiceRecordings,\n        };\n\n  return {\n    ...updatedState,\n    feed: feedGenerate(updatedState),\n  };\n}\n","import { createStore } from 'redux';\nimport { feedUpdate } from './reducers/feed';\nimport {\n  markerCreate,\n  markerDelete,\n  markerList,\n} from './reducers/marker';\nimport {\n  playbackSpotify,\n  playbackAddToQueue,\n  playbackPlannedNextTrack,\n  playbackStart,\n  playbackStarted,\n  playbackAddToQueueReschedule,\n  playbackAddToQueueScheduled,\n  playbackNextSeekScheduled,\n  playbackDisable,\n  playbackEnable,\n  playbackLoadFiles,\n} from  './reducers/playback';\nimport { queueListSet } from './reducers/queue';\nimport {\n  queueIntervalCreate,\n  queueIntervalDelete,\n} from './reducers/queueInterval';\nimport {\n  streamSet,\n  streamPlay,\n  streamPause,\n  streamPrevTrack,\n  streamNextTrack,\n} from './reducers/stream';\nimport {\n  textCommentListSet,\n  textCommentCreate,\n  textCommentDelete,\n} from './reducers/textComment';\nimport {\n  textCommentModificationCreate,\n} from './reducers/textCommentModification';\nimport {\n  voiceRecordingListSet,\n  voiceRecordingCreate,\n  voiceRecordingDelete,\n} from './reducers/voiceRecording';\n\n\nconst initialState = {\n  nextUpQueues: [],\n  lastUpQueues: [],\n  _lastPlayed: undefined,\n  textComments: [],\n  voiceRecordings: [],\n  feed: [],\n  userSettings: undefined,\n  trackMarkerMap: {},\n  playback: {\n    controlsEnabled: false,\n    spotifyApi: undefined,\n    isPlaying: false,\n    queuedUp: false,\n    noopNextTrack: false,\n    addToQueueTimeoutId: undefined,\n    isReady: false,\n    files: {},\n  },\n}\n\n\nfunction streamExpire(state, action) {\n  const stream = { ...state.stream },\n        _lastPlayed = stream.nowPlaying;\n\n  stream.isPlaying = false;\n  stream.isPaused = false;\n  stream.nowPlaying = undefined;\n\n  return { ...state, stream: stream, _lastPlayed: _lastPlayed };\n}\n\n\nfunction queueDeleteNode(state, action) {\n  const queues = state.nextUpQueues,\n        filteredQueues = queues.filter(i => i.uuid !== action.queueUuid);\n\n  return {\n    ...state,\n    nextUpQueues: filteredQueues,\n  }\n}\n\n\nfunction queueDeleteChildNode(state, action) {\n  let queues = [...state.nextUpQueues];\n  const parentIndex = queues.findIndex(i => i.uuid === action.parentUuid),\n        children = queues[parentIndex].children,\n        filteredChildren = children.filter(i => i.uuid !== action.queueUuid);\n\n  queues[parentIndex].children = filteredChildren;\n\n  if(!filteredChildren.length) {\n    queues = queues.filter(i => i.uuid !== action.parentUuid);\n  }\n\n  return {\n    ...state,\n    nextUpQueues: queues,\n  }\n}\n\n\nfunction textCommentClearModifications(state, action) {\n  const textCommentIndex = state.textComments.findIndex(t => t.uuid === action.textCommentUuid),\n        textComments = [...state.textComments];\n\n  textComments[textCommentIndex].modifications = [];\n\n  return {\n    ...state,\n    textComments: textComments,\n  }\n}\n\n\nfunction userGetSettings(state, action) {\n  return {\n    ...state,\n    userSettings: action.userSettings,\n  }\n}\n\n\nconst reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"stream/set\":\n      return streamSet(state, action.payload);\n    case \"stream/play\":\n      return streamPlay(state, action.payload);\n    case \"stream/pause\":\n      return streamPause(state, action.payload);\n    case \"stream/prevTrack\":\n      return streamPrevTrack(state, action.payload);\n    case \"stream/nextTrack\":\n      return streamNextTrack(state, action.payload);\n    case \"stream/expire\":\n      return streamExpire(state, action);\n    case \"queue/listSet\":\n      return queueListSet(state, action.payload);\n    case \"queue/deleteNode\":\n      return queueDeleteNode(state, action);\n    case \"queue/deleteChildNode\":\n      return queueDeleteChildNode(state, action);\n    case \"textComment/listSet\":\n      return textCommentListSet(state, action.payload);\n    case \"textComment/create\":\n      return textCommentCreate(state, action);\n    case \"textComment/delete\":\n      return textCommentDelete(state, action);\n    case \"textCommentModification/create\":\n      return textCommentModificationCreate(state, action.payload);\n    case \"textComment/clearModifications\":\n      return textCommentClearModifications(state, action);\n    case \"voiceRecording/create\":\n      return voiceRecordingCreate(state, action);\n    case \"voiceRecording/listSet\":\n      return voiceRecordingListSet(state, action.payload);\n    case \"voiceRecording/delete\":\n      return voiceRecordingDelete(state, action);\n    case \"user/get-settings\":\n      return userGetSettings(state, action);\n    case \"marker/create\":\n      return markerCreate(state, action.payload);\n    case \"marker/delete\":\n      return markerDelete(state, action.payload);\n    case \"marker/list\":\n      return markerList(state, action.payload);\n    case \"queueInterval/create\":\n      return queueIntervalCreate(state, action.payload);\n    case \"queueInterval/delete\":\n      return queueIntervalDelete(state, action.payload);\n    case \"playback/disable\":\n      return playbackDisable(state);\n    case \"playback/enable\":\n      return playbackEnable(state);\n    case \"playback/spotify\":\n      return playbackSpotify(state, action.payload);\n    case \"playback/addToQueue\":\n      return playbackAddToQueue(state);\n    case \"playback/plannedNextTrack\":\n      return playbackPlannedNextTrack(state, action.payload);\n    case \"playback/start\":\n      return playbackStart(state);\n    case \"playback/started\":\n      return playbackStarted(state);\n    case \"playback/addToQueueReschedule\":\n      return playbackAddToQueueReschedule(state);\n    case \"playback/addToQueueScheduled\":\n      return playbackAddToQueueScheduled(state, action.payload);\n    case \"playback/nextSeekScheduled\":\n      return playbackNextSeekScheduled(state, action.payload);\n    case \"playback/loadFiles\":\n      return playbackLoadFiles(state, action.payload);\n    case \"feed/update\":\n      return feedUpdate(state);\n    default:\n      return state;\n  }\n}\n\n\nexport const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__({ trace: true }));\n","import React, { useState } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport styles from './Login.module.css';\n\nimport { fetchAuthToken, fetchInitializeStream } from './network';\n\n\nfunction Login(props) {\n\n  /*\n   * \n   */\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [rememberMe, setRememberMe] = useState(false);\n\n  /*\n   * When the user initializes a login attempt.\n   */\n  const handleSubmit = async function(e) {\n    e.preventDefault();\n\n    const responseJson = await fetchAuthToken(username, password);\n    if(!responseJson.access || !responseJson.refresh) {\n      return;\n    }\n\n    localStorage.setItem('accessToken', responseJson.access);\n    localStorage.setItem('refreshToken', responseJson.refresh);\n\n    await fetchInitializeStream();\n\n    window.location.reload();\n  }\n\n  return (\n    <form className={styles.Login} onSubmit={async (e) => { await handleSubmit(e); }}>\n      <h3>Sign in</h3>\n      <p>If you have not created an account yet, then please <Link to=\"/signup\">Sign Up</Link> first.</p>\n\n      <label className={styles.FormBlock}>\n        Username\n        <input type=\"text\"\n               name=\"username\"\n               placeholder=\"username\"\n               value={username}\n               onChange={(e) => {setUsername(e.target.value)}} />\n      </label>\n\n      <label className={styles.FormBlock}>\n        Password\n        <input type=\"password\"\n               name=\"password\"\n               placeholder=\"password\"\n               value={password}\n               onChange={(e) => {setPassword(e.target.value)}} />\n      </label>\n\n      <label className={styles.FormBlock}>\n        <input type=\"checkbox\"\n               name=\"remember-me\"\n               value={rememberMe}\n               onChange={(e) => {setRememberMe(e.target.value)}} />\n        Remember Me\n      </label>\n\n      <div className={styles.FormBlock}>\n        <button type=\"submit\">\n          Sign In\n        </button>\n        <span><Link to=\"/forgotpassword\">Forgot Password?</Link></span>\n      </div>\n    </form>\n  );\n}\n\nexport default Login;\n","import { ENDPOINT_VOICE_RECORDING_CREATE, ENDPOINT_VOICE_RECORDING_DELETE } from '../../config/api'\nimport { TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n\n/*\n * Fetches...\n */\nexport const fetchCreateVoiceRecording = async (audioFile, transcriptData, transcriptFinal) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_VOICE_RECORDING_CREATE,\n    {\n      audioFile: audioFile,\n      transcriptData: transcriptData,\n      transcriptFinal: transcriptFinal,\n    },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches an auth token from the server.\n */\nexport const fetchDeleteVoiceRecording = async (voiceRecordingUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_VOICE_RECORDING_DELETE,\n    { voiceRecordingUuid: voiceRecordingUuid },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import {\n  ENDPOINT_TEXT_COMMENT_MODIFICATION_CREATE,\n} from '../../config/api'\nimport { TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n\n/*\n * Fetches...\n */\nexport const fetchCreateTextCommentModification = async (textCommentUuid, style, anchorOffset, focusOffset) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_TEXT_COMMENT_MODIFICATION_CREATE,\n    {\n      textCommentUuid: textCommentUuid,\n      style: style,\n      anchorOffset: anchorOffset,\n      focusOffset: focusOffset,\n    },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n\nexport const STYLE_BOLD = 'bold';\nexport const STYLE_ITALICIZE = 'italicize';\nexport const STYLE_STRIKETHROUGH = 'strikethrough';\n\nexport const STYLE_CHOICES = [\n  STYLE_BOLD,\n  STYLE_ITALICIZE,\n  STYLE_STRIKETHROUGH,\n];\n","import React, { useRef, useState } from \"react\";\nimport { connect } from 'react-redux';\nimport Popover from 'react-text-selection-popover';\nimport styles from './NotableText.module.css';\nimport {\n  fetchCreateTextCommentModification,\n  STYLE_BOLD,\n  STYLE_ITALICIZE,\n  STYLE_STRIKETHROUGH,\n  STYLE_CHOICES,\n} from './network';\n\n\nfunction NotableText(props) {\n\n  /*\n   * \n   */\n  const textColor = props.textColor;\n\n  const selectableRef = useRef(null);\n\n  const [selectableIsShowable, setSelectableIsShowable] = useState(true);\n  const [anchorOffset, setAnchorOffset] = useState(null);\n  const [focusOffset, setFocusOffset] = useState(null);\n\n  /*\n   * When the user highlights part of the comment.\n   */\n  const handleNotation = async function(style) {\n    const textCommentUuid = props.data.uuid;\n    const responseJson = await fetchCreateTextCommentModification(\n      textCommentUuid,\n      style,\n      anchorOffset,\n      focusOffset,\n    );\n    props.dispatch(responseJson.redux)\n    setSelectableIsShowable(false);\n  }\n\n  /*\n   * ...\n   */\n  const onTextSelect = async function() {\n    const selection = window.getSelection();\n\n    // Invalid text selection\n    if(selection.anchorNode !== selection.focusNode) {\n      setSelectableIsShowable(false);\n      setAnchorOffset(null);\n      setFocusOffset(null);\n      return;\n    }\n\n    // NOTE: anchor is where the user starts selecting text, focus is the end\n    //       of the selection.\n    const offset = parseInt(selection.anchorNode.parentNode.getAttribute('offset'));\n    setSelectableIsShowable(true);\n    setAnchorOffset(offset + selection.anchorOffset);\n    setFocusOffset(offset + selection.focusOffset);\n  }\n\n  /*\n   * ...\n   */\n  const onTextUnselect = async function() {\n    setSelectableIsShowable(false);\n    setAnchorOffset(null);\n    setFocusOffset(null);\n  }\n\n  /*\n   * When rendering a text comment, the text has to be displayed along with all\n   * of its annotations. Here the comment string is spliced into many\n   * substrings. If a substring has an accompanying modification, then Rough\n   * Notation is used to display the underline, strike-through, or highlight.\n   */\n  const renderTextComment = function() {\n    const textComment = props.data;\n    const textCommentText = textComment.text;\n    const modifications = textComment.modifications;\n\n    let startOffset = 0,\n        textCommentHtml = <></>;\n    for(let i = 0; i < modifications.length; i++) {\n        let modification = modifications[i];\n\n        const regSubString = textCommentText.substring(\n          startOffset,\n          modification.startPtr\n        )\n        const styledSubString = textCommentText.substring(\n          modification.startPtr,\n          modification.endPtr\n        )\n\n        // BUG: https://github.com/linkstrifer/react-rough-notation/issues/17\n        textCommentHtml = (\n          <>\n            {textCommentHtml}\n            <span offset={startOffset}>{regSubString}</span>\n            {modification.type === STYLE_BOLD &&\n              <b><span>{styledSubString}</span></b>\n            }\n            {modification.type === STYLE_ITALICIZE &&\n              <i><span>{styledSubString}</span></i>\n            }\n            {modification.type === STYLE_STRIKETHROUGH &&\n              <strike><span>{styledSubString}</span></strike>\n            }\n          </>\n        )\n\n        startOffset = modification.endPtr;\n    }\n\n    const regSubString = textCommentText.substring(\n      startOffset,\n      textCommentText.length\n    )\n\n    textCommentHtml = (\n      <>\n        {textCommentHtml}\n        <span offset={startOffset}>{regSubString}</span>\n      </>\n    )\n\n    return textCommentHtml;\n  }\n\n  /*\n   * \n   */\n  return (\n    <div className={styles.NotableText} style={{color: textColor}}>\n\n      <p ref={selectableRef}>\n        {renderTextComment()}\n      </p>\n      <Popover selectionRef={selectableRef} onTextSelect={onTextSelect} onTextUnselect={onTextUnselect} isOpen={selectableIsShowable}>\n        {STYLE_CHOICES.map((style, index) => {\n          return (\n            <button key={index}\n                    type=\"button\"\n                    onClick={async () => { await handleNotation(style); }}>\n              {style}\n            </button>\n          );\n        })}\n      </Popover>\n\n    </div>\n  );\n\n}\n\nconst mapStateToProps = (state) => ({\n    stream: state.stream,\n    textComments: state.textComments,\n    voiceRecordings: state.voiceRecordings,\n    feed: state.feed,\n});\n\nexport default connect(mapStateToProps)(NotableText);\n","import {\n  ENDPOINT_TEXT_COMMENT_DELETE,\n  ENDPOINT_TEXT_COMMENT_UPDATE,\n  ENDPOINT_TEXT_COMMENT_MODIFICATION_LIST_DELETE,\n} from '../../config/api'\nimport { TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n\n/*\n * Fetches...\n */\nexport const fetchDeleteTextComment = async (textCommentUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_TEXT_COMMENT_DELETE,\n    { textCommentUuid: textCommentUuid },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n\n/*\n * Fetches...\n */\nexport const fetchUpdateTextComment = async (textCommentUuid, text) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_TEXT_COMMENT_UPDATE,\n    { textCommentUuid: textCommentUuid, text: text },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n\n/*\n * Fetches...\n */\nexport const fetchListDeleteTextCommentModifications = async (textCommentUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_TEXT_COMMENT_MODIFICATION_LIST_DELETE,\n    { textCommentUuid: textCommentUuid },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import React from \"react\";\nimport { connect } from 'react-redux';\nimport NotableText from '../NotableText/NotableText';\nimport { Notation } from 'react-abc';\nimport styles from './TextComment.module.css';\nimport {\n  fetchDeleteTextComment,\n  fetchListDeleteTextCommentModifications,\n} from './network';\n\n\nfunction TextComment(props) {\n\n  const textComment = props.data,\n        textCommentUuid = textComment.uuid;\n\n  const deleteTextComment = async function() {\n    await fetchDeleteTextComment(textCommentUuid);\n    await props.dispatch({\n      type: 'textComment/delete',\n      textCommentUuid: textCommentUuid,\n    });\n  }\n\n  const clearModifications = async function() {\n    await fetchListDeleteTextCommentModifications(textCommentUuid);\n    await props.dispatch({\n      type: 'textComment/clearModifications',\n      textCommentUuid: textCommentUuid,\n    });\n  }\n\n  let textColor;\n  if(textComment.renderStatus === 'history') {\n    textColor = 'grey';\n  } else if(textComment.renderStatus === 'display') {\n    textColor = 'black';\n  } else {\n    textColor = 'red';\n  }\n\n  /*\n   * \n   */\n  return (\n    <div className={styles.TextComment}>\n\n      {textComment.format === 'text' ?\n        <NotableText data={textComment} textColor={textColor}></NotableText> :\n        <Notation notation={textComment.text} engraverParams={{ staffwidth: 278 }}/>\n      }\n\n      {textComment.format === 'text' &&\n        <button type=\"button\" onClick={clearModifications}>\n          Clear modifications\n        </button>\n      }\n\n      <button type=\"button\" onClick={deleteTextComment}>\n        Delete\n      </button>\n    </div>\n  );\n\n}\n\nconst mapStateToProps = (state) => ({});\n\nexport default connect(mapStateToProps)(TextComment);\n","import React from \"react\";\nimport { connect } from 'react-redux';\nimport styles from './VoiceRecording.module.css';\nimport { fetchDeleteVoiceRecording } from './network';\n\n\nfunction VoiceRecording(props) {\n\n  /*\n   * When the user deletes a text comment.\n   */\n  const handleDelete = async function(e) {\n    e.preventDefault();\n    const voiceRecordingUuid = props.data.uuid;\n    await fetchDeleteVoiceRecording(voiceRecordingUuid);\n    await props.dispatch({\n      type: 'voiceRecording/delete',\n      voiceRecordingUuid: voiceRecordingUuid,\n    });\n  }\n\n  /*\n   * \n   */\n  const voiceRecording = props.data;\n  return (\n    <div className={styles.VoiceRecording}>\n      <p><i>\n        {\n          voiceRecording.transcriptFinal === 'null' ?\n          '<transcript not available>' : voiceRecording.transcriptFinal\n        }\n      </i></p>\n      <form onSubmit={async (e) => { await handleDelete(e); }}>\n        <button type=\"submit\">\n          Delete\n        </button>\n      </form>\n    </div>\n  );\n\n}\n\nconst mapStateToProps = (state) => ({});\n\nexport default connect(mapStateToProps)(VoiceRecording);\n","import React, { useState, useEffect } from \"react\";\nimport { connect } from 'react-redux'\nimport SpeechRecognition, { useSpeechRecognition } from 'react-speech-recognition';\nimport MicRecorder from 'mic-recorder-to-mp3';\nimport styles from './Chat.module.css';\nimport { fetchTextCommentCreate } from './network';\nimport {\n  fetchCreateVoiceRecording,\n} from '../VoiceRecording/network';\nimport TextComment from '../TextComment/TextComment';\nimport VoiceRecording from '../VoiceRecording/VoiceRecording';\nimport {\n  CLASS_TEXT_COMMENT,\n  CLASS_VOICE_RECORDING\n} from '../../config/model';\nimport { getPositionMilliseconds } from '../../utils/reducers/feed';\n\n\nfunction Chat(props) {\n\n  /*\n   * \n   */\n  const feed = props.feed,\n        stream = props.stream;\n\n  const [text, setText] = useState('');\n  const [textCommentUuid, setTextCommentUuid] = useState(undefined);\n  const [textCommentTimestamp, setTextCommentTimestamp] = useState(undefined);\n  const [isAbc, setIsAbc] = useState('');\n  const [isRecording, setIsRecording] = useState(false);\n  const [recorder] = useState(new MicRecorder({ bitRate: 320 }));\n  const [transcriptData] = useState([]);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // REGENERATE THE FEED\n  useEffect(() => {\n\n    const periodicTask = setInterval(() => {\n      props.dispatch({ type: \"feed/update\" });\n    }, 250);\n\n    return () => {\n      clearInterval(periodicTask);\n    }\n\n  // eslint-disable-next-line\n  }, []);\n\n  const handleTextChange = function(e) {\n    if(!textCommentUuid) {\n      const arr = getPositionMilliseconds(stream),\n            position = arr[0];\n      setTextCommentTimestamp(position);\n      setTextCommentUuid(stream.nowPlaying.track.uuid);\n    }\n    setText(e.target.value);\n  }\n\n  /*\n   * When a user submits a new comment.\n   */\n  const createTextComment = async function(e) {\n    e.preventDefault();\n    const format = isAbc ? 'abc_notation' : 'text';\n    const responseJson = await fetchTextCommentCreate(\n      text, format, textCommentUuid, textCommentTimestamp\n    );\n\n    await props.dispatch({\n      type: 'textComment/create',\n      textComment: responseJson.data,\n    });\n\n    setTextCommentTimestamp(undefined);\n    setTextCommentUuid(undefined);\n    setText('');\n  }\n\n  const { transcript, resetTranscript } = useSpeechRecognition();\n\n  /*\n   * ...\n   */\n  const handleRecord = function() {\n    if(!isRecording) {\n      if (SpeechRecognition.browserSupportsSpeechRecognition()) {\n        SpeechRecognition.startListening({ continuous: true });\n        // BUG: https://github.com/JamesBrill/react-speech-recognition/issues/81\n        //\n        // const recognition = SpeechRecognition.getRecognition();\n        // recognition.onresult = (e) => {\n        //   recognition.onresult(e);\n        //   const timeStamp = e.timeStamp,\n        //         transcript = e.results[0][0].transcript,\n        //         confidence = e.results[0][0].confidence,\n        //         isFinal = e.results[0].isFinal;\n        //   transcriptData.push({ timeStamp, transcript, confidence, isFinal });\n        //   setTranscriptData([...transcriptData]);\n        // }\n      }\n      recorder.start();\n      setIsRecording(true);\n    } else {\n      if (SpeechRecognition.browserSupportsSpeechRecognition()) {\n        SpeechRecognition.stopListening();\n      }\n\n      recorder.stop()\n        .getMp3().then(([buffer, blob]) => {\n          (async function () {\n            const file = new File(buffer, 'voice.mp3', {\n              type: blob.type,\n              lastModified: Date.now(),\n            });\n\n            const responseJson = await fetchCreateVoiceRecording(file, JSON.stringify(transcriptData), transcript);\n\n            await props.dispatch({\n              type: 'voiceRecording/create',\n              voiceRecording: responseJson.data,\n            });\n\n            if (SpeechRecognition.browserSupportsSpeechRecognition()) {\n              resetTranscript();\n            }\n          })()\n        });\n\n      setIsRecording(false);\n    }\n  }\n\n  /*\n   * \n   */\n  return (\n    <div className={styles.Chat}>\n      <div>\n        {feed.map((value, index) => {\n          if(value.class === CLASS_TEXT_COMMENT) {\n            return <TextComment key={index} data={value} />\n          } else if(value.class === CLASS_VOICE_RECORDING) {\n            return <VoiceRecording key={index} data={value} />\n          } else {\n            return <></>;\n          }\n        })}\n      </div>\n\n      <form className={styles.CreateTextComment} onSubmit={async (e) => { await createTextComment(e); }}>\n        <input type=\"checkbox\"\n               value={isAbc}\n               onChange={(e) => { setIsAbc(e.target.checked); }} />\n        <button type=\"button\"\n                onClick={handleRecord}\n                disabled={!stream.isPlaying} >\n          Record\n        </button>\n        {isAbc ? (\n          <textarea type=\"text\"\n                    name=\"text\"\n                    placeholder=\"text\"\n                    value={text}\n                    onChange={handleTextChange}\n                    disabled={!stream.isPlaying} />\n        ) : (\n          <input type=\"text\"\n                 name=\"text\"\n                 placeholder=\"text\"\n                 value={text}\n                 onChange={handleTextChange}\n                 disabled={!stream.isPlaying} />\n        )}\n        <button type=\"submit\"\n                disabled={!stream.isPlaying} >\n          Send\n        </button>\n      </form>\n\n      <div>\n      </div>\n    </div>\n  );\n\n}\n\nconst mapStateToProps = (state) => ({\n    stream: state.stream,\n    textComments: state.textComments,\n    voiceRecordings: state.voiceRecordings,\n    feed: state.feed,\n});\n\nexport default connect(mapStateToProps)(Chat);\n","const CLASS_TEXT_COMMENT = 'TextComment'\nconst CLASS_VOICE_RECORDING = 'VoiceRecording'\n\nexport { CLASS_TEXT_COMMENT, CLASS_VOICE_RECORDING }\n","import {\n  ENDPOINT_MARKER_CREATE,\n  ENDPOINT_MARKER_DELETE,\n  ENDPOINT_MARKER_LIST,\n} from '../../config/api';\nimport { TYPE_GET, TYPE_POST } from '../../config/global';\nimport { fetchBackend } from '../../utils/network';\n\n\n/*\n * Creates a marker. The queue context is passed so the Redux state may be\n * updated.\n */\nexport const fetchStreamMarkerCreate = async (trackUuid, timestampMilliseconds, queueUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_MARKER_CREATE,\n    { trackUuid, timestampMilliseconds, queueUuid }\n  );\n  return await response.json();\n};\n\n\n/*\n * Deletes a marker. The queue context is passed so the Redux state may be\n * updated.\n */\nexport const fetchStreamMarkerDelete = async (markerUuid, queueUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_MARKER_DELETE,\n    { markerUuid, queueUuid }\n  );\n  return await response.json();\n};\n\n/*\n * Fetches a list of markers for a given track. The queue context is passed so\n * the Redux state may be updated.\n */\nexport const fetchStreamMarkerList = async (trackUuid, queueUuid) => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_MARKER_LIST,\n    { trackUuid, queueUuid }\n  );\n  return await response.json();\n};\n","import {\n  ENDPOINT_QUEUE_INTERVAL_CREATE,\n  ENDPOINT_QUEUE_INTERVAL_DELETE,\n} from '../../config/api';\nimport { TYPE_POST } from '../../config/global';\nimport { fetchBackend } from '../../utils/network';\n\n/*\n * Fetches...\n */\nexport const fetchStreamQueueIntervalCreate = async (queueUuid, lowerBoundMarkerUuid, upperBoundMarkerUuid, isMuted, repeatCount, parentQueueUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_QUEUE_INTERVAL_CREATE,\n    { queueUuid, lowerBoundMarkerUuid, upperBoundMarkerUuid, isMuted, repeatCount, parentQueueUuid }\n  );\n  return await response.json();\n};\n\n\n/*\n * Fetches...\n */\nexport const fetchStreamQueueIntervalDelete = async (queueIntervalUuid, queueUuid, parentQueueUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_QUEUE_INTERVAL_DELETE,\n    { queueIntervalUuid, queueUuid, parentQueueUuid }\n  );\n  return await response.json();\n};\n","import React from \"react\";\nimport { connect } from 'react-redux';\nimport { fetchStreamMarkerDelete } from './network';\n\n\nfunction TrackMarker(props) {\n\n  const { trackMarker, queueUuid } = props.data;\n\n  const deleteTrackMarker = async function() {\n    const responseJson = await fetchStreamMarkerDelete(\n      trackMarker.uuid, queueUuid\n    );\n    await props.dispatch(responseJson.redux);\n  }\n\n  return (\n    <div>\n      <span>\n        @ {trackMarker.timestampMilliseconds / 1000}\n      </span>\n      <button onClick={deleteTrackMarker}>Delete</button>\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({});\n\nexport default connect(mapStateToProps)(TrackMarker);\n","import React from \"react\";\nimport { connect } from 'react-redux';\nimport { fetchStreamQueueIntervalDelete } from './network';\n\n\nfunction QueueInterval(props) {\n\n  const { queueInterval, queueUuid, parentQueueUuid } = props.data;\n\n  const deleteQueueInterval = async function() {\n    const responseJson = await fetchStreamQueueIntervalDelete(\n      queueInterval.uuid, queueUuid, parentQueueUuid\n    );\n    await props.dispatch(responseJson.redux);\n  }\n\n  const lowerBound = queueInterval.lowerBound ?\n    queueInterval.lowerBound.timestampMilliseconds / 1000 : 'beginning';\n  const upperBound = queueInterval.upperBound ?\n    queueInterval.upperBound.timestampMilliseconds / 1000 : 'end';\n\n  return (\n    <div>\n      <span>\n        {lowerBound} =>\n        {upperBound}\n        ({queueInterval.isMuted ? 'muted' : 'played'})\n      </span>\n      <button onClick={deleteQueueInterval}>Delete</button>\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({});\n\nexport default connect(mapStateToProps)(QueueInterval);\n","import React, { useState, useEffect } from \"react\";\nimport { connect } from 'react-redux';\nimport {\n  fetchStreamMarkerCreate,\n  fetchStreamMarkerList,\n} from '../TrackMarker/network';\nimport {\n  fetchStreamQueueIntervalCreate,\n} from '../QueueInterval/network';\nimport TrackMarker from '../TrackMarker/TrackMarker'\nimport QueueInterval from '../QueueInterval/QueueInterval'\n\n\nfunction QueueEdit(props) {\n\n  const queue = props.data,\n        queueUuid = queue.uuid,\n        parentQueueUuid = queue.parentUuid,\n        trackMarkerMap = props.trackMarkerMap;\n\n  const markers = trackMarkerMap[queueUuid] || [];\n\n  const [formMarkerTimestamp, setFormMarkerTimestamp] = useState('');\n  const [lowerBoundMarkerUuid, setLowerBoundMarkerUuid] = useState('null');\n  const [upperBoundMarkerUuid, setUpperBoundMarkerUuid] = useState('null');\n\n  useEffect(() => {\n    async function loadData() {\n      const responseJson = await fetchStreamMarkerList(\n        queue.track.uuid, queueUuid\n      );\n      await props.dispatch(responseJson.redux);\n    }\n    loadData();\n  // eslint-disable-next-line\n  }, [])\n\n  const createTrackMarker = async function() {\n    const responseJson = await fetchStreamMarkerCreate(\n      queue.track.uuid, formMarkerTimestamp, queueUuid\n    );\n    await props.dispatch(responseJson.redux);\n    setFormMarkerTimestamp('');\n  }\n\n  const createQueueInterval = async function() {\n    const responseJson = await fetchStreamQueueIntervalCreate(\n      queue.uuid,\n      lowerBoundMarkerUuid,\n      upperBoundMarkerUuid,\n      true,\n      null,\n      parentQueueUuid,\n    );\n    await props.dispatch(responseJson.redux);\n  }\n\n  return (\n    <div>\n      <p>Markers</p>\n      {markers.map((value, index) => (\n        <TrackMarker key={index}\n                     data={{\n                       trackMarker: value,\n                       queueUuid: queueUuid,\n                     }} />\n      ))}\n      <div>\n        <input type=\"text\"\n               name=\"timestampMilliseconds\"\n               placeholder=\"timestamp\"\n               value={formMarkerTimestamp}\n               onChange={(e) => {setFormMarkerTimestamp(e.target.value)}} />\n        <button onClick={createTrackMarker}>Create Marker</button>\n      </div>\n      <p>Intervals</p>\n      {queue.intervals.map((value, index) => (\n        <QueueInterval key={index}\n                       data={{\n                         queueInterval: value,\n                         queueUuid: queueUuid,\n                         parentQueueUuid: parentQueueUuid,\n                       }} />\n      ))}\n      <div>\n        <select value={lowerBoundMarkerUuid} onChange={(e) => {setLowerBoundMarkerUuid(e.target.value)}}>\n          <option value={'null'}>Beginning</option>\n          {markers.map((value, index) => (\n            <option key={index} value={value.uuid}>@ {value.timestampMilliseconds}</option>\n          ))}\n        </select>\n        <select value={upperBoundMarkerUuid} onChange={(e) => {setUpperBoundMarkerUuid(e.target.value)}}>\n          {markers.map((value, index) => (\n            <option key={index} value={value.uuid}>@ {value.timestampMilliseconds}</option>\n          ))}\n          <option value={'null'}>End</option>\n        </select>\n        <button onClick={createQueueInterval}>Mute Interval</button>\n      </div>\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n  trackMarkerMap: state.trackMarkerMap,\n  nextUpQueues: state.nextUpQueues,\n});\n\nexport default connect(mapStateToProps)(QueueEdit);\n","import React, { useState } from \"react\";\nimport { connect } from 'react-redux'\nimport QueueEdit from '../QueueEdit/QueueEdit'\nimport styles from './QueueTrack.module.css';\n\n\nfunction QueueTrack(props) {\n\n  /*\n   * \n   */\n  const queue = props.data,\n        stream = props.stream,\n        lastUp = props.lastUp;\n\n  const [showEditing, setShowEditing] = useState(false);\n\n  const edit = async function(e) {\n    setShowEditing(true);\n  }\n\n  const save = async function(e) {\n    setShowEditing(false);\n  }\n\n  /*\n   * \n   */\n  const currentIndex = stream?.nowPlaying?.index || lastUp?.index;\n  const isNextUp = !currentIndex || currentIndex < queue.index;\n  const indent = queue.parentUuid && isNextUp ? '-' : '';\n  return (\n    <div className={styles.QueueTrack}>\n      <span>\n        {indent}\n        {queue.track.name}\n      </span>\n      {isNextUp &&\n        <>\n          <button className={styles.Button} type=\"button\" onClick={async (e) => { await props.destroy(queue); }}>\n            Delete\n          </button>\n          {!showEditing &&\n            <button className={styles.Button} type=\"button\" onClick={edit}>\n              Edit\n            </button>\n          }\n          {showEditing &&\n            <button className={styles.Button} type=\"button\" onClick={save}>\n              Done\n            </button>\n          }\n        </>\n      }\n      {showEditing &&\n        <QueueEdit data={queue}/>\n      }\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n  stream: state.stream,\n  lastUp: state.lastUp,\n});\n\nexport default connect(mapStateToProps)(QueueTrack);\n","import React, { useState } from \"react\";\nimport { connect } from 'react-redux'\nimport styles from './QueueCollection.module.css';\nimport QueueTrack from '../QueueTrack/QueueTrack'\n\n\nfunction QueueCollection(props) {\n\n  /*\n   * \n   */\n  const queue = props.data,\n        stream = props.stream,\n        lastUpQueues = props.lastUpQueues,\n        lastUp = lastUpQueues[lastUpQueues.length - 1],\n        queueUuid = props.data.uuid;\n\n  const isCurrentlyPlayingCollection = (\n    // Stream is NOW playing - \"now playing\" belongs to same parent UUID\n    (stream?.isPlaying && stream?.nowPlaying?.parentUuid === queueUuid) ||\n    // Stream is NOT playing - \"last up\" belongs to same parent UUID\n    (!stream?.isPlaying && lastUp?.parentUuid && lastUp?.parentUuid === queueUuid)\n  );\n\n\n  const [reveal, setReveal] = useState(isCurrentlyPlayingCollection);\n\n  /*\n   * When...\n   */\n  const toggleReveal = function(e) {\n    setReveal(!reveal);\n  }\n\n  /*\n   * \n   */\n  return (\n    <div className={styles.QueueCollection}>\n      <div className={styles.Item}>\n        <span>\n          {queue.collection.name}\n        </span>\n        {!isCurrentlyPlayingCollection &&\n          <button className={styles.Button} type=\"button\" onClick={async (e) => { await props.destroy(queue); }}>\n            Delete\n          </button>\n        }\n        {queue.children.length > 0 && !reveal &&\n          <button className={styles.Button} type=\"button\" onClick={toggleReveal}>\n            More\n          </button>\n        }\n        {queue.children.length > 0 && reveal &&\n          <button className={styles.Button} type=\"button\" onClick={toggleReveal}>\n            Less\n          </button>\n        }\n      </div>\n      {queue.children.length > 0 && reveal &&\n        <div className={styles.Children}>\n          {queue.children.map((value, index) => (\n            <QueueTrack key={index}\n                        data={value}\n                        destroy={props.destroy}>\n            </QueueTrack>\n          ))}\n        </div>\n      }\n    </div>\n  );\n\n}\n\nconst mapStateToProps = (state) => ({\n  stream: state.stream,\n  lastUpQueues: state.lastUpQueues,\n});\n\nexport default connect(mapStateToProps)(QueueCollection);\n","import { connect } from 'react-redux'\nimport styles from './Queue.module.css';\nimport { fetchDeleteQueue } from './network'\nimport QueueCollection from '../QueueCollection/QueueCollection'\nimport QueueTrack from '../QueueTrack/QueueTrack'\n\n\nfunction Queue(props) {\n\n  /*\n   * Called inside a child component, this first deletes the queue from the\n   * backend, then, on success, it deletes it from the front-end model and\n   * view.\n   */\n  const destroyQueueItem = async function(queue) {\n    const queueUuid = queue.uuid;\n\n    await fetchDeleteQueue(queueUuid);\n\n    const parentUuid = queue.parentUuid;\n    if(parentUuid) {\n      props.dispatch({\n        type: 'queue/deleteChildNode',\n        parentUuid: parentUuid,\n        queueUuid: queueUuid,\n      });\n    } else {\n      props.dispatch({\n        type: 'queue/deleteNode',\n        queueUuid: queueUuid,\n      });\n    }\n  }\n\n  /*\n   * \n   */\n  return (\n    <div className={styles.Queue}>\n      <p><i>Last up...</i></p>\n      <div>\n        {props.lastUpQueues.map((value, index) => {\n          if(value.track) {\n            return (\n              <QueueTrack key={index}\n                          data={value}\n                          destroy={() => {}}>\n              </QueueTrack>\n            );\n          } else {\n            return <></>;\n          }\n        })}\n      </div>\n      <div>\n        <p><i>Now playing...</i></p>\n        <p>{props.stream?.nowPlaying?.track.name}</p>\n      </div>\n      <p><i>Next up...</i></p>\n      <div>\n        {props.nextUpQueues.map((value, index) => {\n          if(value.collection) {\n            return (\n              <QueueCollection key={value.uuid}\n                               data={value}\n                               destroy={destroyQueueItem}>\n              </QueueCollection>\n            );\n          } else if(value.track) {\n            return (\n              <QueueTrack key={value.uuid}\n                          data={value}\n                          destroy={destroyQueueItem}>\n              </QueueTrack>\n            );\n          } else {\n            return <></>;\n          }\n        })}\n      </div>\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n  stream: state.stream,\n  nextUpQueues: state.nextUpQueues,\n  lastUpQueues: state.lastUpQueues,\n});\n\nexport default connect(mapStateToProps)(Queue);\n","import { ENDPOINT_MUSIC_SEARCH, ENDPOINT_QUEUE_CREATE } from '../../config/api'\nimport { TYPE_GET, TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n/*\n * Fetches an auth token from the server.\n */\nexport const fetchSearchMusicLibrary = async (query, providerSpotify, providerYouTube, providerJukeboxRadio, formatTrack, formatAlbum, formatPlaylist, formatVideo) => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_MUSIC_SEARCH,\n    {\n      query,\n      providerSpotify,\n      providerYouTube,\n      providerJukeboxRadio,\n      formatTrack,\n      formatAlbum,\n      formatPlaylist,\n      formatVideo,\n    },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n\n/*\n * Fetches an auth token from the server.\n */\nexport const fetchCreateQueue = async (className, genericUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_QUEUE_CREATE,\n    { className, genericUuid },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import React from 'react';\n\n\nfunction SearchResult(props) {\n  const searchResult = props.data;\n  return (\n    <div>\n      <span>\n        {searchResult.provider} {searchResult.format} {searchResult.name}\n      </span>\n      <button type=\"button\" onClick={async (e) => { await props.addToQueue(props.data.class, props.data.uuid); }}>\n        Add\n      </button>\n    </div>\n  );\n}\n\nexport default SearchResult;\n","import React, { useState } from \"react\";\nimport { connect } from 'react-redux';\nimport styles from './Search.module.css';\n\nimport { fetchSearchMusicLibrary, fetchCreateQueue } from './network';\nimport SearchResult from '../SearchResult/SearchResult';\nimport { fetchQueueList } from '../Queue/network';\n\n\nfunction Search(props) {\n\n  /*\n   * \n   */\n\n  const [searchResults, setSearchResults] = useState([]);\n\n  const [query, setQuery] = useState([]);\n\n  // NOTE: These could be condensed, but I prefer explicitly writing them out.\n  const [serviceSpotify, setServiceSpotify] = useState(true);\n  const [serviceYouTube, setServiceYouTube] = useState(true);\n  const [serviceJukeboxRadio, setServiceJukeboxRadio] = useState(true);\n\n  const [formatTrack, setFormatTrack] = useState(true);\n  const [formatAlbum, setFormatAlbum] = useState(true);\n  const [formatPlaylist, setFormatPlaylist] = useState(true);\n  const [formatVideo, setFormatVideo] = useState(true);\n\n  /*\n   * When the user initializes a login attempt.\n   */\n  const handleSubmit = async function(e) {\n    e.preventDefault();\n    const responseJson = await fetchSearchMusicLibrary(\n      query,\n      serviceSpotify,\n      serviceYouTube,\n      serviceJukeboxRadio,\n      formatTrack,\n      formatAlbum,\n      formatPlaylist,\n      formatVideo,\n    );\n    setSearchResults(responseJson.data);\n  }\n\n  /*\n   * When...\n   */\n  const addToQueue = async function(className, genericUuid) {\n    await fetchCreateQueue(\n      className,\n      genericUuid,\n    );\n\n    setSearchResults([]);\n\n    const responseJsonQueueList = await fetchQueueList();\n    await props.dispatch(responseJsonQueueList.redux);\n  }\n\n  return (\n    <div>\n      <form className={styles.Login} onSubmit={async (e) => { await handleSubmit(e); }}>\n        <h3>Search</h3>\n\n        <label className={styles.FormBlock}>\n          Query &nbsp;\n          <input type=\"text\"\n                 name=\"query\"\n                 placeholder=\"\"\n                 value={query}\n                 onChange={(e) => {setQuery(e.target.value)}} />\n        </label>\n\n        <br></br>\n\n        <div className={styles.FormBlock}>\n          <label>\n            <input type=\"checkbox\"\n                   checked={serviceSpotify}\n                   onChange={(e) => {setServiceSpotify(e.target.checked)}} />\n            Spotify\n          </label>\n\n          <label>\n            <input type=\"checkbox\"\n                   name=\"provider.youTube\"\n                   checked={serviceYouTube}\n                   onChange={(e) => {setServiceYouTube(e.target.checked)}} />\n            YouTube\n          </label>\n\n          <label>\n            <input type=\"checkbox\"\n                   name=\"provider.jukeboxRadio\"\n                   checked={serviceJukeboxRadio}\n                   onChange={(e) => {setServiceJukeboxRadio(e.target.checked)}} />\n            Jukebox Radio\n          </label>\n        </div>\n\n        <div className={styles.FormBlock}>\n          <label>\n            <input type=\"checkbox\"\n                   checked={formatTrack}\n                   onChange={(e) => {setFormatTrack(e.target.checked)}} />\n            Track\n          </label>\n\n          <label>\n            <input type=\"checkbox\"\n                   checked={formatAlbum}\n                   onChange={(e) => {setFormatAlbum(e.target.checked)}} />\n            Album\n          </label>\n\n          <label>\n            <input type=\"checkbox\"\n                   checked={formatPlaylist}\n                   onChange={(e) => {setFormatPlaylist(e.target.checked)}} />\n            Playlist\n          </label>\n\n          <label>\n            <input type=\"checkbox\"\n                   checked={formatVideo}\n                   onChange={(e) => {setFormatVideo(e.target.checked)}} />\n            Video\n          </label>\n        </div>\n\n        <br></br>\n\n        <div className={styles.FormBlock}>\n          <button type=\"submit\">\n            Search\n          </button>\n        </div>\n      </form>\n\n      <br></br>\n\n      <div>\n        {searchResults.map((value, index) => (\n          <SearchResult key={index} data={value} addToQueue={addToQueue}></SearchResult>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({});\n\nexport default connect(mapStateToProps)(Search);\n","import { ENDPOINT_USER_CONNECT_SPOTIFY } from '../../config/api';\nimport { TYPE_POST } from '../../config/global';\nimport { fetchBackend } from '../../utils/network';\n\n/*\n * Fetches an auth token from the server.\n */\nexport const fetchUserConnectSpotify = async (code, error) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_USER_CONNECT_SPOTIFY,\n    { code, error },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import React, { useEffect } from \"react\";\n// import styles from './SpotifySync.module.css';\n\nimport { fetchUserConnectSpotify } from './network';\n\n\nfunction SpotifySync(props) {\n\n  useEffect(() => {\n    async function postData() {\n      const queryString = window.location.search,\n            urlParams = new URLSearchParams(queryString),\n            code = urlParams.get('code'),\n            error = urlParams.get('error');\n\n      await fetchUserConnectSpotify(code, error);\n\n      window.location.href = '../search?service=spotify'\n    }\n    postData();\n  }, []);\n\n  return (\n    <p>Redirecting...</p>\n  );\n}\n\nexport default SpotifySync;\n","import { ENDPOINT_TRACK_CREATE } from '../../config/api'\nimport { TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n/*\n * Fetches...\n */\nexport const fetchCreateTrack = async (audioFile, imageFile, trackName, artistName, albumName) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_TRACK_CREATE,\n    {\n      audioFile: audioFile,\n      imageFile: imageFile,\n      trackName: trackName,\n      artistName: artistName,\n      albumName: albumName,\n    },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import React, { useState } from \"react\";\nimport styles from './Upload.module.css';\n\nimport { fetchCreateTrack } from './network';\n\n\nfunction Upload(props) {\n\n  /*\n   * \n   */\n  const [audioFile, setAudioFile] = useState('');\n  const [imageFile, setImageFile] = useState('');\n  const [trackName, setTrackName] = useState('');\n  const [artistName, setArtistName] = useState('');\n  const [albumName, setAlbumName] = useState('');\n\n  /*\n   * When the user initializes a login attempt.\n   */\n  const handleSubmit = async function(e) {\n    e.preventDefault();\n    await fetchCreateTrack(\n      audioFile,\n      imageFile,\n      trackName,\n      artistName,\n      albumName,\n    );\n    setTrackName('');\n    setArtistName('');\n    setAlbumName('');\n  }\n\n  return (\n    <form className={styles.Login} onSubmit={async (e) => { await handleSubmit(e); }}>\n      <h3>Upload</h3>\n\n      <label className={styles.FormBlock}>\n        Audio file\n        <input type=\"file\"\n               name=\"audioFile\"\n               onChange={(e) => {setAudioFile(e.target.files[0])}} />\n      </label>\n\n      <label className={styles.FormBlock}>\n        Image file\n        <input type=\"file\"\n               name=\"imageFile\"\n               onChange={(e) => {setImageFile(e.target.files[0])}} />\n      </label>\n\n      <br></br>\n\n      <label className={styles.FormBlock}>\n        Track name\n        <input type=\"text\"\n               name=\"trackName\"\n               placeholder=\"Track name\"\n               value={trackName}\n               onChange={(e) => {setTrackName(e.target.value)}} />\n      </label>\n\n      <label className={styles.FormBlock}>\n        Artist name\n        <input type=\"text\"\n               name=\"artistName\"\n               placeholder=\"Artist name\"\n               value={artistName}\n               onChange={(e) => {setArtistName(e.target.value)}} />\n      </label>\n\n      <label className={styles.FormBlock}>\n        Album name\n        <input type=\"text\"\n               name=\"albumName\"\n               placeholder=\"Album name\"\n               value={albumName}\n               onChange={(e) => {setAlbumName(e.target.value)}} />\n      </label>\n\n      <br></br>\n\n      <div className={styles.FormBlock}>\n        <button type=\"submit\">\n          Submit\n        </button>\n      </div>\n    </form>\n  );\n}\n\nexport default Upload;\n","import { useState } from \"react\";\nimport { connect } from 'react-redux'\n// import { CountdownCircleTimer } from 'react-countdown-circle-timer'\nimport styles from './Player.module.css';\n\n\nfunction Player(props) {\n\n  /*\n   * \n   */\n  const stream = props.stream,\n        playback = props.playback,\n        track = stream?.nowPlaying?.track,\n        lastUpQueues = props.lastUpQueues,\n        lastUp = lastUpQueues[lastUpQueues.length - 1],\n        nextUpQueues = props.nextUpQueues,\n        nextUp = (\n          nextUpQueues.length ?\n            (nextUpQueues[0].children.length ?\n              nextUpQueues[0].children[0] :\n              nextUpQueues[0]) :\n            undefined\n        );\n\n  // NOTE: This is a temporary mechanism to allow the user to refresh the\n  //       progress value on the front-end.\n  // eslint-disable-next-line\n  const [counter, setCounter] = useState(0);\n\n  /*\n   * A function used to calculate time elapsed since the now playing track was\n   * started.\n   */\n  const getProgress = function() {\n    if(stream?.isPaused) {\n      return stream.pausedAt - stream.startedAt;\n    } else if(stream?.isPlaying) {\n      return Date.now() - stream.startedAt;\n    } else {\n      return undefined;\n    }\n  };\n\n  const handleRefreshProgress = function() {\n    setCounter(prev => prev + 1);\n  }\n\n  // BUG: Edge case needed to refresh the webpage. In the future, there should\n  //      be an API endpoint to fetch additional past queue items.\n  if(stream?.nowPlaying?.index !== 1 && !lastUp) {\n    window.location.reload();\n  }\n\n  return (\n    <>\n      <div className={styles.Div}>\n        <p><i>Last...</i></p>\n        <p>{lastUp?.track?.name}</p>\n      </div>\n\n      <div className={styles.Div}>\n        <p><i>Now playing...</i></p>\n        {(stream?.isPlaying || stream?.isPaused) &&\n          <p>{track?.name}</p>\n        }\n        {(!stream?.isPlaying && !stream?.isPaused) &&\n          <p>Waiting...</p>\n        }\n      </div>\n\n      <div className={styles.Div}>\n        <p><i>Next...</i></p>\n        <p>{nextUp?.track.name}</p>\n      </div>\n\n      <div className={styles.Div}>\n        {getProgress() || 'Waiting...'}\n      </div>\n\n      <div className={styles.Div}>\n        <button className={styles.Button}\n                onClick={props.prevTrack}\n                disabled={!playback.controlsEnabled}>\n          Prev\n        </button>\n        {stream?.isPaused &&\n          <button className={styles.Button}\n                  onClick={props.play}\n                  disabled={!playback.controlsEnabled}>\n            Play\n          </button>\n        }\n        {stream?.isPlaying &&\n          <button className={styles.Button}\n                  onClick={props.pause}\n                  disabled={!playback.controlsEnabled}>\n            Pause\n          </button>\n        }\n        <button className={styles.Button}\n                onClick={props.nextTrack}\n                disabled={!playback.controlsEnabled}>\n          Next\n        </button>\n      </div>\n      <div className={styles.Div}>\n        {(stream?.isPlaying) &&\n          <button className={styles.Button}\n                  onClick={() => { props.seek('backward'); }}\n                  disabled={!playback.controlsEnabled}>\n            Backward\n          </button>\n        }\n        {(stream?.isPlaying) &&\n          <button className={styles.Button}\n                  onClick={() => { props.seek('forward'); }}\n                  disabled={!playback.controlsEnabled}>\n            Forward\n          </button>\n        }\n        {(stream?.isPlaying) &&\n          <button className={styles.Button}\n                  onClick={handleRefreshProgress}\n                  disabled={!playback.controlsEnabled}>\n            Progress\n          </button>\n        }\n      </div>\n    </>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n    stream: state.stream,\n    lastUpQueues: state.lastUpQueues,\n    nextUpQueues: state.nextUpQueues,\n    playback: state.playback,\n});\n\nexport default connect(mapStateToProps)(Player);\n","import React from \"react\";\nimport { connect } from 'react-redux';\n\nfunction UserSettings(props) {\n  if (!props.userSettings) {\n    return <></>;\n  }\n\n  return (\n    <a href={props.userSettings.spotify.authorizationUrl}>Connect Your Spotify Account</a>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n  userSettings: state.userSettings,\n});\n\nexport default connect(mapStateToProps)(UserSettings);\n","import { useEffect, useState } from \"react\";\nimport { connect } from 'react-redux'\nimport { fetchTextCommentList, fetchVoiceRecordingList } from '../Chat/network';\nimport {\n  getPositionMilliseconds,\n  playbackStart,\n  playbackSeek,\n  playbackPause,\n  playbackPlay,\n} from './playback'\n// import styles from './PlaybackWrapper.module.css';\nimport {\n  Switch,\n  Route,\n} from \"react-router-dom\";\n\nimport Chat from '../Chat/Chat';\nimport Queue from '../Queue/Queue';\nimport Search from '../Search/Search';\nimport SpotifySync from '../SpotifySync/SpotifySync';\nimport Upload from '../Upload/Upload';\nimport Player from '../Player/Player';\nimport UserSettings from '../UserSettings/UserSettings';\nimport {\n  fetchNextTrack,\n  fetchPrevTrack,\n  fetchScanBackward,\n  fetchScanForward,\n  fetchTrackGetFiles,\n  fetchPauseTrack,\n  fetchPlayTrack,\n} from '../Player/network';\nimport { SERVICE_JUKEBOX_RADIO } from '../../config/services';\n\n\nfunction PlaybackWrapper(props) {\n\n  /*\n   * \n   */\n  const stream = props.stream,\n        playback = props.playback,\n        lastUpQueues = props.lastUpQueues,\n        lastUp = lastUpQueues[lastUpQueues.length - 1],\n        nextUpQueues = props.nextUpQueues,\n        nextUp = (\n                nextUpQueues.length ?\n                  (nextUpQueues[0].children.length ?\n                    nextUpQueues[0].children[0] :\n                    nextUpQueues[0]) :\n                  undefined\n              );\n\n  const [messageScheduleNextTrack, setMessageScheduleNextTrack] = useState(false);\n  const [plannedNextTrackTimeoutId, setPlannedNextTrackTimeoutId] = useState({});\n  const [nextTrackJson, setNextTrackJson] = useState({});\n\n  /*\n   * Load comments and voice recordings to update the feed.\n   */\n  const updateFeed = async function() {\n    const responseJsonTextCommentList = await fetchTextCommentList();\n    const responseJsonVoiceRecordingList = await fetchVoiceRecordingList();\n    await props.dispatch(responseJsonTextCommentList.redux);\n    await props.dispatch(responseJsonVoiceRecordingList.redux);\n  };\n\n  /*\n   * This starts the now playing track.\n   * Note: You can think of this as \"playing\" the track, but \"play\" in code\n   *       references different behavior. \"Play\" is used for toggling the\n   *       current track from a \"paused\" state to \"play.\"\n   */\n  const start = function() {\n    if(!stream.nowPlaying.track) {\n      return;\n    }\n    props.dispatch({ type: 'playback/started' });\n\n    playbackStart(playback, stream);\n  }\n\n  /*\n   * This adds the nextUp item in the queue to play next (add to queue). This\n   * happens ~5 seconds before the next item should play.\n   */\n  const addToQueue = async function() {\n\n    // disable the player UI\n    await props.dispatch({ type: 'playback/disable' });\n\n    // update the back-end\n    const responseJsonNextTrack = await fetchNextTrack(\n      stream.nowPlaying?.totalDurationMilliseconds, true\n    );\n\n    if(nextUp.track.service === SERVICE_JUKEBOX_RADIO) {\n      const responseJson = await fetchTrackGetFiles(nextUp.track.uuid);\n      await props.dispatch(responseJson.redux);\n    }\n\n    // update the front-end later\n    setNextTrackJson(responseJsonNextTrack);\n\n    // add to queue\n    await props.dispatch({ type: 'playback/addToQueue' });\n\n    // schedule \"next track\"\n    setMessageScheduleNextTrack(true);\n  }\n\n  /*\n   *  Triggered by a scheduled task, this plays the next track.\n   */\n  const plannedNextTrack = async function() {\n    if(stream.nowPlaying.track.service === SERVICE_JUKEBOX_RADIO) {\n      playbackPause(playback, stream);\n    }\n    await props.dispatch({\n      type: 'playback/plannedNextTrack',\n      payload: { payload: nextTrackJson.redux },  // yes\n    });\n    await props.dispatch({ type: 'playback/enable' });\n    await updateFeed();\n  }\n\n  /*\n   * Triggered by human interaction, this plays the previous track.\n   */\n  const prevTrack = async function() {\n    await props.dispatch({ type: 'playback/disable' });\n    if(stream.nowPlaying.track.service === SERVICE_JUKEBOX_RADIO) {\n      playbackPause(playback, stream);\n    }\n    if(lastUp.track.service === SERVICE_JUKEBOX_RADIO) {\n      const responseJson = await fetchTrackGetFiles(lastUp.track.uuid);\n      await props.dispatch(responseJson.redux);\n    }\n    const responseJsonPrevTrack = await fetchPrevTrack();\n    await props.dispatch(responseJsonPrevTrack.redux);\n    await props.dispatch({ type: 'playback/start' });\n    await props.dispatch({ type: 'playback/enable' });\n    await updateFeed();\n  }\n\n  /*\n   * Triggered by human interaction, this plays the next track.\n   */\n  const nextTrack = async function() {\n    await props.dispatch({ type: 'playback/disable' });\n    if(stream.nowPlaying.track.service === SERVICE_JUKEBOX_RADIO) {\n      playbackPause(playback, stream);\n    }\n    if(nextUp.track.service === SERVICE_JUKEBOX_RADIO) {\n      const responseJson = await fetchTrackGetFiles(nextUp.track.uuid);\n      await props.dispatch(responseJson.redux);\n    }\n    const responseJsonNextTrack = await fetchNextTrack(\n      stream.nowPlaying?.totalDurationMilliseconds, false\n    );\n    await props.dispatch(responseJsonNextTrack.redux);\n    await props.dispatch({ type: 'playback/start' });\n    await props.dispatch({ type: 'playback/enable' });\n    await updateFeed();\n  }\n\n  /*\n   * Seek to the expected position in the track. This may be called in 3 cases:\n   *   1: a user signals the track to scan forward 10 seconds.\n   *   2: a user signals the track to scan backward 10 seconds.\n   *   3: a seekTimeout event is triggered, meaning the now playing track must\n   *      seek to the new expected track progress (in the case of a muted\n   *      interval).\n   */\n  const seek = async function(direction = undefined) {\n    await props.dispatch({ type: 'playback/disable' });\n    let startedAt;\n\n    if(direction === 'forward') {\n      const response = await fetchScanForward(\n        stream.nowPlaying.totalDurationMilliseconds\n      );\n      // Seeking forward is not allowed because the track is almost over.\n      if(response.system.status === 400) {\n        await props.dispatch({ type: 'playback/enable' });\n        return;\n      }\n      startedAt = stream.startedAt - (10000);\n    } else if(direction === 'backward') {\n      await fetchScanBackward();\n      const date = new Date(),\n            epochNow = date.getTime(),\n            proposedStartedAt = stream.startedAt + 10000,\n            proposedProgress = epochNow - proposedStartedAt;\n      startedAt = proposedProgress > 0 ? proposedStartedAt : epochNow;\n    } else {\n      startedAt = stream.startedAt;\n    }\n\n    await props.dispatch({\n      type: 'stream/set',\n      payload: {stream: { ...stream, startedAt: startedAt }},\n    });\n\n    const arr = getPositionMilliseconds(stream, startedAt),\n          seekTimeoutDuration = arr[1];\n    playbackSeek(playback, stream, startedAt);\n    await props.dispatch({ type: 'playback/addToQueueReschedule' });\n\n    // schedule seek\n    if(seekTimeoutDuration) {\n      const seekTimeoutId = setTimeout(() => {\n        seek();\n      }, seekTimeoutDuration);\n      // setNextSeekTimeoutId(seekTimeoutId);\n      props.dispatch({\n        type: 'playback/nextSeekScheduled',\n        payload: { nextSeekTimeoutId: seekTimeoutId },\n      });\n    }\n\n    await props.dispatch({ type: 'playback/enable' });\n  }\n\n  /*\n   * Toggling the player from the \"playing\" to \"paused\" state.\n   */\n  const pause = async function() {\n    await props.dispatch({ type: 'playback/disable' });\n    const jsonResponse = await fetchPauseTrack();\n    await props.dispatch(jsonResponse.redux);\n    await props.dispatch({ type: 'playback/addToQueueReschedule' });\n    playbackPause(playback, stream);\n    clearTimeout(plannedNextTrackTimeoutId);\n    await props.dispatch({ type: 'playback/enable' });\n  }\n\n  /*\n   * Toggling the player from the \"paused\" to \"playing\" state.\n   */\n  const play = async function() {\n    await props.dispatch({ type: 'playback/disable' });\n    const jsonResponse = await fetchPlayTrack();\n    await props.dispatch(jsonResponse.redux);\n\n    // When page loads with the player in the \"paused\" state and then the user\n    // toggles to the \"playing\" state.\n    if(!playback.isPlaying) {\n      await props.dispatch({ type: 'playback/enable' });\n      return;\n    }\n\n    await props.dispatch({ type: 'playback/addToQueueReschedule' });\n    playbackPlay(playback, stream);\n    await props.dispatch({ type: 'playback/enable' });\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // SCHEDULE ADD TO QUEUE\n  // Happens near the end of the currently playing track.\n  useEffect(() => {\n\n    // debouncer\n    const needsToScheduleAddToQueue = (\n      stream.isPlaying &&\n      playback.isPlaying &&\n      !playback.addToQueueTimeoutId\n    );\n    if(!needsToScheduleAddToQueue) {\n      return;\n    }\n\n    if(!stream?.nowPlaying) {\n      return;\n    }\n\n    // schedule add to queue\n    const progress = Date.now() - stream.startedAt,\n          timeLeft = (\n            stream.nowPlaying.totalDurationMilliseconds - progress\n          ),\n          timeoutDuration = timeLeft - 5000;\n    const timeoutId = setTimeout(() => {\n      addToQueue();\n    }, timeoutDuration);\n    props.dispatch({\n      type: 'playback/addToQueueScheduled',\n      payload: { addToQueueTimeoutId: timeoutId },\n    });\n\n    // schedule seek\n    const arr = getPositionMilliseconds(stream, stream.startedAt),\n          seekTimeoutDuration = arr[1];\n    if(seekTimeoutDuration) {\n      const seekTimeoutId = setTimeout(() => {\n        seek();\n      }, seekTimeoutDuration);\n      // setNextSeekTimeoutId(seekTimeoutId);\n      props.dispatch({\n        type: 'playback/nextSeekScheduled',\n        payload: { nextSeekTimeoutId: seekTimeoutId },\n      });\n    }\n\n  // eslint-disable-next-line\n  }, [playback]);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // SCHEDULE PLANNED NEXT TRACK\n  // Happens at the very end of the currently playing track.\n  useEffect(() => {\n\n    // debouncer\n    if(!messageScheduleNextTrack) {\n      return;\n    }\n    setMessageScheduleNextTrack(false);\n\n    // schedule next track\n    const progress = Date.now() - stream.startedAt,\n          timeoutDuration = (\n            stream.nowPlaying.totalDurationMilliseconds - progress\n          );\n    const timeoutId = setTimeout(() => {\n      plannedNextTrack();\n    }, timeoutDuration);\n    clearTimeout(plannedNextTrackTimeoutId);\n    setPlannedNextTrackTimeoutId(timeoutId);\n\n  // eslint-disable-next-line\n  }, [messageScheduleNextTrack]);\n\n  // Play the music.\n  if(stream.isPlaying && !playback.isPlaying && playback.isReady) {\n    start();\n  }\n\n  return (\n    <>\n    <Switch>\n      <Route path=\"/settings\">\n        <UserSettings />\n      </Route>\n      <Route path=\"/chat\">\n        <Chat />\n      </Route>\n      <Route path=\"/player\">\n        <Player nextTrack={nextTrack}\n                prevTrack={prevTrack}\n                seek={seek}\n                pause={pause}\n                play={play} />\n      </Route>\n      <Route path=\"/queue\">\n        <Queue />\n      </Route>\n      <Route path=\"/search\">\n        <Search />\n      </Route>\n      <Route path=\"/upload\">\n        <Upload />\n      </Route>\n      <Route path=\"/spotify\">\n        <SpotifySync />\n      </Route>\n    </Switch>\n    </>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n    stream: state.stream,\n    playback: state.playback,\n    lastUpQueues: state.lastUpQueues,\n    nextUpQueues: state.nextUpQueues,\n});\n\nexport default connect(mapStateToProps)(PlaybackWrapper);\n","import './App.css';\nimport {\n  fetchTextCommentList,\n  fetchVoiceRecordingList,\n} from './components/Chat/network';\nimport { fetchVerifyToken } from './components/Login/network'\nimport {\n  fetchStreamGet,\n  fetchPauseTrack,\n  fetchTrackGetFiles,\n} from './components/Player/network';\nimport { fetchQueueList } from './components/Queue/network'\nimport { fetchGetUserSettings } from './components/UserSettings/network';\nimport { playbackPause } from './components/PlaybackWrapper/playback';\nimport { store } from './utils/redux'\nimport Login from './components/Login/Login';\nimport PlaybackWrapper from './components/PlaybackWrapper/PlaybackWrapper';\nimport { useEffect, useState } from \"react\";\nimport { Provider } from 'react-redux';\nimport {\n  BrowserRouter as Router,\n  Link\n} from \"react-router-dom\";\nimport { SERVICE_JUKEBOX_RADIO } from './config/services';\n\nconst SpotifyWebApi = require('spotify-web-api-js');\n\n\nfunction App() {\n\n  // keeps track of the status of the webpage\n  //  - initial: when the page is first loaded\n  //  - unauthenticated: the client does NOT have a valid access token\n  //  - authenticated: the client has a valid access token\n  //  - ready: all API data has been loaded\n  const [status, setStatus] = useState('initial');\n\n  // componentDidMount\n  useEffect(() => {\n    async function loadData() {\n      let responseJson;\n\n      // verify authentication\n      const authResponse = await fetchVerifyToken();\n        if (!authResponse) {\n          setStatus('unauthenticated');\n          return;\n        }\n\n      // set state\n      setStatus('authenticated');\n\n      // load stream\n      responseJson = await fetchStreamGet();\n      await store.dispatch(responseJson.redux);\n\n      const payload = responseJson.redux.payload,\n            nowPlayingTrack = payload.stream.nowPlaying?.track;\n      if(nowPlayingTrack?.service === SERVICE_JUKEBOX_RADIO) {\n        const trackUuid = nowPlayingTrack.uuid;\n        responseJson = await fetchTrackGetFiles(trackUuid);\n        await store.dispatch(responseJson.redux);\n        // var request = new XMLHttpRequest();\n        // request.open(\"GET\", responseJson.redux.payload.track.audioUrl, true);\n        // request.responseType = \"blob\";\n        // request.onload = () => {\n        //   if(this.status !== 200) {\n        //     return;\n        //   }\n        //   const audio = new Audio(URL.createObjectURL(this.response));\n        //   responseJson.redux.payload.track.audio = audio;\n        //   store.dispatch(responseJson.redux);\n        // }\n        // request.send();\n      }\n\n      // load queue\n      responseJson = await fetchQueueList();\n      await store.dispatch(responseJson.redux);\n\n      // load comments\n      const textCommentsJsonResponse = await fetchTextCommentList();\n      await store.dispatch(textCommentsJsonResponse.redux);\n\n      // load voice recordings\n      const voiceRecordingsJsonResponse = await fetchVoiceRecordingList();\n      await store.dispatch(voiceRecordingsJsonResponse.redux);\n\n      // get user settings\n      const userSettingsJsonResponse = await fetchGetUserSettings();\n      await store.dispatch({\n        type: 'user/get-settings',\n        userSettings: userSettingsJsonResponse.data,\n      });\n\n      // initialize Spotify player\n      const spotifyApi = new SpotifyWebApi();\n      spotifyApi.setAccessToken(userSettingsJsonResponse.data.spotify.accessToken);\n      await store.dispatch({\n        type: 'playback/spotify',\n        payload: { spotifyApi: spotifyApi },\n      });\n\n      // enable playback controls\n      await store.dispatch({ type: 'playback/enable' });\n\n      setStatus('ready');\n    }\n    loadData();\n\n    window.addEventListener(\"beforeunload\", (e) => {\n      e.preventDefault();\n      const state = store.getState();\n      if(!state.stream.isPlaying) {\n        return;\n      }\n      fetchPauseTrack();\n      playbackPause(state.playback, state.stream);\n    });\n  }, []);\n\n  // as the page is loading, display nothing\n  if(status === 'initial') {\n    return (\n      <Router>\n        <Provider store={store}>\n          <></>\n        </Provider>\n      </Router>\n    );\n  }\n\n  // if the user is not authenticated, only display the login portal\n  if(status === 'unauthenticated') {\n    return (\n      <Router>\n        <Provider store={store}>\n          <div className=\"app-main-container\">\n            <div className=\"app-main\">\n              <Login />\n            </div>\n          </div>\n        </Provider>\n      </Router>\n    )\n  }\n\n  // if the user is not authenticated, only display the login portal\n  if(status === 'authenticated') {\n    return (\n      <Router>\n        <Provider store={store}>\n          Loading...\n        </Provider>\n      </Router>\n    )\n  }\n\n  // display the main UI now that everything is loaded up\n  return (\n    <Router>\n      <Provider store={store}>\n\n        {/* nav bar */}\n        <nav>\n          <ul>\n            <li>\n              <Link to=\"/settings\">Settings</Link>\n            </li>\n            <li>\n              <Link to=\"/chat\">Chat</Link>\n            </li>\n            <li>\n              <Link to=\"/player\">Player</Link>\n            </li>\n            <li>\n              <Link to=\"/queue\">Queue</Link>\n            </li>\n            <li>\n              <Link to=\"/search\">Search</Link>\n            </li>\n            <li>\n              <Link to=\"/upload\">Upload</Link>\n            </li>\n          </ul>\n        </nav>\n\n        {/* main section */}\n        <div className=\"app-main-container\">\n          <div className=\"app-main\">\n            <PlaybackWrapper />\n          </div>\n        </div>\n\n      </Provider>\n    </Router>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Upload\":\"Upload_Upload__tMDig\",\"FormBlock\":\"Upload_FormBlock__2ls6S\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"QueueCollection\":\"QueueCollection_QueueCollection__3PH8C\",\"Item\":\"QueueCollection_Item__3Kg1p\",\"Button\":\"QueueCollection_Button__1j08c\",\"Children\":\"QueueCollection_Children__U1cJx\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Login\":\"Login_Login__1ujut\",\"FormBlock\":\"Login_FormBlock__S_rix\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Search\":\"Search_Search__2SQmI\",\"FormBlock\":\"Search_FormBlock__3ZZZJ\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"QueueTrack\":\"QueueTrack_QueueTrack__14e2x\",\"Button\":\"QueueTrack_Button__cfD-Y\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Chat\":\"Chat_Chat__3NjUX\",\"ChatItem\":\"Chat_ChatItem__9P8wv\",\"ChatBar\":\"Chat_ChatBar__1jd0C\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"NotableText\":\"NotableText_NotableText__1_8Yx\",\"Notated\":\"NotableText_Notated__1OpEa\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"TextComment\":\"TextComment_TextComment__15QHu\",\"Notated\":\"TextComment_Notated__24bZz\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"VoiceRecording\":\"VoiceRecording_VoiceRecording__10J4X\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Queue\":\"Queue_Queue__YTCBa\"};"],"sourceRoot":""}