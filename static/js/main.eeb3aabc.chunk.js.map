{"version":3,"sources":["components/Player/Player.module.css","components/Upload/Upload.module.css","components/QueueCollection/QueueCollection.module.css","components/Login/Login.module.css","components/Search/Search.module.css","components/QueueTrack/QueueTrack.module.css","components/Chat/Chat.module.css","components/TextComment/TextComment.module.css","components/VoiceRecording/VoiceRecording.module.css","components/Queue/Queue.module.css","config/global.js","utils/network.js","components/Chat/network.js","config/api.js","components/Login/network.js","components/Player/network.js","components/Queue/network.js","components/UserSettings/network.js","utils/reducers/marker.js","utils/reducers/player.js","utils/reducers/queue.js","utils/reducers/queueInterval.js","utils/reducers/stream.js","utils/reducers/textComment.js","utils/reducers/voiceRecording.js","utils/redux.js","components/Login/Login.js","components/TextComment/network.js","components/VoiceRecording/network.js","components/TextComment/TextComment.js","components/VoiceRecording/VoiceRecording.js","components/Chat/Chat.js","config/model.js","components/TrackMarker/network.js","components/QueueInterval/network.js","components/TrackMarker/TrackMarker.js","components/QueueInterval/QueueInterval.js","components/QueueEdit/QueueEdit.js","components/QueueTrack/QueueTrack.js","components/QueueCollection/QueueCollection.js","components/Queue/Queue.js","components/Search/network.js","components/SearchResult/SearchResult.js","components/Search/Search.js","components/Upload/network.js","components/Upload/Upload.js","components/Player/Player.js","components/UserSettings/UserSettings.js","components/PlaybackWrapper/PlaybackWrapper.js","App.js","reportWebVitals.js","index.js"],"names":["module","exports","BACKEND_DOMAIN","process","TYPE_GET","TYPE_POST","fetchBackend","a","method","url","data","formData","FormData","Object","entries","key","value","append","requestOptions","headers","token","localStorage","getItem","Authorization","request","Request","fetch","mode","body","response","searchParams","URLSearchParams","set","getUrl","toString","fetchTextCommentCreate","text","json","responseJson","fetchTextCommentList","fetchVoiceRecordingList","fetchAuthToken","username","password","fetchInitializeStream","fetchVerifyToken","status","undefined","fetchStreamGet","fetchNextTrack","fetchPauseTrack","fetchPlayTrack","fetchPrevTrack","fetchScanBackward","fetchScanForward","fetchQueueList","fetchDeleteQueue","queueUuid","fetchGetUserSettings","markerCreate","state","action","trackMarkerMap","marker","sortedMarkers","sort","b","timestampMilliseconds","markerDelete","filteredMarkers","filter","m","uuid","markerList","markers","playerSpotify","payload","spotifyApi","finalizeQueue","queue","copy","children","length","editedChildren","map","totalDurationMilliseconds","reduce","total","q","durationMilliseconds","intervals","trackDurationMilliseconds","track","playbackIntervals","lowerBound","upperBound","interval","push","i","queueListSet","lastUpQueues","nextUpQueues","_lastPlayed","stream","isPlaying","isPaused","nowPlaying","lastUp","nextUp","findByUuid","o","sortQueueIntervals","queueIntervalCreate","parentIndex","index","queueInterval","parentQueueUuid","queues","findIndex","trackQueue","sortedQueueIntervals","finalizedNextUpQueues","queueIntervalDelete","filteredQueueIntervals","streamSet","obj","streamPlay","updatedPayload","startedAt","streamPause","pausedAt","streamPrevTrack","lastNowPlaying","nextUpQueue","nextNowPlaying","isTrackInCollection","parentUuid","unshift","pop","streamNextTrack","shift","textCommentListSet","textComments","feed","voiceRecordings","voiceRecordingListSet","initialState","userSettings","streamExpire","queueDeleteNode","filteredQueues","queueDeleteChildNode","filteredChildren","textCommentCreate","textComment","textCommentDelete","textCommentUuid","voiceRecordingCreate","voiceRecording","voiceRecordingDelete","voiceRecordingUuid","userGetSettings","store","createStore","type","window","__REDUX_DEVTOOLS_EXTENSION__","Login","props","useState","setUsername","setPassword","rememberMe","setRememberMe","handleSubmit","e","preventDefault","access","refresh","setItem","location","reload","className","styles","onSubmit","to","FormBlock","name","placeholder","onChange","target","fetchDeleteTextComment","fetchCreateVoiceRecording","audioFile","transcriptData","transcriptFinal","fetchDeleteVoiceRecording","TextComment","onClick","destroy","VoiceRecording","handleDelete","connect","setText","isRecording","setIsRecording","MicRecorder","bitRate","recorder","destroyTextCommentModifications","destroyTextComment","dispatch","destroyVoiceRecording","createTextComment","createTextCommentModification","useSpeechRecognition","transcript","resetTranscript","Chat","class","destroyModifications","create","CreateTextComment","SpeechRecognition","browserSupportsSpeechRecognition","stopListening","stop","getMp3","then","buffer","blob","file","File","lastModified","Date","now","JSON","stringify","startListening","continuous","start","fetchStreamMarkerCreate","trackUuid","fetchStreamMarkerDelete","markerUuid","fetchStreamMarkerList","fetchStreamQueueIntervalCreate","lowerBoundMarkerUuid","upperBoundMarkerUuid","isMuted","repeatCount","fetchStreamQueueIntervalDelete","queueIntervalUuid","trackMarker","deleteTrackMarker","redux","deleteQueueInterval","formMarkerTimestamp","setFormMarkerTimestamp","setLowerBoundMarkerUuid","setUpperBoundMarkerUuid","useEffect","loadData","createTrackMarker","createQueueInterval","showEditing","setShowEditing","edit","save","currentIndex","isNextUp","indent","QueueTrack","Button","isCurrentlyPlayingCollection","reveal","setReveal","toggleReveal","QueueCollection","Item","collection","Children","destroyQueueItem","Queue","fetchSearchMusicLibrary","query","providerSpotify","providerYouTube","providerJukeboxRadio","formatTrack","formatAlbum","formatPlaylist","formatVideo","fetchCreateQueue","genericUuid","SearchResult","searchResult","provider","format","addToQueue","searchResults","setSearchResults","setQuery","serviceSpotify","setServiceSpotify","serviceYouTube","setServiceYouTube","serviceJukeboxRadio","setServiceJukeboxRadio","setFormatTrack","setFormatAlbum","setFormatPlaylist","setFormatVideo","responseJsonQueueList","checked","fetchCreateTrack","imageFile","trackName","artistName","albumName","Upload","setAudioFile","setImageFile","setTrackName","setArtistName","setAlbumName","files","counter","setCounter","updateFeed","responseJsonTextCommentList","responseJsonVoiceRecordingList","handlePrevTrack","prevTrack","handleNextTrack","nextTrack","handlePlayTrack","play","handlePauseTrack","pause","handleScanBackward","seek","handleScanForward","Div","href","spotify","authorizationUrl","playerIsPlaying","setPlayerIsPlaying","shouldScheduleNextTrack","setShouldScheduleNextTrack","shouldScheduleReset","setShouldScheduleReset","nextTrackReduxJson","setNextTrackReduxJson","setNextTrackTimeoutId","setResetNextTrackTimeoutId","resetScheduledTasks","prev","clearTimeout","forced","responseJsonNextTrack","responseJsonPrevTrack","direction","system","date","epochNow","getTime","proposedStartedAt","progress","jsonResponse","resetNextTrack","externalId","nowPlayingDuration","timeoutId","setTimeout","uris","position_ms","path","SpotifyWebApi","require","App","setStatus","textCommentsJsonResponse","voiceRecordingsJsonResponse","userSettingsJsonResponse","setAccessToken","accessToken","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.eeb3aabc.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"Player\":\"Player_Player__RgpZ6\",\"Div\":\"Player_Div__HhfjS\",\"Button\":\"Player_Button__1m74t\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Upload\":\"Upload_Upload__tMDig\",\"FormBlock\":\"Upload_FormBlock__2ls6S\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"QueueCollection\":\"QueueCollection_QueueCollection__3PH8C\",\"Item\":\"QueueCollection_Item__3Kg1p\",\"Button\":\"QueueCollection_Button__1j08c\",\"Children\":\"QueueCollection_Children__U1cJx\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Login\":\"Login_Login__1ujut\",\"FormBlock\":\"Login_FormBlock__S_rix\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Search\":\"Search_Search__2SQmI\",\"FormBlock\":\"Search_FormBlock__3ZZZJ\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"QueueTrack\":\"QueueTrack_QueueTrack__14e2x\",\"Button\":\"QueueTrack_Button__cfD-Y\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Chat\":\"Chat_Chat__3NjUX\",\"ChatItem\":\"Chat_ChatItem__9P8wv\",\"ChatBar\":\"Chat_ChatBar__1jd0C\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"TextComment\":\"TextComment_TextComment__15QHu\",\"Notated\":\"TextComment_Notated__24bZz\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"VoiceRecording\":\"VoiceRecording_VoiceRecording__10J4X\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Queue\":\"Queue_Queue__YTCBa\"};","const BACKEND_DOMAIN = process.env.REACT_APP_BACKEND_DOMAIN;\nconst TYPE_GET = 'GET';\nconst TYPE_POST = 'POST';\n\nexport { BACKEND_DOMAIN, TYPE_GET, TYPE_POST }\n","import { BACKEND_DOMAIN } from '../config/global'\n\n\nasync function fetchBackend(method = '', url = '', data = {}) {\n  let response;\n\n  url = BACKEND_DOMAIN + url;\n\n  if(method !== 'GET') {\n\n    // aggregate form data in one place\n    const formData = new FormData();\n    for (const [key, value] of Object.entries(data)) {\n      formData.append(key, value);\n    }\n    // for (const [key, value] of Object.entries(files)) {\n    //   formData.append(key, value);\n    // }\n\n    // authenticate request if possible\n    let requestOptions = {headers: {}}\n    const token = localStorage.getItem('accessToken');\n    if(token) {\n      requestOptions.headers.Authorization = `Bearer ${token}`;\n    }\n    const request = new Request(url, requestOptions);\n\n    // make the request\n    response = await fetch(request, {\n      method: method,\n      mode: 'cors',\n      body: formData,\n    });\n  } else {\n\n    // translate form data for GET\n    let searchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(data)) {\n      searchParams.set(key, value);\n    }\n    const getUrl = url + '/?' + searchParams.toString();\n\n    // authenticate request if possible\n    let requestOptions = {headers: {'Content-Type': 'application/json'}}\n    const token = localStorage.getItem('accessToken');\n    if(token) {\n      requestOptions.headers.Authorization = `Bearer ${token}`;\n    }\n    const request = new Request(getUrl, requestOptions);\n\n    // make the request\n    response = await fetch(request, {\n      method: method,\n      mode: 'cors',\n    });\n  }\n\n  return response;\n}\n\nexport { fetchBackend }\n","import {\n  ENDPOINT_TEXT_COMMENT_CREATE,\n  ENDPOINT_TEXT_COMMENT_LIST,\n  ENDPOINT_VOICE_RECORDING_LIST\n} from '../../config/api'\nimport { TYPE_GET, TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n\n/*\n * Fetches...\n */\nexport const fetchTextCommentCreate = async (text) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_TEXT_COMMENT_CREATE,\n    {text: text},\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nexport const fetchTextCommentList = async () => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_TEXT_COMMENT_LIST\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nexport const fetchVoiceRecordingList = async () => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_VOICE_RECORDING_LIST\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","// AUTHENTICATION\nexport const ENDPOINT_OBTAIN_TOKENS = '/auth/obtain-tokens/'\nexport const ENDPOINT_REFRESH_TOKEN = '/auth/refresh-token/'\nexport const ENDPOINT_VERIFY_TOKEN = '/auth/verify-token/'\n\n// USER\nexport const ENDPOINT_USER_GET_SETTINGS = '/users/user/get-settings'\n\n// TEXT COMMENT\nexport const ENDPOINT_TEXT_COMMENT_CREATE = '/comments/text-comment/create/'\nexport const ENDPOINT_TEXT_COMMENT_UPDATE = '/comments/text-comment/update/'\nexport const ENDPOINT_TEXT_COMMENT_DELETE = '/comments/text-comment/delete/'\nexport const ENDPOINT_TEXT_COMMENT_LIST = '/comments/text-comment/list'\n\n// TEXT COMMENT MODIFICATION\nexport const ENDPOINT_TEXT_COMMENT_MODIFICATION_CREATE = '/comments/text-comment-modification/create/'\nexport const ENDPOINT_TEXT_COMMENT_MODIFICATION_LIST_DELETE = '/comments/text-comment-modification/list-delete/'\n\n// VOICE RECORDING\nexport const ENDPOINT_VOICE_RECORDING_CREATE = '/comments/voice-recording/create/'\nexport const ENDPOINT_VOICE_RECORDING_DELETE = '/comments/voice-recording/delete/'\nexport const ENDPOINT_VOICE_RECORDING_LIST = '/comments/voice-recording/list'\n\n// TRACK\nexport const ENDPOINT_TRACK_CREATE = '/music/track/create/'\n\n// MUSIC\nexport const ENDPOINT_MUSIC_SEARCH = '/music/search'\n\n// QUEUE\nexport const ENDPOINT_QUEUE_CREATE = '/streams/queue/create/'\nexport const ENDPOINT_QUEUE_DELETE = '/streams/queue/delete/'\nexport const ENDPOINT_QUEUE_LIST = '/streams/queue/list'\n\n// STREAM\nexport const ENDPOINT_STREAM_GET = '/streams/stream/get'\nexport const ENDPOINT_STREAM_INITIALIZE = '/streams/stream/initialize/'\nexport const ENDPOINT_STREAM_NEXT_TRACK = '/streams/stream/next-track/'\nexport const ENDPOINT_STREAM_PAUSE_TRACK = '/streams/stream/pause-track/'\nexport const ENDPOINT_STREAM_PLAY_TRACK = '/streams/stream/play-track/'\nexport const ENDPOINT_STREAM_PREV_TRACK = '/streams/stream/prev-track/'\nexport const ENDPOINT_STREAM_SCAN_BACKWARD = '/streams/stream/scan-backward/'\nexport const ENDPOINT_STREAM_SCAN_FORWARD = '/streams/stream/scan-forward/'\n\n// MARKER\nexport const ENDPOINT_MARKER_CREATE = '/streams/marker/create/'\nexport const ENDPOINT_MARKER_DELETE = '/streams/marker/delete/'\nexport const ENDPOINT_MARKER_LIST = '/streams/marker/list'\n\n// QUEUE INTERVAL\nexport const ENDPOINT_QUEUE_INTERVAL_CREATE = '/streams/queue-interval/create/'\nexport const ENDPOINT_QUEUE_INTERVAL_DELETE = '/streams/queue-interval/delete/'\n","import {\n  ENDPOINT_OBTAIN_TOKENS,\n  ENDPOINT_STREAM_INITIALIZE,\n  ENDPOINT_VERIFY_TOKEN,\n} from '../../config/api'\nimport { TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n/*\n * Fetches an auth token from the server.\n */\nexport const fetchAuthToken = async (username, password) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_OBTAIN_TOKENS,\n    { username: username, password: password },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n\n/*\n * Fetches an auth token from the server.\n */\nexport const fetchInitializeStream = async () => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_INITIALIZE,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n\n/*\n * Fetches...\n */\nexport const fetchVerifyToken = async () => {\n  const token = localStorage.getItem('accessToken');\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_VERIFY_TOKEN,\n    { token: token }\n  );\n  if(response.status !== 200) {\n    //throw new Error(\"Not logged in!\");\n    return undefined;\n  }\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import {\n  ENDPOINT_STREAM_GET,\n  ENDPOINT_STREAM_NEXT_TRACK,\n  ENDPOINT_STREAM_PAUSE_TRACK,\n  ENDPOINT_STREAM_PLAY_TRACK,\n  ENDPOINT_STREAM_PREV_TRACK,\n  ENDPOINT_STREAM_SCAN_BACKWARD,\n  ENDPOINT_STREAM_SCAN_FORWARD,\n} from '../../config/api'\nimport { TYPE_GET, TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n\n/*\n * Fetches...\n */\nconst fetchStreamGet = async () => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_STREAM_GET,\n  );\n  return await response.json();\n};\n\n/*\n * Fetches...\n */\nconst fetchNextTrack = async () => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_NEXT_TRACK,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nconst fetchPauseTrack = async () => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_PAUSE_TRACK,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nconst fetchPlayTrack = async () => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_PLAY_TRACK,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nconst fetchPrevTrack = async () => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_PREV_TRACK,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nconst fetchScanBackward = async () => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_SCAN_BACKWARD,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nconst fetchScanForward = async () => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_STREAM_SCAN_FORWARD,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\nexport {\n  fetchStreamGet,\n  fetchNextTrack,\n  fetchPauseTrack,\n  fetchPlayTrack,\n  fetchPrevTrack,\n  fetchScanBackward,\n  fetchScanForward,\n}\n","import { ENDPOINT_QUEUE_LIST, ENDPOINT_QUEUE_DELETE } from '../../config/api'\nimport { TYPE_GET, TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n/*\n * Fetches...\n */\nexport const fetchQueueList = async () => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_QUEUE_LIST,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches...\n */\nexport const fetchDeleteQueue = async (queueUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_QUEUE_DELETE,\n    { queueUuid: queueUuid },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import {\n  ENDPOINT_USER_GET_SETTINGS\n} from '../../config/api'\nimport { TYPE_GET } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n/*\n * Fetches an user settings from the server.\n */\nexport const fetchGetUserSettings = async () => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_USER_GET_SETTINGS,\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n","/*\n * Create a marker relevant to a queue item (track).\n */\nexport const markerCreate = function(state, action) {\n  const trackMarkerMap = { ...state.trackMarkerMap },\n        queueUuid = action.queueUuid,\n        marker = action.marker,\n        markers = [...trackMarkerMap[queueUuid], marker],\n        sortedMarkers = markers.sort((a, b) => {\n          return a.timestampMilliseconds - b.timestampMilliseconds;\n        });\n  trackMarkerMap[queueUuid] = sortedMarkers;\n  return {\n    ...state,\n    trackMarkerMap: trackMarkerMap,\n  };\n}\n\n/*\n * Delete a marker relevant to a queue item (track).\n */\nexport const markerDelete = function(state, action) {\n  const trackMarkerMap = { ...state.trackMarkerMap },\n        queueUuid = action.queueUuid,\n        marker = action.marker,\n        markers = trackMarkerMap[action.queueUuid],\n        filteredMarkers = markers.filter(m => m.uuid !== marker.uuid);\n  trackMarkerMap[queueUuid] = filteredMarkers;\n  return {\n    ...state,\n    trackMarkerMap: trackMarkerMap,\n  };\n}\n\n/*\n * Set the markers on a queue item (track).\n */\nexport const markerList = function(state, action) {\n  const queueUuid = action.queueUuid,\n        markers = action.markers,\n        trackMarkerMap = { ...state.trackMarkerMap };\n  trackMarkerMap[queueUuid] = markers;\n  return {\n    ...state,\n    trackMarkerMap: trackMarkerMap\n  };\n}\n","/*\n *\n */\nexport const playerSpotify = function(state, payload) {\n  return {\n    ...state,\n    spotifyApi: payload.spotifyApi,\n  }\n}\n","/*\n * A queue object is returned from the server with an assortment of\n * intervals. These intervals must be interpreted on the front-end\n * to put together the full picture - how long is the queue item\n * expected to play for?\n */\nexport const finalizeQueue = function(queue) {\n  const copy = { ...queue };\n\n  // Recursive case: parent node (queue item of format collection)\n  if(copy.children.length) {\n    const editedChildren = copy.children.map(finalizeQueue),\n          totalDurationMilliseconds = editedChildren.reduce((total, q) => (\n            total + q.durationMilliseconds\n          ), 0);\n    copy.children = editedChildren;\n    copy.totalDurationMilliseconds = totalDurationMilliseconds;\n    return copy;\n  }\n\n  const intervals = copy.intervals,\n        trackDurationMilliseconds = copy.track?.durationMilliseconds;\n  if(!intervals.length) {\n    copy.totalDurationMilliseconds = trackDurationMilliseconds;\n    copy.playbackIntervals = [[0, trackDurationMilliseconds]];\n    return copy;\n  }\n\n  const playbackIntervals = [];\n  let lowerBound,\n      upperBound;\n  // NOTE: here it is assumed that all intervals are muted.\n  for(const interval of intervals) {\n    if(!interval.lowerBound) {\n      lowerBound = interval.upperBound.timestampMilliseconds;\n      continue;\n    } else if(!interval.upperBound) {\n      if(!lowerBound) {\n        lowerBound = 0;\n      }\n      upperBound = interval.lowerBound.timestampMilliseconds;\n      playbackIntervals.push([lowerBound, upperBound]);\n      // Setting this value signifies that the playbackIntervals array is\n      // finished.\n      lowerBound = undefined;\n      // This is the end of the interval array anyways. Explicitly break here\n      // just for clarity.\n      break;\n    } else {\n      if(!lowerBound) {\n        lowerBound = 0;\n      }\n      upperBound = interval.lowerBound.timestampMilliseconds;\n      playbackIntervals.push([lowerBound, upperBound]);\n      lowerBound = interval.upperBound.timestampMilliseconds;\n      upperBound = undefined;\n      continue;\n    }\n  }\n\n  if(lowerBound) {\n    upperBound = trackDurationMilliseconds;\n    playbackIntervals.push([lowerBound, upperBound]);\n  }\n\n  const totalDurationMilliseconds = playbackIntervals.reduce((total, i) => (\n    total + (i[1] - i[0])\n  ), 0);\n\n  copy.totalDurationMilliseconds = totalDurationMilliseconds;\n  copy.playbackIntervals = playbackIntervals;\n\n  return copy;\n}\n\n\n/*\n * A queue object is returned from the server with an assortment of\n * intervals. These intervals must be interpreted on the front-end\n * to put together the full picture - how long is the queue item\n * expected to play for?\n */\nexport const queueListSet = function(state, payload) {\n  const lastUpQueues = payload.lastUpQueues.map(finalizeQueue),\n        nextUpQueues = payload.nextUpQueues.map(finalizeQueue),\n        _lastPlayed = state._lastPlayed;\n\n  if(_lastPlayed) {\n    lastUpQueues.push(_lastPlayed);\n  }\n\n  let stream = state.stream;\n  if(!stream.isPlaying && !stream.isPaused && stream.nowPlaying) {\n    lastUpQueues.push(stream.nowPlaying);\n    stream = { ...stream, nowPlaying: undefined }\n  }\n\n  const lastUp = (\n          !lastUpQueues.length ?\n            undefined :\n            lastUpQueues[lastUpQueues.length - 1]\n        ),\n        nextUp = (\n          !nextUpQueues.length ? undefined : (\n            !nextUpQueues[0].children.length ?\n              nextUpQueues[0] :\n              nextUpQueues[0].children[0]\n          )\n        );\n\n  return {\n    ...state,\n    stream: stream,\n    lastUp: lastUp,\n    lastUpQueues: lastUpQueues,\n    nextUp: nextUp,\n    nextUpQueues: nextUpQueues,\n  }\n}\n"," import { finalizeQueue } from './queue';\n\n\n/*\n * Used to \"findIndex\" by uuid in an array.\n */\nconst findByUuid = function(uuid) {\n  return (o => o.uuid === uuid);\n}\n\n\n/*\n * Used to \"filter\" out by uuid in an array.\n */\nconst filterByUuid = function(uuid) {\n  return (o => o.uuid !== uuid);\n}\n\n\n/*\n * Used to \"sort\" and array containing queue intervals.\n */\nconst sortQueueIntervals = function(a, b) {\n  if(!b.upperBound) {\n    return -1;\n  } else if(!a.upperBound) {\n    return 1;\n  } else {\n    return (\n      a.upperBound.timestampMilliseconds -\n      a.upperBound.timestampMilliseconds\n    );\n  }\n}\n\n\n/*\n * Create a queue interval relevant to a queue item (track).\n */\nexport const queueIntervalCreate = function(state, action) {\n  const queueInterval = action.queueInterval,\n        queueUuid = action.queueUuid,\n        parentQueueUuid = action.parentQueueUuid;\n\n  // get the queue that the queue interval belongs too.\n  let queues = state.nextUpQueues;\n  let parentIndex, index;\n  if(parentQueueUuid) {\n    parentIndex = queues.findIndex(findByUuid(parentQueueUuid));\n    queues = queues[parentIndex].children;\n  }\n  index = queues.findIndex(findByUuid(queueUuid));\n  const trackQueue = queues[index];\n\n  // add queue interval to that queue (and sort).\n  const queueIntervals = [...trackQueue.intervals, queueInterval],\n        sortedQueueIntervals = queueIntervals.sort(sortQueueIntervals);\n\n  // save the state\n  const nextUpQueues = [...state.nextUpQueues];\n  if(parentIndex) {\n    nextUpQueues[parentIndex].children[index].intervals = sortedQueueIntervals;\n  } else {\n    nextUpQueues[index].intervals = sortedQueueIntervals;\n  }\n\n  // update playback intervals\n  const finalizedNextUpQueues = nextUpQueues.map(finalizeQueue);\n\n  return {\n    ...state,\n    nextUpQueues: finalizedNextUpQueues,\n  };\n}\n\n\n/*\n * Delete a queue interval relevant to a queue item (track).\n */\nexport const queueIntervalDelete = function(state, action) {\n  const queueInterval = action.queueInterval,\n        queueUuid = action.queueUuid,\n        parentQueueUuid = action.parentQueueUuid;\n\n  // get the queue that the queue interval belongs too.\n  let queues = state.nextUpQueues;\n  let parentIndex, index;\n  if(parentQueueUuid) {\n    parentIndex = queues.findIndex(findByUuid(parentQueueUuid));\n    queues = queues[parentIndex].children;\n  }\n  index = queues.findIndex(findByUuid(queueUuid));\n  const trackQueue = queues[index];\n\n  // delete queue interval from that queue.\n  const queueIntervals = [...trackQueue.intervals],\n        filteredQueueIntervals = queueIntervals.filter(filterByUuid(queueInterval.uuid));\n\n  // save the state\n  const nextUpQueues = [...state.nextUpQueues];\n  if(parentIndex) {\n    nextUpQueues[parentIndex].children[index].intervals = filteredQueueIntervals;\n  } else {\n    nextUpQueues[index].intervals = filteredQueueIntervals;\n  }\n\n  // update playback intervals\n  const finalizedNextUpQueues = nextUpQueues.map(finalizeQueue);\n\n  return {\n   ...state,\n   nextUpQueues: finalizedNextUpQueues,\n  };\n}\n"," import { finalizeQueue } from './queue';\n\n\n/*\n * ...\n */\nexport const streamSet = function(state, payload) {\n  const stream = payload.stream,\n        nowPlaying = stream.nowPlaying,\n        obj = { ...state };\n\n  if(nowPlaying) {\n    stream.nowPlaying = finalizeQueue(nowPlaying);\n  }\n\n  obj.stream = stream;\n\n  if(!stream.isPlaying && !stream.isPaused && stream.nowPlaying) {\n    obj.lastUp = stream.nowPlaying;\n    obj._lastPlayed = stream.nowPlaying;\n    obj.stream.nowPlaying = undefined;\n  }\n\n  return obj;\n}\n\n\n/*\n * ...\n */\nexport const streamPlay = function(state, payload) {\n  const updatedPayload = {\n    stream: {\n      ...state.stream,\n      isPlaying: true,\n      isPaused: false,\n      startedAt: payload.startedAt,\n    }\n  };\n  return streamSet(state, updatedPayload);\n}\n\n\n/*\n * ...\n */\nexport const streamPause = function(state, payload) {\n  const updatedPayload = {\n    stream: {\n      ...state.stream,\n      isPlaying: false,\n      isPaused: true,\n      pausedAt: payload.pausedAt,\n    }\n  };\n  return streamSet(state, updatedPayload);\n}\n\n\n/*\n * Set the stream context.\n */\nexport const streamPrevTrack = function(state, payload) {\n  const lastUpQueues = [...state.lastUpQueues],\n        nextUpQueues = [...state.nextUpQueues],\n        lastNowPlaying = state.stream.nowPlaying,\n        nextUpQueue = nextUpQueues[0],\n        nextNowPlaying = lastUpQueues[lastUpQueues.length - 1];\n\n  const isTrackInCollection = (\n    lastNowPlaying?.parentUuid &&\n    nextUpQueue?.uuid &&\n    lastNowPlaying?.parentUuid === nextUpQueue?.uuid\n  );\n  if(lastNowPlaying) {\n    if(isTrackInCollection) {\n      nextUpQueue.children.unshift(lastNowPlaying);\n    } else {\n      nextUpQueues.unshift(lastNowPlaying);\n    }\n  }\n\n  lastUpQueues.pop();\n\n  return {\n      ...state,\n      stream: {\n        ...state.stream,\n        startedAt: payload.startedAt,\n        nowPlaying: nextNowPlaying,\n        isPlaying: true,\n        isPaused: false,\n      },\n      lastUpQueues: lastUpQueues,\n      nextUpQueues: nextUpQueues,\n      _lastPlayed: undefined,\n  };\n}\n\n\n/*\n * ...\n */\nexport const streamNextTrack = function(state, payload) {\n  const lastUpQueues = [...state.lastUpQueues],\n        nextUpQueues = [...state.nextUpQueues],\n        lastNowPlaying = state.stream.nowPlaying,\n        nextUpQueue = nextUpQueues[0],\n        nextNowPlaying = (\n          nextUpQueue ?\n            (nextUpQueue.children.length ?\n              nextUpQueue.children[0] :\n              nextUpQueue) :\n            undefined\n        );\n\n  if(lastNowPlaying) {\n    lastUpQueues.push(lastNowPlaying);\n  }\n\n  if(nextUpQueue) {\n    if(nextUpQueue.children.length) {\n      nextUpQueue.children.shift();\n      if(!nextUpQueue.children.length) {\n        nextUpQueues.shift();\n      }\n    } else {\n      nextUpQueues.shift();\n    }\n  }\n\n  return {\n      ...state,\n      stream: {\n        ...state.stream,\n        startedAt: payload.startedAt,\n        nowPlaying: nextNowPlaying,\n        isPlaying: true,\n        isPaused: false,\n      },\n      lastUpQueues: lastUpQueues,\n      nextUpQueues: nextUpQueues,\n      _lastPlayed: lastNowPlaying,\n  };\n}\n","/*\n * ...\n */\nexport const textCommentListSet = function(state, payload) {\n  const textComments = payload.textComments,\n        aggregateFeed = [...textComments, ...state.voiceRecordings];\n\n  const feed = aggregateFeed.sort((a, b) => {\n    return a.timestampMilliseconds - b.timestampMilliseconds;\n  });\n\n  return {\n    ...state,\n    textComments: payload.textComments,\n    feed: feed,\n  }\n}\n","/*\n * ...\n */\nexport const voiceRecordingListSet = function(state, payload) {\n  const voiceRecordings = payload.voiceRecordings,\n        aggregateFeed = [...state.textComments, ...voiceRecordings],\n        feed = aggregateFeed.sort((a, b) => {\n          return a.timestampMilliseconds - b.timestampMilliseconds;\n        });\n\n  return {\n    ...state,\n    voiceRecordings: payload.voiceRecordings,\n    feed: feed,\n  }\n}\n","import { createStore } from 'redux';\nimport {\n  markerCreate,\n  markerDelete,\n  markerList,\n} from './reducers/marker';\nimport { playerSpotify } from './reducers/player';\nimport { queueListSet } from './reducers/queue';\nimport {\n  queueIntervalCreate,\n  queueIntervalDelete,\n} from './reducers/queueInterval';\nimport {\n  streamSet,\n  streamPlay,\n  streamPause,\n  streamPrevTrack,\n  streamNextTrack,\n} from './reducers/stream';\nimport {\n  textCommentListSet,\n} from './reducers/textComment';\nimport {\n  voiceRecordingListSet,\n} from './reducers/voiceRecording';\n\n\nconst initialState = {\n  nextUpQueues: [],\n  lastUpQueues: [],\n  _lastPlayed: undefined,\n  textComments: [],\n  voiceRecordings: [],\n  feed: [],\n  userSettings: undefined,\n  trackMarkerMap: {},\n}\n\n\nfunction streamExpire(state, action) {\n  const stream = { ...state.stream },\n        _lastPlayed = stream.nowPlaying;\n\n  stream.isPlaying = false;\n  stream.isPaused = false;\n  stream.nowPlaying = undefined;\n\n  return { ...state, stream: stream, _lastPlayed: _lastPlayed };\n}\n\n\nfunction queueDeleteNode(state, action) {\n  const queues = state.nextUpQueues,\n        filteredQueues = queues.filter(i => i.uuid !== action.queueUuid);\n\n  return {\n    ...state,\n    nextUpQueues: filteredQueues,\n  }\n}\n\n\nfunction queueDeleteChildNode(state, action) {\n  let queues = [...state.nextUpQueues];\n  const parentIndex = queues.findIndex(i => i.uuid === action.parentUuid),\n        children = queues[parentIndex].children,\n        filteredChildren = children.filter(i => i.uuid !== action.queueUuid);\n\n  queues[parentIndex].children = filteredChildren;\n\n  if(!filteredChildren.length) {\n    queues = queues.filter(i => i.uuid !== action.parentUuid);\n  }\n\n  return {\n    ...state,\n    nextUpQueues: queues,\n  }\n}\n\n\nfunction textCommentCreate(state, action) {\n  const textComments = [...state.textComments, action.textComment],\n        aggregateFeed = [...textComments, ...state.voiceRecordings],\n        feed = aggregateFeed.sort((a, b) => {\n          return a.timestampMilliseconds - b.timestampMilliseconds;\n        });\n\n  return {\n    ...state,\n    textComments: textComments,\n    feed: feed,\n  }\n}\n\n\n// function textCommentClearModifications(state, action) {\n//   const textCommentIndex = state.textComments.findIndex(t => t.uuid === action.textCommentUuid),\n//         textComments = [...state.textComments];\n//\n//   textComments[textCommentIndex].modifications = [];\n//\n//   const aggregateFeed = [...textComments, ...state.voiceRecordings],\n//         feed = aggregateFeed.sort((a, b) => {\n//           return a.timestampMilliseconds - b.timestampMilliseconds;\n//         });\n//\n//   return {\n//     ...state,\n//     textComments: textComments,\n//     feed: feed,\n//   }\n// }\n\n\nfunction textCommentDelete(state, action) {\n  const textComments = state.textComments.filter(i => i.uuid !== action.textCommentUuid),\n        aggregateFeed = [...textComments, ...state.voiceRecordings],\n        feed = aggregateFeed.sort((a, b) => {\n          return a.timestampMilliseconds - b.timestampMilliseconds;\n        });\n\n  return {\n    ...state,\n    textComments: textComments,\n    feed: feed,\n  }\n}\n\n\nfunction voiceRecordingCreate(state, action) {\n  const voiceRecordings = [...state.voiceRecordings, action.voiceRecording],\n        aggregateFeed = [...state.textComments, ...voiceRecordings],\n        feed = aggregateFeed.sort((a, b) => {\n          return a.timestampMilliseconds - b.timestampMilliseconds;\n        });\n\n  return {\n    ...state,\n    voiceRecordings: voiceRecordings,\n    feed: feed,\n  }\n}\n\n\nfunction voiceRecordingDelete(state, action) {\n  const voiceRecordings = state.voiceRecordings.filter(i => i.uuid !== action.voiceRecordingUuid),\n        aggregateFeed = [...state.textComments, ...voiceRecordings],\n        feed = aggregateFeed.sort((a, b) => {\n          return a.timestampMilliseconds - b.timestampMilliseconds;\n        });\n\n  return {\n    ...state,\n    voiceRecordings: voiceRecordings,\n    feed: feed,\n  }\n}\n\nfunction userGetSettings(state, action) {\n  return {\n    ...state,\n    userSettings: action.userSettings,\n  }\n}\n\n\nconst reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"stream/set\":\n      return streamSet(state, action.payload);\n    case \"stream/play\":\n      return streamPlay(state, action.payload);\n    case \"stream/pause\":\n      return streamPause(state, action.payload);\n    case \"stream/prevTrack\":\n      return streamPrevTrack(state, action.payload);\n    case \"stream/nextTrack\":\n      return streamNextTrack(state, action.payload);\n    case \"stream/expire\":\n      return streamExpire(state, action);\n    case \"queue/listSet\":\n      return queueListSet(state, action.payload);\n    case \"queue/deleteNode\":\n      return queueDeleteNode(state, action);\n    case \"queue/deleteChildNode\":\n      return queueDeleteChildNode(state, action);\n    case \"textComment/listSet\":\n      return textCommentListSet(state, action.payload);\n    case \"textComment/create\":\n      return textCommentCreate(state, action);\n    case \"textComment/delete\":\n      return textCommentDelete(state, action);\n    // case \"textComment/clearModifications\":\n    //   return textCommentClearModifications(state, action);\n    case \"voiceRecording/create\":\n      return voiceRecordingCreate(state, action);\n    case \"voiceRecording/listSet\":\n      return voiceRecordingListSet(state, action.payload);\n    case \"voiceRecording/delete\":\n      return voiceRecordingDelete(state, action);\n    case \"user/get-settings\":\n      return userGetSettings(state, action);\n    case \"marker/create\":\n      return markerCreate(state, action.payload);\n    case \"marker/delete\":\n      return markerDelete(state, action.payload);\n    case \"marker/list\":\n      return markerList(state, action.payload);\n    case \"queueInterval/create\":\n      return queueIntervalCreate(state, action.payload);\n    case \"queueInterval/delete\":\n      return queueIntervalDelete(state, action.payload);\n    case \"player/spotify\":\n      return playerSpotify(state, action.payload);\n    default:\n      return state;\n  }\n}\n\n\nexport const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\n","import React, { useState } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport styles from './Login.module.css';\n\nimport { fetchAuthToken, fetchInitializeStream } from './network';\n\n\nfunction Login(props) {\n\n  /*\n   * 🏗\n   */\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [rememberMe, setRememberMe] = useState(false);\n\n  /*\n   * When the user initializes a login attempt.\n   */\n  const handleSubmit = async function(e) {\n    e.preventDefault();\n\n    const responseJson = await fetchAuthToken(username, password);\n    if(!responseJson.access || !responseJson.refresh) {\n      return;\n    }\n\n    localStorage.setItem('accessToken', responseJson.access);\n    localStorage.setItem('refreshToken', responseJson.refresh);\n\n    await fetchInitializeStream();\n\n    window.location.reload();\n  }\n\n  return (\n    <form className={styles.Login} onSubmit={async (e) => { await handleSubmit(e); }}>\n      <h3>Sign in</h3>\n      <p>If you have not created an account yet, then please <Link to=\"/signup\">Sign Up</Link> first.</p>\n\n      <label className={styles.FormBlock}>\n        Username\n        <input type=\"text\"\n               name=\"username\"\n               placeholder=\"username\"\n               value={username}\n               onChange={(e) => {setUsername(e.target.value)}} />\n      </label>\n\n      <label className={styles.FormBlock}>\n        Password\n        <input type=\"password\"\n               name=\"password\"\n               placeholder=\"password\"\n               value={password}\n               onChange={(e) => {setPassword(e.target.value)}} />\n      </label>\n\n      <label className={styles.FormBlock}>\n        <input type=\"checkbox\"\n               name=\"remember-me\"\n               value={rememberMe}\n               onChange={(e) => {setRememberMe(e.target.value)}} />\n        Remember Me\n      </label>\n\n      <div className={styles.FormBlock}>\n        <button type=\"submit\">\n          Sign In\n        </button>\n        <span><Link to=\"/forgotpassword\">Forgot Password?</Link></span>\n      </div>\n    </form>\n  );\n}\n\nexport default Login;\n","import {\n  ENDPOINT_TEXT_COMMENT_DELETE,\n  ENDPOINT_TEXT_COMMENT_UPDATE,\n  ENDPOINT_TEXT_COMMENT_MODIFICATION_LIST_DELETE,\n} from '../../config/api'\nimport { TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n\n/*\n * Fetches...\n */\nexport const fetchDeleteTextComment = async (textCommentUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_TEXT_COMMENT_DELETE,\n    { textCommentUuid: textCommentUuid },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n\n/*\n * Fetches...\n */\nexport const fetchUpdateTextComment = async (textCommentUuid, text) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_TEXT_COMMENT_UPDATE,\n    { textCommentUuid: textCommentUuid, text: text },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n\n/*\n * Fetches...\n */\nexport const fetchListDeleteTextCommentModifications = async (textCommentUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_TEXT_COMMENT_MODIFICATION_LIST_DELETE,\n    { textCommentUuid: textCommentUuid },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import { ENDPOINT_VOICE_RECORDING_CREATE, ENDPOINT_VOICE_RECORDING_DELETE } from '../../config/api'\nimport { TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n\n/*\n * Fetches...\n */\nexport const fetchCreateVoiceRecording = async (audioFile, transcriptData, transcriptFinal) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_VOICE_RECORDING_CREATE,\n    {\n      audioFile: audioFile,\n      transcriptData: transcriptData,\n      transcriptFinal: transcriptFinal,\n    },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n/*\n * Fetches an auth token from the server.\n */\nexport const fetchDeleteVoiceRecording = async (voiceRecordingUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_VOICE_RECORDING_DELETE,\n    { voiceRecordingUuid: voiceRecordingUuid },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import React from \"react\";\n// import NotableText from '../NotableText/NotableText'\nimport styles from './TextComment.module.css';\n\n\nfunction TextComment(props) {\n\n  /*\n   * 🎨\n   */\n  return (\n    <div className={styles.TextComment}>\n      {/*\n      <NotableText data={props.data} create={props.create}></NotableText>\n      */}\n\n      <span>\n        {props.data.text} &nbsp;\n      </span>\n\n      {/*\n      <button type=\"button\" onClick={async (e) => { await props.destroyModifications(props.data.uuid); }}>\n        Clear modifications\n      </button>\n      */}\n\n      <button type=\"button\" onClick={async (e) => { await props.destroy(props.data.uuid); }}>\n        Delete\n      </button>\n    </div>\n  );\n\n}\n\nexport default TextComment;\n","import React from \"react\";\nimport styles from './VoiceRecording.module.css';\nimport { fetchDeleteVoiceRecording } from './network';\n\n\nfunction VoiceRecording(props) {\n\n  /*\n   * When the user deletes a text comment.\n   */\n  const handleDelete = async function(e) {\n    e.preventDefault();\n    const voiceRecordingUuid = props.data.uuid;\n    await fetchDeleteVoiceRecording(voiceRecordingUuid);\n    await props.destroy(voiceRecordingUuid);\n  }\n\n  /*\n   * 🎨\n   */\n  const voiceRecording = props.data;\n  return (\n    <div className={styles.VoiceRecording}>\n      <p><i>\n        {\n          voiceRecording.transcriptFinal === 'null' ?\n          '<transcript not available>' : voiceRecording.transcriptFinal\n        }\n      </i></p>\n      <form onSubmit={async (e) => { await handleDelete(e); }}>\n        <button type=\"submit\">\n          Delete\n        </button>\n      </form>\n    </div>\n  );\n\n}\n\nexport default VoiceRecording;\n","import React, { useState } from \"react\";\nimport { connect } from 'react-redux'\nimport SpeechRecognition, { useSpeechRecognition } from 'react-speech-recognition';\nimport MicRecorder from 'mic-recorder-to-mp3';\nimport styles from './Chat.module.css';\nimport { fetchTextCommentCreate } from './network';\nimport {\n  fetchDeleteTextComment,\n} from '../TextComment/network';\nimport {\n  fetchCreateVoiceRecording,\n  fetchDeleteVoiceRecording,\n} from '../VoiceRecording/network';\nimport TextComment from '../TextComment/TextComment';\nimport VoiceRecording from '../VoiceRecording/VoiceRecording';\nimport {\n  CLASS_TEXT_COMMENT,\n  CLASS_VOICE_RECORDING\n} from '../../config/model';\n\n\nfunction Chat(props) {\n\n  /*\n   * 🏗\n   */\n  const [text, setText] = useState('');\n  const [isRecording, setIsRecording] = useState(false);\n  const [recorder] = useState(new MicRecorder({ bitRate: 320 }));\n  const [transcriptData] = useState([]);\n\n  /*\n   * ...\n   */\n  const destroyTextCommentModifications = () => {};\n  // const destroyTextCommentModifications = async function(textCommentUuid) {\n  //   await fetchListDeleteTextCommentModifications(textCommentUuid);\n  //   await props.dispatch({\n  //     type: 'textComment/clearModifications',\n  //     textCommentUuid: textCommentUuid,\n  //   });\n  // }\n\n  /*\n   * ...\n   */\n  const destroyTextComment = async function(textCommentUuid) {\n    // await fetchListDeleteTextCommentModifications(textCommentUuid);\n    await fetchDeleteTextComment(textCommentUuid);\n    await props.dispatch({\n      type: 'textComment/delete',\n      textCommentUuid: textCommentUuid,\n    });\n  }\n\n  /*\n   * ...\n   */\n  const destroyVoiceRecording = async function(voiceRecordingUuid) {\n    await fetchDeleteVoiceRecording(voiceRecordingUuid);\n    await props.dispatch({\n      type: 'voiceRecording/delete',\n      voiceRecordingUuid: voiceRecordingUuid,\n    });\n  }\n\n  /*\n   * When a user submits a new comment.\n   */\n  const createTextComment = async function(e) {\n    e.preventDefault();\n    const responseJson = await fetchTextCommentCreate(text);\n\n    await props.dispatch({\n      type: 'textComment/create',\n      textComment: responseJson.data,\n    });\n\n    setText('');\n  }\n\n  /*\n   * Called by a child component when the user creates a text comment\n   * modification.\n   */\n  const createTextCommentModification = () => {};\n  // const createTextCommentModification = async function(textCommentUuid, textCommentModification) {\n  //   const textCommentIndex = _textComments.findIndex(t => t.uuid === textCommentUuid);\n  //   const modifications = _textComments[textCommentIndex].modifications;\n  //\n  //   modifications.push(textCommentModification);\n  //   const sortedModifications = modifications.sort((a, b) => {\n  //     return a.startPtr - b.startPtr;\n  //   });\n  //\n  //   _textComments[textCommentIndex].modifications = sortedModifications;\n  //   _setTextComments([..._textComments]);\n  // }\n\n  const { transcript, resetTranscript } = useSpeechRecognition();\n\n  /*\n   * ...\n   */\n  const handleRecord = function() {\n    if(!isRecording) {\n      if (SpeechRecognition.browserSupportsSpeechRecognition()) {\n        SpeechRecognition.startListening({ continuous: true });\n        // BUG: https://github.com/JamesBrill/react-speech-recognition/issues/81\n        //\n        // const recognition = SpeechRecognition.getRecognition();\n        // recognition.onresult = (e) => {\n        //   recognition.onresult(e);\n        //   const timeStamp = e.timeStamp,\n        //         transcript = e.results[0][0].transcript,\n        //         confidence = e.results[0][0].confidence,\n        //         isFinal = e.results[0].isFinal;\n        //   transcriptData.push({ timeStamp, transcript, confidence, isFinal });\n        //   setTranscriptData([...transcriptData]);\n        // }\n      }\n      recorder.start();\n      setIsRecording(true);\n    } else {\n      if (SpeechRecognition.browserSupportsSpeechRecognition()) {\n        SpeechRecognition.stopListening();\n      }\n\n      recorder.stop()\n        .getMp3().then(([buffer, blob]) => {\n          (async function () {\n            const file = new File(buffer, 'voice.mp3', {\n              type: blob.type,\n              lastModified: Date.now(),\n            });\n\n            const responseJson = await fetchCreateVoiceRecording(file, JSON.stringify(transcriptData), transcript);\n\n            await props.dispatch({\n              type: 'voiceRecording/create',\n              voiceRecording: responseJson.data,\n            });\n\n            if (SpeechRecognition.browserSupportsSpeechRecognition()) {\n              resetTranscript();\n            }\n          })()\n        });\n\n      setIsRecording(false);\n    }\n  }\n\n  /*\n   * This aggregates text comments and voice recordings into one data list,\n   * sorted by track timestamp.\n   */\n  const feed = props.feed;\n\n  /*\n   * 🎨\n   */\n  return (\n    <div className={styles.Chat}>\n      <div>\n        {feed.map((value, index) => {\n          if(value.class === CLASS_TEXT_COMMENT) {\n            return <TextComment key={index} data={value} destroy={destroyTextComment} destroyModifications={destroyTextCommentModifications} create={createTextCommentModification} />\n          } else if(value.class === CLASS_VOICE_RECORDING) {\n            return <VoiceRecording key={index} data={value} destroy={destroyVoiceRecording} />\n          } else {\n            return <></>;\n          }\n        })}\n      </div>\n\n      <form className={styles.CreateTextComment} onSubmit={async (e) => { await createTextComment(e); }}>\n        <button type=\"button\" onClick={handleRecord}>\n          Record\n        </button>\n        <input type=\"text\"\n               name=\"text\"\n               placeholder=\"text\"\n               value={text}\n               onChange={(e) => { setText(e.target.value); }} />\n        <button type=\"submit\">\n          Send\n        </button>\n      </form>\n\n      <div>\n      </div>\n    </div>\n  );\n\n}\n\nconst mapStateToProps = (state) => ({\n    stream: state.stream,\n    textComments: state.textComments,\n    voiceRecordings: state.voiceRecordings,\n    feed: state.feed,\n});\n\nexport default connect(mapStateToProps)(Chat);\n","const CLASS_TEXT_COMMENT = 'TextComment'\nconst CLASS_VOICE_RECORDING = 'VoiceRecording'\n\nexport { CLASS_TEXT_COMMENT, CLASS_VOICE_RECORDING }\n","import {\n  ENDPOINT_MARKER_CREATE,\n  ENDPOINT_MARKER_DELETE,\n  ENDPOINT_MARKER_LIST,\n} from '../../config/api';\nimport { TYPE_GET, TYPE_POST } from '../../config/global';\nimport { fetchBackend } from '../../utils/network';\n\n\n/*\n * Creates a marker. The queue context is passed so the Redux state may be\n * updated.\n */\nexport const fetchStreamMarkerCreate = async (trackUuid, timestampMilliseconds, queueUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_MARKER_CREATE,\n    { trackUuid, timestampMilliseconds, queueUuid }\n  );\n  return await response.json();\n};\n\n\n/*\n * Deletes a marker. The queue context is passed so the Redux state may be\n * updated.\n */\nexport const fetchStreamMarkerDelete = async (markerUuid, queueUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_MARKER_DELETE,\n    { markerUuid, queueUuid }\n  );\n  return await response.json();\n};\n\n/*\n * Fetches a list of markers for a given track. The queue context is passed so\n * the Redux state may be updated.\n */\nexport const fetchStreamMarkerList = async (trackUuid, queueUuid) => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_MARKER_LIST,\n    { trackUuid, queueUuid }\n  );\n  return await response.json();\n};\n","import {\n  ENDPOINT_QUEUE_INTERVAL_CREATE,\n  ENDPOINT_QUEUE_INTERVAL_DELETE,\n} from '../../config/api';\nimport { TYPE_POST } from '../../config/global';\nimport { fetchBackend } from '../../utils/network';\n\n/*\n * Fetches...\n */\nexport const fetchStreamQueueIntervalCreate = async (queueUuid, lowerBoundMarkerUuid, upperBoundMarkerUuid, isMuted, repeatCount, parentQueueUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_QUEUE_INTERVAL_CREATE,\n    { queueUuid, lowerBoundMarkerUuid, upperBoundMarkerUuid, isMuted, repeatCount, parentQueueUuid }\n  );\n  return await response.json();\n};\n\n\n/*\n * Fetches...\n */\nexport const fetchStreamQueueIntervalDelete = async (queueIntervalUuid, queueUuid, parentQueueUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_QUEUE_INTERVAL_DELETE,\n    { queueIntervalUuid, queueUuid, parentQueueUuid }\n  );\n  return await response.json();\n};\n","import React from \"react\";\nimport { connect } from 'react-redux';\nimport { fetchStreamMarkerDelete } from './network';\n\n\nfunction TrackMarker(props) {\n\n  const { trackMarker, queueUuid } = props.data;\n\n  const deleteTrackMarker = async function() {\n    const responseJson = await fetchStreamMarkerDelete(\n      trackMarker.uuid, queueUuid\n    );\n    await props.dispatch(responseJson.redux);\n  }\n\n  return (\n    <div>\n      <span>\n        @ {trackMarker.timestampMilliseconds / 1000}\n      </span>\n      <button onClick={deleteTrackMarker}>Delete</button>\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({});\n\nexport default connect(mapStateToProps)(TrackMarker);\n","import React from \"react\";\nimport { connect } from 'react-redux';\nimport { fetchStreamQueueIntervalDelete } from './network';\n\n\nfunction QueueInterval(props) {\n\n  const { queueInterval, queueUuid, parentQueueUuid } = props.data;\n\n  const deleteQueueInterval = async function() {\n    const responseJson = await fetchStreamQueueIntervalDelete(\n      queueInterval.uuid, queueUuid, parentQueueUuid\n    );\n    await props.dispatch(responseJson.redux);\n  }\n\n  const lowerBound = queueInterval.lowerBound ?\n    queueInterval.lowerBound.timestampMilliseconds / 1000 : 'beginning';\n  const upperBound = queueInterval.upperBound ?\n    queueInterval.upperBound.timestampMilliseconds / 1000 : 'end';\n\n  return (\n    <div>\n      <span>\n        {lowerBound} =>\n        {upperBound}\n        ({queueInterval.isMuted ? 'muted' : 'played'})\n      </span>\n      <button onClick={deleteQueueInterval}>Delete</button>\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({});\n\nexport default connect(mapStateToProps)(QueueInterval);\n","import React, { useState, useEffect } from \"react\";\nimport { connect } from 'react-redux';\nimport {\n  fetchStreamMarkerCreate,\n  fetchStreamMarkerList,\n} from '../TrackMarker/network';\nimport {\n  fetchStreamQueueIntervalCreate,\n} from '../QueueInterval/network';\nimport TrackMarker from '../TrackMarker/TrackMarker'\nimport QueueInterval from '../QueueInterval/QueueInterval'\n\n\nfunction QueueEdit(props) {\n\n  const queue = props.data,\n        queueUuid = queue.uuid,\n        parentQueueUuid = queue.parentUuid,\n        trackMarkerMap = props.trackMarkerMap;\n\n  const markers = trackMarkerMap[queueUuid] || [];\n\n  const [formMarkerTimestamp, setFormMarkerTimestamp] = useState('');\n  const [lowerBoundMarkerUuid, setLowerBoundMarkerUuid] = useState('null');\n  const [upperBoundMarkerUuid, setUpperBoundMarkerUuid] = useState('null');\n\n  useEffect(() => {\n    async function loadData() {\n      const responseJson = await fetchStreamMarkerList(\n        queue.track.uuid, queueUuid\n      );\n      await props.dispatch(responseJson.redux);\n    }\n    loadData();\n  }, [props, queue, queueUuid])\n\n  const createTrackMarker = async function() {\n    const responseJson = await fetchStreamMarkerCreate(\n      queue.track.uuid, formMarkerTimestamp, queueUuid\n    );\n    await props.dispatch(responseJson.redux);\n    setFormMarkerTimestamp('');\n  }\n\n  const createQueueInterval = async function() {\n    const responseJson = await fetchStreamQueueIntervalCreate(\n      queue.uuid,\n      lowerBoundMarkerUuid,\n      upperBoundMarkerUuid,\n      true,\n      null,\n      parentQueueUuid,\n    );\n    await props.dispatch(responseJson.redux);\n  }\n\n  return (\n    <div>\n      <p>Markers</p>\n      {markers.map((value, index) => (\n        <TrackMarker key={index}\n                     data={{\n                       trackMarker: value,\n                       queueUuid: queueUuid,\n                     }} />\n      ))}\n      <div>\n        <input type=\"text\"\n               name=\"timestampMilliseconds\"\n               placeholder=\"timestamp\"\n               value={formMarkerTimestamp}\n               onChange={(e) => {setFormMarkerTimestamp(e.target.value)}} />\n        <button onClick={createTrackMarker}>Create Marker</button>\n      </div>\n      <p>Intervals</p>\n      {queue.intervals.map((value, index) => (\n        <QueueInterval key={index}\n                       data={{\n                         queueInterval: value,\n                         queueUuid: queueUuid,\n                         parentQueueUuid: parentQueueUuid,\n                       }} />\n      ))}\n      <div>\n        <select value={lowerBoundMarkerUuid} onChange={(e) => {setLowerBoundMarkerUuid(e.target.value)}}>\n          <option value={'null'}>Beginning</option>\n          {markers.map((value, index) => (\n            <option key={index} value={value.uuid}>@ {value.timestampMilliseconds}</option>\n          ))}\n        </select>\n        <select value={upperBoundMarkerUuid} onChange={(e) => {setUpperBoundMarkerUuid(e.target.value)}}>\n          <option value={'null'}>End</option>\n          {markers.map((value, index) => (\n            <option key={index} value={value.uuid}>@ {value.timestampMilliseconds}</option>\n          ))}\n        </select>\n        <button onClick={createQueueInterval}>Mute Interval</button>\n      </div>\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n  trackMarkerMap: state.trackMarkerMap,\n  nextUpQueues: state.nextUpQueues,\n});\n\nexport default connect(mapStateToProps)(QueueEdit);\n","import React, { useState } from \"react\";\nimport { connect } from 'react-redux'\nimport QueueEdit from '../QueueEdit/QueueEdit'\nimport styles from './QueueTrack.module.css';\n\n\nfunction QueueTrack(props) {\n\n  /*\n   * 🏗\n   */\n  const queue = props.data,\n        stream = props.stream,\n        lastUp = props.lastUp;\n\n  const [showEditing, setShowEditing] = useState(false);\n\n  const edit = async function(e) {\n    setShowEditing(true);\n  }\n\n  const save = async function(e) {\n    setShowEditing(false);\n  }\n\n  /*\n   * 🎨\n   */\n  const currentIndex = stream?.nowPlaying?.index || lastUp?.index;\n  const isNextUp = !currentIndex || currentIndex < queue.index;\n  const indent = queue.parentUuid && isNextUp ? '-' : '';\n  return (\n    <div className={styles.QueueTrack}>\n      <span>\n        {indent}\n        {queue.track.name}\n      </span>\n      {isNextUp &&\n        <>\n          <button className={styles.Button} type=\"button\" onClick={async (e) => { await props.destroy(queue); }}>\n            Delete\n          </button>\n          {!showEditing &&\n            <button className={styles.Button} type=\"button\" onClick={edit}>\n              Edit\n            </button>\n          }\n          {showEditing &&\n            <button className={styles.Button} type=\"button\" onClick={save}>\n              Done\n            </button>\n          }\n        </>\n      }\n      {showEditing &&\n        <QueueEdit data={queue}/>\n      }\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n  stream: state.stream,\n  lastUp: state.lastUp,\n});\n\nexport default connect(mapStateToProps)(QueueTrack);\n","import React, { useState } from \"react\";\nimport { connect } from 'react-redux'\nimport styles from './QueueCollection.module.css';\nimport QueueTrack from '../QueueTrack/QueueTrack'\n\n\nfunction QueueCollection(props) {\n\n  /*\n   * 🏗\n   */\n  const queue = props.data,\n        stream = props.stream,\n        lastUpQueues = props.lastUpQueues,\n        lastUp = lastUpQueues[lastUpQueues.length - 1],\n        queueUuid = props.data.uuid;\n\n  const isCurrentlyPlayingCollection = (\n    // Stream is NOW playing - \"now playing\" belongs to same parent UUID\n    (stream?.isPlaying && stream?.nowPlaying?.parentUuid === queueUuid) ||\n    // Stream is NOT playing - \"last up\" belongs to same parent UUID\n    (!stream?.isPlaying && lastUp?.parentUuid && lastUp?.parentUuid === queueUuid)\n  );\n\n\n  const [reveal, setReveal] = useState(isCurrentlyPlayingCollection);\n\n  /*\n   * When...\n   */\n  const toggleReveal = function(e) {\n    setReveal(!reveal);\n  }\n\n  /*\n   * 🎨\n   */\n  return (\n    <div className={styles.QueueCollection}>\n      <div className={styles.Item}>\n        <span>\n          {queue.collection.name}\n        </span>\n        {!isCurrentlyPlayingCollection &&\n          <button className={styles.Button} type=\"button\" onClick={async (e) => { await props.destroy(queue); }}>\n            Delete\n          </button>\n        }\n        {queue.children.length > 0 && !reveal &&\n          <button className={styles.Button} type=\"button\" onClick={toggleReveal}>\n            More\n          </button>\n        }\n        {queue.children.length > 0 && reveal &&\n          <button className={styles.Button} type=\"button\" onClick={toggleReveal}>\n            Less\n          </button>\n        }\n      </div>\n      {queue.children.length > 0 && reveal &&\n        <div className={styles.Children}>\n          {queue.children.map((value, index) => (\n            <QueueTrack key={index}\n                        data={value}\n                        destroy={props.destroy}>\n            </QueueTrack>\n          ))}\n        </div>\n      }\n    </div>\n  );\n\n}\n\nconst mapStateToProps = (state) => ({\n  stream: state.stream,\n  lastUpQueues: state.lastUpQueues,\n});\n\nexport default connect(mapStateToProps)(QueueCollection);\n","import { connect } from 'react-redux'\nimport styles from './Queue.module.css';\nimport { fetchDeleteQueue } from './network'\nimport QueueCollection from '../QueueCollection/QueueCollection'\nimport QueueTrack from '../QueueTrack/QueueTrack'\n\n\nfunction Queue(props) {\n\n  /*\n   * Called inside a child component, this first deletes the queue from the\n   * backend, then, on success, it deletes it from the front-end model and\n   * view.\n   */\n  const destroyQueueItem = async function(queue) {\n    const queueUuid = queue.uuid;\n\n    await fetchDeleteQueue(queueUuid);\n\n    const parentUuid = queue.parentUuid;\n    if(parentUuid) {\n      props.dispatch({\n        type: 'queue/deleteChildNode',\n        parentUuid: parentUuid,\n        queueUuid: queueUuid,\n      });\n    } else {\n      props.dispatch({\n        type: 'queue/deleteNode',\n        queueUuid: queueUuid,\n      });\n    }\n  }\n\n  /*\n   * 🎨\n   */\n  return (\n    <div className={styles.Queue}>\n      <p><i>Last up...</i></p>\n      <div>\n        {props.lastUpQueues.map((value, index) => {\n          if(value.track) {\n            return (\n              <QueueTrack key={index}\n                          data={value}\n                          destroy={() => {}}>\n              </QueueTrack>\n            );\n          } else {\n            return <></>;\n          }\n        })}\n      </div>\n      <div>\n        <p><i>Now playing...</i></p>\n        <p>{props.stream?.nowPlaying?.track.name}</p>\n      </div>\n      <p><i>Next up...</i></p>\n      <div>\n        {props.nextUpQueues.map((value, index) => {\n          if(value.collection) {\n            return (\n              <QueueCollection key={value.uuid}\n                               data={value}\n                               destroy={destroyQueueItem}>\n              </QueueCollection>\n            );\n          } else if(value.track) {\n            return (\n              <QueueTrack key={value.uuid}\n                          data={value}\n                          destroy={destroyQueueItem}>\n              </QueueTrack>\n            );\n          } else {\n            return <></>;\n          }\n        })}\n      </div>\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n  stream: state.stream,\n  nextUpQueues: state.nextUpQueues,\n  lastUpQueues: state.lastUpQueues,\n});\n\nexport default connect(mapStateToProps)(Queue);\n","import { ENDPOINT_MUSIC_SEARCH, ENDPOINT_QUEUE_CREATE } from '../../config/api'\nimport { TYPE_GET, TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n/*\n * Fetches an auth token from the server.\n */\nexport const fetchSearchMusicLibrary = async (query, providerSpotify, providerYouTube, providerJukeboxRadio, formatTrack, formatAlbum, formatPlaylist, formatVideo) => {\n  const response = await fetchBackend(\n    TYPE_GET,\n    ENDPOINT_MUSIC_SEARCH,\n    {\n      query,\n      providerSpotify,\n      providerYouTube,\n      providerJukeboxRadio,\n      formatTrack,\n      formatAlbum,\n      formatPlaylist,\n      formatVideo,\n    },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n\n\n/*\n * Fetches an auth token from the server.\n */\nexport const fetchCreateQueue = async (className, genericUuid) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_QUEUE_CREATE,\n    { className, genericUuid },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import React from 'react';\n\n\nfunction SearchResult(props) {\n  const searchResult = props.data;\n  return (\n    <div>\n      <span>\n        {searchResult.provider} {searchResult.format} {searchResult.name}\n      </span>\n      <button type=\"button\" onClick={async (e) => { await props.addToQueue(props.data.class, props.data.uuid); }}>\n        Add\n      </button>\n    </div>\n  );\n}\n\nexport default SearchResult;\n","import React, { useState } from \"react\";\nimport { connect } from 'react-redux';\nimport styles from './Search.module.css';\n\nimport { fetchSearchMusicLibrary, fetchCreateQueue } from './network';\nimport SearchResult from '../SearchResult/SearchResult';\nimport { fetchQueueList } from '../Queue/network';\n\n\nfunction Search(props) {\n\n  /*\n   * 🏗\n   */\n\n  const [searchResults, setSearchResults] = useState([]);\n\n  const [query, setQuery] = useState([]);\n\n  // NOTE: These could be condensed, but I prefer explicitly writing them out.\n  const [serviceSpotify, setServiceSpotify] = useState(true);\n  const [serviceYouTube, setServiceYouTube] = useState(true);\n  const [serviceJukeboxRadio, setServiceJukeboxRadio] = useState(true);\n\n  const [formatTrack, setFormatTrack] = useState(true);\n  const [formatAlbum, setFormatAlbum] = useState(true);\n  const [formatPlaylist, setFormatPlaylist] = useState(true);\n  const [formatVideo, setFormatVideo] = useState(true);\n\n  /*\n   * When the user initializes a login attempt.\n   */\n  const handleSubmit = async function(e) {\n    e.preventDefault();\n    const responseJson = await fetchSearchMusicLibrary(\n      query,\n      serviceSpotify,\n      serviceYouTube,\n      serviceJukeboxRadio,\n      formatTrack,\n      formatAlbum,\n      formatPlaylist,\n      formatVideo,\n    );\n    setSearchResults(responseJson.data);\n  }\n\n  /*\n   * When...\n   */\n  const addToQueue = async function(className, genericUuid) {\n    await fetchCreateQueue(\n      className,\n      genericUuid,\n    );\n\n    setSearchResults([]);\n\n    const responseJsonQueueList = await fetchQueueList();\n    await props.dispatch(responseJsonQueueList.redux);\n  }\n\n  return (\n    <div>\n      <form className={styles.Login} onSubmit={async (e) => { await handleSubmit(e); }}>\n        <h3>Search</h3>\n\n        <label className={styles.FormBlock}>\n          Query &nbsp;\n          <input type=\"text\"\n                 name=\"query\"\n                 placeholder=\"\"\n                 value={query}\n                 onChange={(e) => {setQuery(e.target.value)}} />\n        </label>\n\n        <br></br>\n\n        <div className={styles.FormBlock}>\n          <label>\n            <input type=\"checkbox\"\n                   checked={serviceSpotify}\n                   onChange={(e) => {setServiceSpotify(e.target.checked)}} />\n            Spotify\n          </label>\n\n          <label>\n            <input type=\"checkbox\"\n                   name=\"provider.youTube\"\n                   checked={serviceYouTube}\n                   onChange={(e) => {setServiceYouTube(e.target.checked)}} />\n            YouTube\n          </label>\n\n          <label>\n            <input type=\"checkbox\"\n                   name=\"provider.jukeboxRadio\"\n                   checked={serviceJukeboxRadio}\n                   onChange={(e) => {setServiceJukeboxRadio(e.target.checked)}} />\n            Jukebox Radio\n          </label>\n        </div>\n\n        <div className={styles.FormBlock}>\n          <label>\n            <input type=\"checkbox\"\n                   checked={formatTrack}\n                   onChange={(e) => {setFormatTrack(e.target.checked)}} />\n            Track\n          </label>\n\n          <label>\n            <input type=\"checkbox\"\n                   checked={formatAlbum}\n                   onChange={(e) => {setFormatAlbum(e.target.checked)}} />\n            Album\n          </label>\n\n          <label>\n            <input type=\"checkbox\"\n                   checked={formatPlaylist}\n                   onChange={(e) => {setFormatPlaylist(e.target.checked)}} />\n            Playlist\n          </label>\n\n          <label>\n            <input type=\"checkbox\"\n                   checked={formatVideo}\n                   onChange={(e) => {setFormatVideo(e.target.checked)}} />\n            Video\n          </label>\n        </div>\n\n        <br></br>\n\n        <div className={styles.FormBlock}>\n          <button type=\"submit\">\n            Search\n          </button>\n        </div>\n      </form>\n\n      <br></br>\n\n      <div>\n        {searchResults.map((value, index) => (\n          <SearchResult key={index} data={value} addToQueue={addToQueue}></SearchResult>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({});\n\nexport default connect(mapStateToProps)(Search);\n","import { ENDPOINT_TRACK_CREATE } from '../../config/api'\nimport { TYPE_POST } from '../../config/global'\nimport { fetchBackend } from '../../utils/network'\n\n/*\n * Fetches...\n */\nexport const fetchCreateTrack = async (audioFile, imageFile, trackName, artistName, albumName) => {\n  const response = await fetchBackend(\n    TYPE_POST,\n    ENDPOINT_TRACK_CREATE,\n    {\n      audioFile: audioFile,\n      imageFile: imageFile,\n      trackName: trackName,\n      artistName: artistName,\n      albumName: albumName,\n    },\n  );\n  const responseJson = await response.json();\n  return responseJson;\n};\n","import React, { useState } from \"react\";\nimport styles from './Upload.module.css';\n\nimport { fetchCreateTrack } from './network';\n\n\nfunction Upload(props) {\n\n  /*\n   * 🏗\n   */\n  const [audioFile, setAudioFile] = useState('');\n  const [imageFile, setImageFile] = useState('');\n  const [trackName, setTrackName] = useState('');\n  const [artistName, setArtistName] = useState('');\n  const [albumName, setAlbumName] = useState('');\n\n  /*\n   * When the user initializes a login attempt.\n   */\n  const handleSubmit = async function(e) {\n    e.preventDefault();\n    await fetchCreateTrack(\n      audioFile,\n      imageFile,\n      trackName,\n      artistName,\n      albumName,\n    );\n    setTrackName('');\n    setArtistName('');\n    setAlbumName('');\n  }\n\n  return (\n    <form className={styles.Login} onSubmit={async (e) => { await handleSubmit(e); }}>\n      <h3>Upload</h3>\n\n      <label className={styles.FormBlock}>\n        Audio file\n        <input type=\"file\"\n               name=\"audioFile\"\n               onChange={(e) => {setAudioFile(e.target.files[0])}} />\n      </label>\n\n      <label className={styles.FormBlock}>\n        Image file\n        <input type=\"file\"\n               name=\"imageFile\"\n               onChange={(e) => {setImageFile(e.target.files[0])}} />\n      </label>\n\n      <br></br>\n\n      <label className={styles.FormBlock}>\n        Track name\n        <input type=\"text\"\n               name=\"trackName\"\n               placeholder=\"Track name\"\n               value={trackName}\n               onChange={(e) => {setTrackName(e.target.value)}} />\n      </label>\n\n      <label className={styles.FormBlock}>\n        Artist name\n        <input type=\"text\"\n               name=\"artistName\"\n               placeholder=\"Artist name\"\n               value={artistName}\n               onChange={(e) => {setArtistName(e.target.value)}} />\n      </label>\n\n      <label className={styles.FormBlock}>\n        Album name\n        <input type=\"text\"\n               name=\"albumName\"\n               placeholder=\"Album name\"\n               value={albumName}\n               onChange={(e) => {setAlbumName(e.target.value)}} />\n      </label>\n\n      <br></br>\n\n      <div className={styles.FormBlock}>\n        <button type=\"submit\">\n          Submit\n        </button>\n      </div>\n    </form>\n  );\n}\n\nexport default Upload;\n","import { useState } from \"react\";\nimport { connect } from 'react-redux'\n// import { CountdownCircleTimer } from 'react-countdown-circle-timer'\nimport styles from './Player.module.css';\nimport { fetchTextCommentList, fetchVoiceRecordingList } from '../Chat/network';\n\n\nfunction Player(props) {\n\n  /*\n   * 🏗\n   */\n  const stream = props.stream,\n        track = stream?.nowPlaying?.track,\n        lastUpQueues = props.lastUpQueues,\n        lastUp = lastUpQueues[lastUpQueues.length - 1],\n        nextUpQueues = props.nextUpQueues,\n        nextUp = (\n          nextUpQueues.length ?\n            (nextUpQueues[0].children.length ?\n              nextUpQueues[0].children[0] :\n              nextUpQueues[0]) :\n            undefined\n        );\n\n  const [counter, setCounter] = useState(0);\n\n  /*\n   * A function used to calculate time elapsed since the now playing track was\n   * started.\n   */\n  const getProgress = function() {\n    if(stream?.isPaused) {\n      return stream.pausedAt - stream.startedAt;\n    } else if(stream?.isPlaying) {\n      return Date.now() - stream.startedAt;\n    } else {\n      return undefined;\n    }\n  };\n\n  /*\n   * Load comments and voice recordings to update the feed.\n   */\n  const updateFeed = async function() {\n    const responseJsonTextCommentList = await fetchTextCommentList();\n    const responseJsonVoiceRecordingList = await fetchVoiceRecordingList();\n    await props.dispatch(responseJsonTextCommentList.redux);\n    await props.dispatch(responseJsonVoiceRecordingList.redux);\n  };\n\n  /*\n   * Go back and play the track that was last playing.\n   */\n  const handlePrevTrack = async function() {\n    props.prevTrack();\n    await updateFeed();\n  }\n\n  /*\n   * When...\n   */\n  const handleNextTrack = async function() {\n    await props.nextTrack(true);\n    await updateFeed();\n  }\n\n  /*\n   * When...\n   */\n  const handlePlayTrack = async function() {\n    props.play();\n  }\n\n  /*\n   * When...\n   */\n  const handlePauseTrack = async function() {\n    props.pause();\n  }\n\n  /*\n   * When...\n   */\n  const handleScanBackward = async function() {\n    await props.seek('backward');\n  }\n\n  /*\n   * When...\n   */\n  const handleScanForward = async function() {\n    await props.seek('forward');\n  }\n\n  const handleRefreshProgress = function() {\n    setCounter(counter + 1);\n  }\n\n  /*\n   * When...\n   */\n  // const handleIdle = async function() {\n  //   await props.dispatch({\n  //     type: \"stream/expire\",\n  //   });\n  //\n  //   await props.dispatch({\n  //     type: \"queue/listSet\",\n  //     lastUpQueues: props.lastUpQueues,\n  //     nextUpQueues: props.nextUpQueues,\n  //   });\n  // }\n\n  /*\n   * Schedule next section\n   */\n\n  // BUG: edge case needed to refresh the webpage. In the future, there should\n  //      be an API endpoint to fetch additional past queue items.\n  if(stream?.nowPlaying?.index !== 1 && !lastUp) {\n    window.location.reload();\n  }\n\n  return (\n    <>\n      <div className={styles.Div}>\n        <p><i>Last...</i></p>\n        <p>{lastUp?.track?.name}</p>\n      </div>\n\n      <div className={styles.Div}>\n        <p><i>Now playing...</i></p>\n        {(stream?.isPlaying || stream?.isPaused) &&\n          <p>{track?.name}</p>\n        }\n        {(!stream?.isPlaying && !stream?.isPaused) &&\n          <p>Waiting...</p>\n        }\n      </div>\n\n      <div className={styles.Div}>\n        <p><i>Next...</i></p>\n        <p>{nextUp?.track.name}</p>\n      </div>\n\n      <div className={styles.Div}>\n        {getProgress()}\n      </div>\n\n      <div className={styles.Div}>\n        <button className={styles.Button} onClick={handlePrevTrack}>Prev</button>\n        {stream?.isPaused &&\n          <button className={styles.Button} onClick={handlePlayTrack}>Play</button>\n        }\n        {stream?.isPlaying &&\n          <button className={styles.Button} onClick={handlePauseTrack}>Pause</button>\n        }\n        <button className={styles.Button} onClick={handleNextTrack}>Next</button>\n      </div>\n      <div className={styles.Div}>\n        {(stream?.isPlaying) &&\n          <button className={styles.Button} onClick={handleScanBackward}>Backward</button>\n        }\n        {(stream?.isPlaying) &&\n          <button className={styles.Button} onClick={handleScanForward}>Forward</button>\n        }\n        {(stream?.isPlaying) &&\n          <button className={styles.Button} onClick={handleRefreshProgress}>Progress</button>\n        }\n      </div>\n    </>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n    stream: state.stream,\n    lastUpQueues: state.lastUpQueues,\n    nextUpQueues: state.nextUpQueues,\n});\n\nexport default connect(mapStateToProps)(Player);\n","import React from \"react\";\nimport { connect } from 'react-redux';\n\nfunction UserSettings(props) {\n  if (!props.userSettings) {\n    return <></>;\n  }\n\n  return (\n    <a href={props.userSettings.spotify.authorizationUrl}>Connect Your Spotify Account</a>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n  userSettings: state.userSettings,\n});\n\nexport default connect(mapStateToProps)(UserSettings);\n","import { useEffect, useState } from \"react\";\nimport { connect } from 'react-redux'\n// import { CountdownCircleTimer } from 'react-countdown-circle-timer'\n// import styles from './PlaybackWrapper.module.css';\nimport {\n  Switch,\n  Route,\n} from \"react-router-dom\";\n\nimport Chat from '../Chat/Chat';\nimport Queue from '../Queue/Queue';\nimport Search from '../Search/Search';\nimport Upload from '../Upload/Upload';\nimport Player from '../Player/Player';\nimport UserSettings from '../UserSettings/UserSettings';\nimport {\n  fetchNextTrack,\n  fetchPrevTrack,\n  fetchScanBackward,\n  fetchScanForward,\n  fetchPauseTrack,\n  fetchPlayTrack,\n} from '../Player/network';\n\n\nfunction PlaybackWrapper(props) {\n\n  const stream = props.stream,\n        spotifyApi = props.spotifyApi,\n        nextUpQueues = props.nextUpQueues,\n        nextUp = (\n          nextUpQueues.length ?\n            (nextUpQueues[0].children.length ?\n              nextUpQueues[0].children[0] :\n              nextUpQueues[0]) :\n            undefined\n        );\n\n  const [playerIsPlaying, setPlayerIsPlaying] = useState(false);\n  const [shouldScheduleNextTrack, setShouldScheduleNextTrack] = useState(false);\n  const [shouldScheduleReset, setShouldScheduleReset] = useState(false);\n\n  const [nextTrackReduxJson, setNextTrackReduxJson] = useState({});\n\n  // eslint-disable-next-line\n  const [nextTrackTimeoutId, setNextTrackTimeoutId] = useState(undefined);\n  // eslint-disable-next-line\n  const [resetNextTrackTimeoutId, setResetNextTrackTimeoutId] = useState(undefined);\n\n  const resetScheduledTasks = function() {\n    setNextTrackTimeoutId(prev => {\n      clearTimeout(prev);\n      return undefined;\n    });\n\n    setResetNextTrackTimeoutId(prev => {\n      clearTimeout(prev);\n      return undefined;\n    });\n  }\n\n  const start = function() {\n    setPlayerIsPlaying(true);\n\n    const progress = Date.now() - stream.startedAt;\n\n    if(!stream.nowPlaying.track) {\n      return;\n    }\n\n    spotifyApi.play({\n      uris: [stream.nowPlaying.track.externalId],\n      position_ms: progress,\n    });\n\n    setShouldScheduleNextTrack(true);\n  }\n\n  const nextTrack = async function(forced = false) {\n    const responseJsonNextTrack = await fetchNextTrack();\n    if(forced) {\n      await props.dispatch(responseJsonNextTrack.redux);\n      await setNextTrackReduxJson({});\n      resetScheduledTasks();\n      await setPlayerIsPlaying(false);\n      return;\n    }\n    setNextTrackReduxJson(responseJsonNextTrack.redux);\n    setShouldScheduleReset(true);\n    addToQueue();\n  }\n\n  const prevTrack = async function() {\n    const responseJsonPrevTrack = await fetchPrevTrack();\n    await props.dispatch(responseJsonPrevTrack.redux);\n    await setNextTrackReduxJson({});\n    resetScheduledTasks();\n    await setPlayerIsPlaying(false);\n  }\n\n  const seek = async function(direction) {\n    let startedAt;\n    if(direction === 'forward') {\n      const response = await fetchScanForward();\n\n      if(response.system.status === 400) {\n        return;\n      }\n\n      startedAt = stream.startedAt - (10000);\n    } else if(direction === 'backward') {\n      await fetchScanBackward();\n\n      const date = new Date(),\n            epochNow = date.getTime();\n\n      const proposedStartedAt = stream.startedAt + 10000,\n            proposedProgress = epochNow - proposedStartedAt;\n\n      startedAt = proposedProgress > 0 ? proposedStartedAt : epochNow;\n    }\n\n    await props.dispatch({\n      type: 'stream/set',\n      payload: {stream: { ...stream, startedAt: startedAt }},\n    });\n\n    const progress = Date.now() - startedAt;\n    spotifyApi.seek(progress);\n\n    resetScheduledTasks();\n    setShouldScheduleNextTrack(true);\n  }\n\n  const pause = async function() {\n    const jsonResponse = await fetchPauseTrack();\n    props.dispatch(jsonResponse.redux);\n\n    // NOTE: this is not called because it would \"start\" the song again\n    // setPlayerIsPlaying(false);\n\n    resetScheduledTasks();\n\n    spotifyApi.pause();\n  }\n\n  const play = async function() {\n    const jsonResponse = await fetchPlayTrack();\n    await props.dispatch(jsonResponse.redux);\n\n    if(!playerIsPlaying) {\n      // TODO this case isn't working needs refactor\n      return;\n    }\n\n    spotifyApi.play();\n    // NOTE: this is not called because it would \"start\" the song again\n    // setPlayerIsPlaying(true);\n    setShouldScheduleNextTrack(true);\n  }\n\n  const resetNextTrack = async function() {\n    await props.dispatch(nextTrackReduxJson);\n    await setNextTrackReduxJson({});\n    await setShouldScheduleNextTrack(true);\n  }\n\n  const addToQueue = function() {\n    spotifyApi.queue(nextUp.track.externalId);\n  }\n\n  // Will schedule task to queue up the next track near the end of the\n  // currently playing track.\n  useEffect(() => {\n    // check\n    if(!shouldScheduleNextTrack) {\n      return;\n    }\n    setShouldScheduleNextTrack(false);\n\n    // calculations\n    const nowPlayingDuration = stream.nowPlaying.totalDurationMilliseconds,\n          progress = Date.now() - stream.startedAt,\n          timeout = nowPlayingDuration - progress - 5000;\n\n    // schedule\n    const timeoutId = setTimeout(() => {\n      nextTrack();\n    }, timeout);\n\n    setNextTrackTimeoutId(timeoutId);\n\n  // eslint-disable-next-line\n  }, [shouldScheduleNextTrack]);\n\n  // Will schedule a task to reset the cycle at the end of the currently\n  // playing track.\n  useEffect(() => {\n    if(!shouldScheduleReset) {\n      return;\n    }\n    setShouldScheduleReset(false);\n    const nowPlayingDuration = stream.nowPlaying.totalDurationMilliseconds,\n          progress = Date.now() - stream.startedAt,\n          timeout = nowPlayingDuration - progress;\n\n    const timeoutId = setTimeout(() => {\n      resetNextTrack();\n    }, timeout);\n\n    setResetNextTrackTimeoutId(timeoutId);\n\n  // eslint-disable-next-line\n  }, [shouldScheduleReset]);\n\n  // Play the music.\n  if(stream.isPlaying && !playerIsPlaying) {\n    start();\n  }\n\n  return (\n    <>\n    <Switch>\n      <Route path=\"/settings\">\n        <UserSettings />\n      </Route>\n      <Route path=\"/chat\">\n        <Chat />\n      </Route>\n      <Route path=\"/player\">\n        <Player nextTrack={nextTrack}\n                prevTrack={prevTrack}\n                seek={seek}\n                pause={pause}\n                play={play} />\n      </Route>\n      <Route path=\"/queue\">\n        <Queue />\n      </Route>\n      <Route path=\"/search\">\n        <Search />\n      </Route>\n      <Route path=\"/upload\">\n        <Upload />\n      </Route>\n    </Switch>\n    </>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n    stream: state.stream,\n    spotifyApi: state.spotifyApi,\n    nextUpQueues: state.nextUpQueues,\n});\n\nexport default connect(mapStateToProps)(PlaybackWrapper);\n","import './App.css';\nimport {\n  fetchTextCommentList,\n  fetchVoiceRecordingList,\n} from './components/Chat/network';\nimport { fetchVerifyToken } from './components/Login/network'\nimport { fetchStreamGet } from './components/Player/network';\nimport { fetchQueueList } from './components/Queue/network'\nimport { fetchGetUserSettings } from './components/UserSettings/network'\nimport { store } from './utils/redux'\nimport Login from './components/Login/Login';\nimport PlaybackWrapper from './components/PlaybackWrapper/PlaybackWrapper';\nimport { useEffect, useState } from \"react\";\nimport { Provider } from 'react-redux';\nimport {\n  BrowserRouter as Router,\n  Link\n} from \"react-router-dom\";\n\nconst SpotifyWebApi = require('spotify-web-api-js');\n\n\nfunction App() {\n\n  // keeps track of the status of the webpage\n  //  - initial: when the page is first loaded\n  //  - unauthenticated: the client does NOT have a valid access token\n  //  - authenticated: the client has a valid access token\n  //  - ready: all API data has been loaded\n  const [status, setStatus] = useState('initial');\n\n  // componentDidMount\n  useEffect(() => {\n    async function loadData() {\n      let responseJson;\n\n      // verify authentication\n      const authResponse = await fetchVerifyToken();\n        if (!authResponse) {\n          setStatus('unauthenticated');\n          return;\n        }\n\n      // set state\n      setStatus('authenticated');\n\n      // load stream\n      responseJson = await fetchStreamGet();\n      await store.dispatch(responseJson.redux);\n\n      // load queue\n      responseJson = await fetchQueueList();\n      await store.dispatch(responseJson.redux);\n\n      // load comments\n      const textCommentsJsonResponse = await fetchTextCommentList();\n      await store.dispatch(textCommentsJsonResponse.redux);\n\n      // load voice recordings\n      const voiceRecordingsJsonResponse = await fetchVoiceRecordingList();\n      await store.dispatch(voiceRecordingsJsonResponse.redux);\n\n      // get user settings\n      const userSettingsJsonResponse = await fetchGetUserSettings();\n      await store.dispatch({\n        type: 'user/get-settings',\n        userSettings: userSettingsJsonResponse.data,\n      });\n\n      // initialize Spotify player\n      const spotifyApi = new SpotifyWebApi();\n      spotifyApi.setAccessToken(userSettingsJsonResponse.data.spotify.accessToken);\n      await store.dispatch({\n        type: 'player/spotify',\n        payload: { spotifyApi: spotifyApi },\n      });\n\n      setStatus('ready');\n    }\n    loadData();\n  }, []);\n\n  // as the page is loading, display nothing\n  if(status === 'initial') {\n    return (\n      <Router>\n        <Provider store={store}>\n          <></>\n        </Provider>\n      </Router>\n    );\n  }\n\n  // if the user is not authenticated, only display the login portal\n  if(status === 'unauthenticated') {\n    return (\n      <Router>\n        <Provider store={store}>\n          <div className=\"app-main-container\">\n            <div className=\"app-main\">\n              <Login />\n            </div>\n          </div>\n        </Provider>\n      </Router>\n    )\n  }\n\n  // if the user is not authenticated, only display the login portal\n  if(status === 'authenticated') {\n    return (\n      <Router>\n        <Provider store={store}>\n          Loading...\n        </Provider>\n      </Router>\n    )\n  }\n\n  // display the main UI now that everything is loaded up\n  return (\n    <Router>\n      <Provider store={store}>\n\n        {/* nav bar */}\n        <nav>\n          <ul>\n            <li>\n              <Link to=\"/settings\">Settings</Link>\n            </li>\n            <li>\n              <Link to=\"/chat\">Chat</Link>\n            </li>\n            <li>\n              <Link to=\"/player\">Player</Link>\n            </li>\n            <li>\n              <Link to=\"/queue\">Queue</Link>\n            </li>\n            <li>\n              <Link to=\"/search\">Search</Link>\n            </li>\n            <li>\n              <Link to=\"/upload\">Upload</Link>\n            </li>\n          </ul>\n        </nav>\n\n        {/* main section */}\n        <div className=\"app-main-container\">\n          <div className=\"app-main\">\n            <PlaybackWrapper />\n          </div>\n        </div>\n\n      </Provider>\n    </Router>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}